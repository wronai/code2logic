{
  "name": "code2logic",
  "statistics": {
    "files": 53,
    "lines": 21971,
    "languages": {
      "python": 53
    }
  },
  "entrypoints": [
    "llm_profiler.py",
    "config.py",
    "project_reproducer.py",
    "base.py",
    "llm.py",
    "quality.py",
    "reproducer.py",
    "prompts.py",
    "chunked_reproduction.py",
    "__init__.py"
  ],
  "modules": [
    {
      "path": "llm_profiler.py",
      "language": "python",
      "lines": 490,
      "classes": [
        {
          "name": "LLMProfile",
          "bases": [],
          "docstring": "Profile of LLM capabilities for code reproduction.",
          "methods": [
            {
              "name": "__post_init__",
              "signature": "()",
              "intent": "creates init",
              "is_async": false
            }
          ]
        },
        {
          "name": "ProfileTestResult",
          "bases": [],
          "docstring": "Result of a single profile test."
        },
        {
          "name": "LLMProfiler",
          "bases": [],
          "docstring": "Profile LLM capabilities for code reproduction.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client,verbose:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "run_profile",
              "signature": "(quick:bool=False)->LLMProfile",
              "intent": "starts profile",
              "is_async": false
            },
            {
              "name": "_test_reproduction",
              "signature": "(name:str,code:str)->ProfileTestResult",
              "intent": "checks reproduction",
              "is_async": false
            },
            {
              "name": "_code_to_spec",
              "signature": "(code:str)->str",
              "intent": "code to spec",
              "is_async": false
            },
            {
              "name": "_extract_code",
              "signature": "(response:str)->str",
              "intent": "parses code",
              "is_async": false
            },
            {
              "name": "_check_syntax",
              "signature": "(code:str)->bool",
              "intent": "checks syntax",
              "is_async": false
            },
            {
              "name": "_calculate_similarity",
              "signature": "(original:str,reproduced:str)->float",
              "intent": "processes similarity",
              "is_async": false
            },
            {
              "name": "_calculate_metrics",
              "signature": "(profile:LLMProfile,results:List[ProfileTestResult])->LLMProfile",
              "intent": "processes metrics",
              "is_async": false
            },
            {
              "name": "_test_consistency",
              "signature": "(profile:LLMProfile)->LLMProfile",
              "intent": "checks consistency",
              "is_async": false
            }
          ]
        },
        {
          "name": "AdaptiveChunker",
          "bases": [],
          "docstring": "Adaptive chunking based on LLM profile.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(profile:Optional[LLMProfile]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "get_optimal_settings",
              "signature": "()->Dict[str, Any]",
              "intent": "retrieves optimal settings",
              "is_async": false
            },
            {
              "name": "chunk_spec",
              "signature": "(spec:str,format:str='yaml')->List[Dict[str, Any]]",
              "intent": "chunk spec",
              "is_async": false
            },
            {
              "name": "recommend_format",
              "signature": "(spec_size_tokens:int)->str",
              "intent": "recommend format",
              "is_async": false
            },
            {
              "name": "estimate_chunks_needed",
              "signature": "(spec_size_tokens:int)->int",
              "intent": "estimate chunks needed",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_get_profiles_path",
          "signature": "()->Path",
          "intent": "retrieves profiles path",
          "is_async": false
        },
        {
          "name": "load_profiles",
          "signature": "()->Dict[str, LLMProfile]",
          "intent": "retrieves profiles",
          "is_async": false
        },
        {
          "name": "save_profile",
          "signature": "(profile:LLMProfile)->None",
          "intent": "caches profile",
          "is_async": false
        },
        {
          "name": "get_profile",
          "signature": "(provider:str,model:str)->Optional[LLMProfile]",
          "intent": "retrieves profile",
          "is_async": false
        },
        {
          "name": "get_or_create_profile",
          "signature": "(provider:str,model:str)->LLMProfile",
          "intent": "retrieves or create profile",
          "is_async": false
        },
        {
          "name": "_create_default_profile",
          "signature": "(provider:str,model:str)->LLMProfile",
          "intent": "creates default profile",
          "is_async": false
        },
        {
          "name": "profile_llm",
          "signature": "(client,quick:bool=False)->LLMProfile",
          "intent": "profile llm",
          "is_async": false
        },
        {
          "name": "get_adaptive_chunker",
          "signature": "(provider:str,model:str)->AdaptiveChunker",
          "intent": "retrieves adaptive chunker",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "time",
        "hashlib",
        "dataclasses.dataclass",
        "dataclasses.field",
        "dataclasses.asdict",
        "datetime",
        "typing.Dict",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "PROFILE_TEST_CASES",
        "LLMProfile",
        "ProfileTestResult",
        "load_profiles",
        "save_profile",
        "get_profile",
        "get_or_create_profile",
        "LLMProfiler",
        "AdaptiveChunker",
        "profile_llm"
      ]
    },
    {
      "path": "config.py",
      "language": "python",
      "lines": 168,
      "classes": [
        {
          "name": "Config",
          "bases": [],
          "docstring": "Configuration manager for Code2Logic.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(env_file:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_load_env_file",
              "signature": "(env_file:str=None)",
              "intent": "retrieves env file",
              "is_async": false
            },
            {
              "name": "_parse_env_file",
              "signature": "(path:Path)",
              "intent": "parses env file",
              "is_async": false
            },
            {
              "name": "_load_config_file",
              "signature": "()",
              "intent": "retrieves config file",
              "is_async": false
            },
            {
              "name": "get_api_key",
              "signature": "(provider:str)->Optional[str]",
              "intent": "retrieves api key",
              "is_async": false
            },
            {
              "name": "get_model",
              "signature": "(provider:str)->str",
              "intent": "retrieves model",
              "is_async": false
            },
            {
              "name": "get_ollama_host",
              "signature": "()->str",
              "intent": "retrieves ollama host",
              "is_async": false
            },
            {
              "name": "get_default_provider",
              "signature": "()->str",
              "intent": "retrieves default provider",
              "is_async": false
            },
            {
              "name": "is_verbose",
              "signature": "()->bool",
              "intent": "is verbose",
              "is_async": false
            },
            {
              "name": "get_cache_dir",
              "signature": "()->Path",
              "intent": "retrieves cache dir",
              "is_async": false
            },
            {
              "name": "list_configured_providers",
              "signature": "()->Dict[str, bool]",
              "intent": "list configured providers",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "load_env",
          "signature": "()",
          "intent": "retrieves env",
          "is_async": false
        },
        {
          "name": "get_api_key",
          "signature": "(provider:str)->Optional[str]",
          "intent": "retrieves api key",
          "is_async": false
        },
        {
          "name": "get_model",
          "signature": "(provider:str)->str",
          "intent": "retrieves model",
          "is_async": false
        }
      ],
      "imports": [
        "os",
        "json",
        "pathlib.Path",
        "typing.Optional",
        "typing.Dict",
        "typing.Any"
      ],
      "exports": [
        "Config",
        "load_env",
        "get_api_key",
        "get_model",
        "SHELL_COMMANDS"
      ]
    },
    {
      "path": "file_formats.py",
      "language": "python",
      "lines": 278,
      "classes": [],
      "functions": [
        {
          "name": "generate_file_csv",
          "signature": "(file_path:Path)->str",
          "intent": "creates file csv",
          "is_async": false
        },
        {
          "name": "generate_file_json",
          "signature": "(file_path:Path)->str",
          "intent": "creates file json",
          "is_async": false
        },
        {
          "name": "generate_file_yaml",
          "signature": "(file_path:Path)->str",
          "intent": "creates file yaml",
          "is_async": false
        },
        {
          "name": "_parse_file_elements",
          "signature": "(content:str)->Dict[str, Any]",
          "intent": "parses file elements",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "pathlib.Path",
        "typing.Dict",
        "typing.Any"
      ],
      "exports": [
        "generate_file_csv",
        "generate_file_json",
        "generate_file_yaml"
      ]
    },
    {
      "path": "project_reproducer.py",
      "language": "python",
      "lines": 318,
      "classes": [
        {
          "name": "FileResult",
          "bases": [],
          "docstring": "Result for a single file reproduction."
        },
        {
          "name": "ProjectResult",
          "bases": [],
          "docstring": "Result for project reproduction."
        },
        {
          "name": "ProjectReproducer",
          "bases": [],
          "docstring": "Multi-file project reproduction system.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None,max_workers:int=4,target_lang:str=None,use_llm:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_get_client",
              "signature": "()->BaseLLMClient",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "find_source_files",
              "signature": "(project_path:str,extensions:Set[str]=None,exclude_patterns:List[str]=None)->List[Path]",
              "intent": "retrieves source files",
              "is_async": false
            },
            {
              "name": "reproduce_file",
              "signature": "(file_path:Path,output_dir:Path)->FileResult",
              "intent": "reproduce file",
              "is_async": false
            },
            {
              "name": "reproduce_project",
              "signature": "(project_path:str,output_dir:str=None,parallel:bool=False)->ProjectResult",
              "intent": "reproduce project",
              "is_async": false
            },
            {
              "name": "_aggregate_results",
              "signature": "(project_path:str,results:List[FileResult])->ProjectResult",
              "intent": "aggregate results",
              "is_async": false
            },
            {
              "name": "_save_report",
              "signature": "(output_dir:Path,result:ProjectResult)",
              "intent": "caches report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "reproduce_project",
          "signature": "(project_path:str,output_dir:str=None,target_lang:str=None,parallel:bool=False...+1)->ProjectResult",
          "intent": "reproduce project",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "dataclasses.dataclass",
        "dataclasses.field",
        "dataclasses.asdict",
        "datetime"
      ],
      "exports": [
        "SUPPORTED_EXTENSIONS",
        "FileResult",
        "ProjectResult",
        "ProjectReproducer",
        "reproduce_project"
      ]
    },
    {
      "path": "base.py",
      "language": "python",
      "lines": 49,
      "classes": [
        {
          "name": "VerboseMixin",
          "bases": [],
          "docstring": "Mixin providing verbose logging functionality.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "log",
              "signature": "(msg:str,level:str='info')",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "debug",
              "signature": "(msg:str)",
              "intent": "debug",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(msg:str)",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "warn",
              "signature": "(msg:str)",
              "intent": "warn",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(msg:str)",
              "intent": "error",
              "is_async": false
            }
          ]
        },
        {
          "name": "BaseParser",
          "bases": [
            "VerboseMixin"
          ],
          "docstring": "Base class for code parsers.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(content:str,language:str=None)",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "parse_file",
              "signature": "(path:str)",
              "intent": "parses file",
              "is_async": false
            }
          ]
        },
        {
          "name": "BaseGenerator",
          "bases": [
            "VerboseMixin"
          ],
          "docstring": "Base class for output generators.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project,detail:str='full')->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "logging"
      ],
      "exports": [
        "VerboseMixin",
        "BaseParser",
        "BaseGenerator"
      ]
    },
    {
      "path": "cli.py",
      "language": "python",
      "lines": 801,
      "classes": [
        {
          "name": "Colors",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Logger",
          "bases": [],
          "docstring": "Enhanced logger for CLI output.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False,debug:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_elapsed",
              "signature": "()->str",
              "intent": "elapsed",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(msg:str)",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "success",
              "signature": "(msg:str)",
              "intent": "success",
              "is_async": false
            },
            {
              "name": "warning",
              "signature": "(msg:str)",
              "intent": "warning",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(msg:str)",
              "intent": "error",
              "is_async": false
            },
            {
              "name": "step",
              "signature": "(msg:str)",
              "intent": "step",
              "is_async": false
            },
            {
              "name": "detail",
              "signature": "(msg:str)",
              "intent": "detail",
              "is_async": false
            },
            {
              "name": "debug_msg",
              "signature": "(msg:str)",
              "intent": "debug msg",
              "is_async": false
            },
            {
              "name": "stats",
              "signature": "(label:str,value)",
              "intent": "stats",
              "is_async": false
            },
            {
              "name": "separator",
              "signature": "()",
              "intent": "separator",
              "is_async": false
            },
            {
              "name": "header",
              "signature": "(msg:str)",
              "intent": "header",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "ensure_dependencies",
          "signature": "()",
          "intent": "ensure dependencies",
          "is_async": false
        },
        {
          "name": "_get_env_file_path",
          "signature": "()->str",
          "intent": "retrieves env file path",
          "is_async": false
        },
        {
          "name": "_read_text_file",
          "signature": "(path:str)->str",
          "intent": "retrieves text file",
          "is_async": false
        },
        {
          "name": "_write_text_file",
          "signature": "(path:str,content:str)->None",
          "intent": "logs text file",
          "is_async": false
        },
        {
          "name": "_set_env_var",
          "signature": "(var_name:str,value:str)->str",
          "intent": "updates env var",
          "is_async": false
        },
        {
          "name": "_unset_env_var",
          "signature": "(var_name:str)->str",
          "intent": "unset env var",
          "is_async": false
        },
        {
          "name": "_get_litellm_config_path",
          "signature": "()->str",
          "intent": "retrieves litellm config path",
          "is_async": false
        },
        {
          "name": "_get_user_llm_config_path",
          "signature": "()->str",
          "intent": "retrieves user llm config path",
          "is_async": false
        },
        {
          "name": "_load_user_llm_config",
          "signature": "()->dict",
          "intent": "retrieves user llm config",
          "is_async": false
        },
        {
          "name": "_save_user_llm_config",
          "signature": "(data:dict)->str",
          "intent": "caches user llm config",
          "is_async": false
        },
        {
          "name": "_load_litellm_yaml",
          "signature": "()->dict",
          "intent": "retrieves litellm yaml",
          "is_async": false
        },
        {
          "name": "_save_litellm_yaml",
          "signature": "(data:dict)->str",
          "intent": "caches litellm yaml",
          "is_async": false
        },
        {
          "name": "_infer_provider_from_litellm_model",
          "signature": "(litellm_model:str)->str",
          "intent": "infer provider from litellm model",
          "is_async": false
        },
        {
          "name": "_code2logic_llm_cli",
          "signature": "(argv:list[str])->None",
          "intent": "code2logic llm cli",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "os",
        "sys",
        "subprocess",
        "time",
        "json",
        "signal",
        "datetime",
        "__version__"
      ],
      "exports": [
        "Colors",
        "Logger",
        "ensure_dependencies",
        "main"
      ]
    },
    {
      "path": "llm.py",
      "language": "python",
      "lines": 375,
      "classes": [
        {
          "name": "LLMConfig",
          "bases": [],
          "docstring": "Configuration for LLM backend."
        },
        {
          "name": "OllamaClient",
          "bases": [],
          "docstring": "Direct Ollama API client.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(config:LLMConfig)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:Optional[str]=None)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "chat",
              "signature": "(messages:List[Dict[str,str]])->str",
              "intent": "chat",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "list_models",
              "signature": "()->List[str]",
              "intent": "list models",
              "is_async": false
            }
          ]
        },
        {
          "name": "LiteLLMClient",
          "bases": [],
          "docstring": "LiteLLM client for unified API access.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(config:LLMConfig)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:Optional[str]=None)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "chat",
              "signature": "(messages:List[Dict[str,str]])->str",
              "intent": "chat",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            }
          ]
        },
        {
          "name": "CodeAnalyzer",
          "bases": [],
          "docstring": "LLM-powered code analysis for Code2Logic.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(model:str=None,provider:str=None,base_url:str=None,api_key:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "suggest_refactoring",
              "signature": "(project)->List[Dict[str, Any]]",
              "intent": "suggest refactoring",
              "is_async": false
            },
            {
              "name": "find_semantic_duplicates",
              "signature": "(project)->List[Dict[str, Any]]",
              "intent": "retrieves semantic duplicates",
              "is_async": false
            },
            {
              "name": "generate_code",
              "signature": "(project,target_lang:str,module_filter:Optional[str]=None)->Dict[str, str]",
              "intent": "creates code",
              "is_async": false
            },
            {
              "name": "translate_function",
              "signature": "(name:str,signature:str,intent:str,source_lang:str...+1)->str",
              "intent": "converts function",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f)->str",
              "intent": "creates signature",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_available_backends",
          "signature": "()->Dict[str, bool]",
          "intent": "retrieves available backends",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "dataclasses.dataclass",
        "httpx",
        "litellm.completion",
        "llm_clients.OpenRouterClient"
      ],
      "exports": [
        "LLMConfig",
        "OllamaClient",
        "LiteLLMClient",
        "CodeAnalyzer",
        "get_available_backends"
      ]
    },
    {
      "path": "errors.py",
      "language": "python",
      "lines": 371,
      "classes": [
        {
          "name": "ErrorSeverity",
          "bases": [
            "Enum"
          ],
          "docstring": "Error severity levels."
        },
        {
          "name": "ErrorType",
          "bases": [
            "Enum"
          ],
          "docstring": "Types of errors that can occur during analysis."
        },
        {
          "name": "AnalysisError",
          "bases": [],
          "docstring": "Represents an error during analysis.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "AnalysisResult",
          "bases": [],
          "docstring": "Result of analysis with errors tracked.",
          "methods": [
            {
              "name": "add_error",
              "signature": "(error:AnalysisError)",
              "intent": "creates error",
              "is_async": false
            },
            {
              "name": "has_errors",
              "signature": "()->bool",
              "intent": "has errors",
              "is_async": false
            },
            {
              "name": "summary",
              "signature": "()->str",
              "intent": "summary",
              "is_async": false
            }
          ]
        },
        {
          "name": "ErrorHandler",
          "bases": [],
          "docstring": "Handles errors during analysis with configurable behavior.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(mode:str='lenient',max_file_size_mb:float=10.0,timeout_seconds:float=30.0,logger:Optional[Any]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reset",
              "signature": "()",
              "intent": "reset",
              "is_async": false
            },
            {
              "name": "handle_error",
              "signature": "(error_type:ErrorType,path:str,message:str,exception:Optional[Exception]=None...+1)->bool",
              "intent": "handles error",
              "is_async": false
            },
            {
              "name": "_default_severity",
              "signature": "(error_type:ErrorType)->ErrorSeverity",
              "intent": "default severity",
              "is_async": false
            },
            {
              "name": "_log_error",
              "signature": "(error:AnalysisError)",
              "intent": "logs error",
              "is_async": false
            },
            {
              "name": "safe_read_file",
              "signature": "(path:Path)->Optional[str]",
              "intent": "safe read file",
              "is_async": false
            },
            {
              "name": "safe_write_file",
              "signature": "(path:Path,content:str)->bool",
              "intent": "safe write file",
              "is_async": false
            },
            {
              "name": "safe_parse",
              "signature": "(path:str,content:str,parser_func:Callable)->Any",
              "intent": "safe parse",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "create_error_handler",
          "signature": "(mode:str='lenient',max_file_size_mb:float=10.0)->ErrorHandler",
          "intent": "creates error handler",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "pathlib.Path",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Callable",
        "logging"
      ],
      "exports": [
        "ErrorSeverity",
        "ErrorType",
        "AnalysisError",
        "AnalysisResult",
        "ErrorHandler",
        "create_error_handler"
      ]
    },
    {
      "path": "code_review.py",
      "language": "python",
      "lines": 205,
      "classes": [
        {
          "name": "CodeReviewer",
          "bases": [],
          "docstring": "Automated code review with optional LLM enhancement.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "review",
              "signature": "(project,focus:str='all')->Dict[str, Any]",
              "intent": "review",
              "is_async": false
            },
            {
              "name": "generate_report",
              "signature": "(results:Dict[str,Any],project_name:str='Project')->str",
              "intent": "creates report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_code_quality",
          "signature": "(project)->Dict[str, List[Dict]]",
          "intent": "processes code quality",
          "is_async": false
        },
        {
          "name": "check_security_issues",
          "signature": "(project)->Dict[str, List[Dict]]",
          "intent": "checks security issues",
          "is_async": false
        },
        {
          "name": "check_performance_issues",
          "signature": "(project)->Dict[str, List[Dict]]",
          "intent": "checks performance issues",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "collections.defaultdict"
      ],
      "exports": [
        "SECURITY_PATTERNS",
        "PERFORMANCE_PATTERNS",
        "COMPLEXITY_HIGH",
        "COMPLEXITY_MEDIUM",
        "LINES_MAX",
        "FILE_LINES_MAX",
        "analyze_code_quality",
        "check_security_issues",
        "check_performance_issues",
        "CodeReviewer"
      ]
    },
    {
      "path": "analyzer.py",
      "language": "python",
      "lines": 235,
      "classes": [
        {
          "name": "ProjectAnalyzer",
          "bases": [],
          "docstring": "Main class for analyzing software projects.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(root_path:str,use_treesitter:bool=True,verbose:bool=False,include_private:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_print_status",
              "signature": "()",
              "intent": "logs status",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "()->ProjectInfo",
              "intent": "processes",
              "is_async": false
            },
            {
              "name": "_scan_files",
              "signature": "()",
              "intent": "scan files",
              "is_async": false
            },
            {
              "name": "_detect_entrypoints",
              "signature": "()->List[str]",
              "intent": "detect entrypoints",
              "is_async": false
            },
            {
              "name": "get_statistics",
              "signature": "()->Dict",
              "intent": "retrieves statistics",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_project",
          "signature": "(path:str,use_treesitter:bool=True,verbose:bool=False)->ProjectInfo",
          "intent": "processes project",
          "is_async": false
        },
        {
          "name": "get_library_status",
          "signature": "()->Dict[str, bool]",
          "intent": "retrieves library status",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "pathlib.Path",
        "datetime",
        "collections.defaultdict",
        "typing.List",
        "typing.Dict",
        "models.ProjectInfo",
        "models.ModuleInfo",
        "parsers.TreeSitterParser",
        "parsers.UniversalParser"
      ],
      "exports": [
        "ProjectAnalyzer",
        "analyze_project",
        "get_library_status"
      ]
    },
    {
      "path": "quality.py",
      "language": "python",
      "lines": 212,
      "classes": [
        {
          "name": "QualityIssue",
          "bases": [],
          "docstring": "Represents a code quality issue."
        },
        {
          "name": "QualityReport",
          "bases": [],
          "docstring": "Complete quality analysis report.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "QualityAnalyzer",
          "bases": [],
          "docstring": "Analyzes code quality and generates recommendations.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(thresholds:Dict[str,int]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "(project:ProjectInfo)->QualityReport",
              "intent": "processes",
              "is_async": false
            },
            {
              "name": "analyze_modules",
              "signature": "(modules:List[ModuleInfo])->QualityReport",
              "intent": "processes modules",
              "is_async": false
            },
            {
              "name": "_analyze_module",
              "signature": "(module:ModuleInfo,report:QualityReport)",
              "intent": "processes module",
              "is_async": false
            },
            {
              "name": "_check_function",
              "signature": "(func,file_path:str,report:QualityReport)",
              "intent": "checks function",
              "is_async": false
            },
            {
              "name": "_check_class",
              "signature": "(file_path:str,report:QualityReport)",
              "intent": "checks class",
              "is_async": false
            },
            {
              "name": "_get_file_recommendation",
              "signature": "(module:ModuleInfo)->str",
              "intent": "retrieves file recommendation",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_quality",
          "signature": "(project:ProjectInfo,thresholds:Dict[str,int]=None)->QualityReport",
          "intent": "processes quality",
          "is_async": false
        },
        {
          "name": "get_quality_summary",
          "signature": "(report:QualityReport)->str",
          "intent": "retrieves quality summary",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "models.ModuleInfo",
        "models.ProjectInfo"
      ],
      "exports": [
        "QualityIssue",
        "QualityReport",
        "QualityAnalyzer",
        "analyze_quality",
        "get_quality_summary"
      ]
    },
    {
      "path": "shared_utils.py",
      "language": "python",
      "lines": 279,
      "classes": [],
      "functions": [
        {
          "name": "compact_imports",
          "signature": "(imports:List[str],max_items:int=10)->List[str]",
          "intent": "compact imports",
          "is_async": false
        },
        {
          "name": "deduplicate_imports",
          "signature": "(imports:List[str])->List[str]",
          "intent": "deduplicate imports",
          "is_async": false
        },
        {
          "name": "abbreviate_type",
          "signature": "(type_str:str)->str",
          "intent": "abbreviate type",
          "is_async": false
        },
        {
          "name": "expand_type",
          "signature": "(abbrev:str)->str",
          "intent": "expand type",
          "is_async": false
        },
        {
          "name": "build_signature",
          "signature": "(params:List[str],return_type:Optional[str]=None,include_self:bool=False,abbreviate:bool=False...+1)->str",
          "intent": "creates signature",
          "is_async": false
        },
        {
          "name": "remove_self_from_params",
          "signature": "(params:List[str])->List[str]",
          "intent": "deletes self from params",
          "is_async": false
        },
        {
          "name": "categorize_function",
          "signature": "(name:str)->str",
          "intent": "categorize function",
          "is_async": false
        },
        {
          "name": "extract_domain",
          "signature": "(path:str)->str",
          "intent": "parses domain",
          "is_async": false
        },
        {
          "name": "compute_hash",
          "signature": "(name:str,signature:str,length:int=8)->str",
          "intent": "processes hash",
          "is_async": false
        },
        {
          "name": "truncate_docstring",
          "signature": "(docstring:Optional[str],max_length:int=60)->str",
          "intent": "truncate docstring",
          "is_async": false
        },
        {
          "name": "escape_for_yaml",
          "signature": "(text:str)->str",
          "intent": "escape for yaml",
          "is_async": false
        },
        {
          "name": "clean_identifier",
          "signature": "(name:str)->str",
          "intent": "clean identifier",
          "is_async": false
        }
      ],
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Set",
        "typing.Optional",
        "hashlib",
        "re"
      ],
      "exports": [
        "compact_imports",
        "deduplicate_imports",
        "TYPE_ABBREVIATIONS",
        "abbreviate_type",
        "expand_type",
        "build_signature",
        "remove_self_from_params",
        "CATEGORY_PATTERNS",
        "categorize_function",
        "DOMAIN_KEYWORDS"
      ]
    },
    {
      "path": "parsers.py",
      "language": "python",
      "lines": 1584,
      "classes": [
        {
          "name": "_PyFunctionBodyAnalyzer",
          "bases": [
            "ast.NodeVisitor"
          ],
          "docstring": null,
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_add_call",
              "signature": "(name:str)->None",
              "intent": "creates call",
              "is_async": false
            },
            {
              "name": "_add_raise",
              "signature": "(name:str)->None",
              "intent": "creates raise",
              "is_async": false
            },
            {
              "name": "visit_Call",
              "signature": "(node)",
              "intent": "visit call",
              "is_async": false
            },
            {
              "name": "visit_Raise",
              "signature": "(node)",
              "intent": "visit raise",
              "is_async": false
            },
            {
              "name": "visit_If",
              "signature": "(node)",
              "intent": "visit if",
              "is_async": false
            },
            {
              "name": "visit_For",
              "signature": "(node)",
              "intent": "visit for",
              "is_async": false
            },
            {
              "name": "visit_AsyncFor",
              "signature": "(node)",
              "intent": "visit asyncfor",
              "is_async": false
            },
            {
              "name": "visit_While",
              "signature": "(node)",
              "intent": "visit while",
              "is_async": false
            },
            {
              "name": "visit_IfExp",
              "signature": "(node)",
              "intent": "visit ifexp",
              "is_async": false
            },
            {
              "name": "visit_BoolOp",
              "signature": "(node)",
              "intent": "visit boolop",
              "is_async": false
            },
            {
              "name": "visit_Try",
              "signature": "(node)",
              "intent": "visit try",
              "is_async": false
            },
            {
              "name": "visit_comprehension",
              "signature": "(node)",
              "intent": "visit comprehension",
              "is_async": false
            },
            {
              "name": "visit_Match",
              "signature": "(node)",
              "intent": "visit match",
              "is_async": false
            },
            {
              "name": "visit_FunctionDef",
              "signature": "(node)",
              "intent": "visit functiondef",
              "is_async": false
            },
            {
              "name": "visit_AsyncFunctionDef",
              "signature": "(node)",
              "intent": "visit asyncfunctiondef",
              "is_async": false
            },
            {
              "name": "visit_ClassDef",
              "signature": "(node)",
              "intent": "visit classdef",
              "is_async": false
            },
            {
              "name": "visit_Lambda",
              "signature": "(node)",
              "intent": "visit lambda",
              "is_async": false
            }
          ]
        },
        {
          "name": "TreeSitterParser",
          "bases": [],
          "docstring": "Parser using Tree-sitter for high-accuracy AST parsing.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_init_parsers",
              "signature": "()",
              "intent": "creates parsers",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "(language:str)->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "get_supported_languages",
              "signature": "()->List[str]",
              "intent": "retrieves supported languages",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(filepath:str,content:str,language:str)->Optional[ModuleInfo]",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(filepath:str,content:str,tree)->ModuleInfo",
              "intent": "parses python",
              "is_async": false
            },
            {
              "name": "_extract_constants",
              "signature": "(tree,content:str)->List[ConstantInfo]",
              "intent": "parses constants",
              "is_async": false
            },
            {
              "name": "_extract_type_checking_imports",
              "signature": "(tree,content:str)->List[str]",
              "intent": "parses type checking imports",
              "is_async": false
            },
            {
              "name": "_extract_conditional_imports",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses conditional imports",
              "is_async": false
            },
            {
              "name": "_extract_aliases",
              "signature": "(tree,content:str)->dict",
              "intent": "parses aliases",
              "is_async": false
            },
            {
              "name": "_extract_py_function",
              "signature": "(node,content:str,decorated_node=None)->Optional[FunctionInfo]",
              "intent": "parses py function",
              "is_async": false
            },
            {
              "name": "_extract_py_enum",
              "signature": "(node,content:str)->Optional[TypeInfo]",
              "intent": "parses py enum",
              "is_async": false
            },
            {
              "name": "_extract_py_class",
              "signature": "(node,content:str,decorated_node=None)->Optional[ClassInfo]",
              "intent": "parses py class",
              "is_async": false
            },
            {
              "name": "_extract_dataclass_field",
              "signature": "(node,content:str)->Optional[FieldInfo]",
              "intent": "parses dataclass field",
              "is_async": false
            },
            {
              "name": "_extract_class_attribute",
              "signature": "(node,content:str)->Optional[AttributeInfo]",
              "intent": "parses class attribute",
              "is_async": false
            },
            {
              "name": "_extract_init_attributes",
              "signature": "(func_node,content:str)->List[AttributeInfo]",
              "intent": "parses init attributes",
              "is_async": false
            },
            {
              "name": "_extract_class_property",
              "signature": "(node,content:str)->Optional[str]",
              "intent": "parses class property",
              "is_async": false
            },
            {
              "name": "_extract_py_import",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses py import",
              "is_async": false
            },
            {
              "name": "_extract_py_from_import",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses py from import",
              "is_async": false
            },
            {
              "name": "_extract_py_constant",
              "signature": "(node,content:str)->Optional[ConstantInfo]",
              "intent": "parses py constant",
              "is_async": false
            },
            {
              "name": "_extract_conditional_imports",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses conditional imports",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(filepath:str,content:str,tree,language:str)->ModuleInfo",
              "intent": "parses js ts",
              "is_async": false
            },
            {
              "name": "_extract_js_class",
              "signature": "(node,content:str)->Optional[ClassInfo]",
              "intent": "parses js class",
              "is_async": false
            },
            {
              "name": "_extract_js_method",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js method",
              "is_async": false
            },
            {
              "name": "_extract_js_function",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js function",
              "is_async": false
            },
            {
              "name": "_extract_js_arrow_fn",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js arrow fn",
              "is_async": false
            },
            {
              "name": "_extract_js_params",
              "signature": "(params_node,content:str)->List[str]",
              "intent": "parses js params",
              "is_async": false
            },
            {
              "name": "_extract_ts_type",
              "signature": "(node,content:str)->Optional[TypeInfo]",
              "intent": "parses ts type",
              "is_async": false
            },
            {
              "name": "_extract_ts_enum",
              "signature": "(node,content:str)->Optional[TypeInfo]",
              "intent": "parses ts enum",
              "is_async": false
            },
            {
              "name": "_extract_js_constant",
              "signature": "(node,content:str)->Optional[str]",
              "intent": "parses js constant",
              "is_async": false
            },
            {
              "name": "_extract_js_comment",
              "signature": "(node,content:str)->Optional[str]",
              "intent": "parses js comment",
              "is_async": false
            },
            {
              "name": "_find_child",
              "signature": "(node,type_name:str)",
              "intent": "retrieves child",
              "is_async": false
            },
            {
              "name": "_text",
              "signature": "(node,content:str)->str",
              "intent": "text",
              "is_async": false
            },
            {
              "name": "_extract_string",
              "signature": "(node,content:str)->str",
              "intent": "parses string",
              "is_async": false
            },
            {
              "name": "_truncate_docstring",
              "signature": "(docstring:Optional[str],max_len:int=80)->Optional[str]",
              "intent": "truncate docstring",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalParser",
          "bases": [],
          "docstring": "Fallback parser using Python AST and regex.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(filepath:str,content:str,language:str)->Optional[ModuleInfo]",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(filepath:str,content:str)->Optional[ModuleInfo]",
              "intent": "parses python",
              "is_async": false
            },
            {
              "name": "_extract_ast_enum",
              "signature": "(node:Any)->Optional[TypeInfo]",
              "intent": "parses ast enum",
              "is_async": false
            },
            {
              "name": "_extract_ast_function",
              "signature": "(node)->FunctionInfo",
              "intent": "parses ast function",
              "is_async": false
            },
            {
              "name": "_extract_ast_class",
              "signature": "(node:Any)->ClassInfo",
              "intent": "parses ast class",
              "is_async": false
            },
            {
              "name": "_extract_ast_constant",
              "signature": "(node:Any,content:str)->Optional[ConstantInfo]",
              "intent": "parses ast constant",
              "is_async": false
            },
            {
              "name": "_format_ast_value",
              "signature": "(value_node:Any,content:str)->str",
              "intent": "formats ast value",
              "is_async": false
            },
            {
              "name": "_ann_str",
              "signature": "(node)->str",
              "intent": "ann str",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(filepath:str,content:str,language:str)->ModuleInfo",
              "intent": "parses js ts",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_normalize_import_path",
          "signature": "(import_path:str)->str",
          "intent": "normalize import path",
          "is_async": false
        },
        {
          "name": "_clean_imports",
          "signature": "(imports:List[str])->List[str]",
          "intent": "clean imports",
          "is_async": false
        },
        {
          "name": "_combine_import_name",
          "signature": "(module_name:str,identifier:str)->str",
          "intent": "merges import name",
          "is_async": false
        },
        {
          "name": "_truncate_constant_value",
          "signature": "(value_text:str,limit:int=400)->str",
          "intent": "truncate constant value",
          "is_async": false
        },
        {
          "name": "_py_expr_to_dotted_name",
          "signature": "(expr)->str",
          "intent": "py expr to dotted name",
          "is_async": false
        },
        {
          "name": "_analyze_python_function_node",
          "signature": "(func_node)",
          "intent": "processes python function node",
          "is_async": false
        },
        {
          "name": "is_tree_sitter_available",
          "signature": "()->bool",
          "intent": "is tree sitter available",
          "is_async": false
        }
      ],
      "imports": [
        "ast",
        "re",
        "textwrap",
        "typing.Optional",
        "typing.List",
        "models.FunctionInfo",
        "models.ClassInfo",
        "models.TypeInfo",
        "models.ModuleInfo",
        "models.ConstantInfo"
      ],
      "exports": [
        "TREE_SITTER_AVAILABLE",
        "TreeSitterParser",
        "UniversalParser",
        "is_tree_sitter_available"
      ]
    },
    {
      "path": "intent.py",
      "language": "python",
      "lines": 429,
      "classes": [
        {
          "name": "IntentType",
          "bases": [
            "Enum"
          ],
          "docstring": "Types of user intents for code analysis."
        },
        {
          "name": "Intent",
          "bases": [],
          "docstring": "Represents a detected user intent."
        },
        {
          "name": "EnhancedIntentGenerator",
          "bases": [],
          "docstring": "Generator intencji z NLP - lemmatyzacja, ekstrakcja z docstringw.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(lang:str='en')",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(name:str,docstring:Optional[str]=None)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_extract_from_docstring",
              "signature": "(docstring:str)->Optional[str]",
              "intent": "parses from docstring",
              "is_async": false
            },
            {
              "name": "_split_name",
              "signature": "(name:str)->List[str]",
              "intent": "splits name",
              "is_async": false
            },
            {
              "name": "get_available_features",
              "signature": "()->dict[str, bool]",
              "intent": "retrieves available features",
              "is_async": false
            }
          ]
        },
        {
          "name": "IntentAnalyzer",
          "bases": [],
          "docstring": "Analyzes user queries to detect intent and provide suggestions.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_extract_keywords",
              "signature": "(query:str)->List[str]",
              "intent": "parses keywords",
              "is_async": false
            },
            {
              "name": "_calculate_intent_confidence",
              "signature": "(keywords:List[str],patterns:List[str])->float",
              "intent": "processes intent confidence",
              "is_async": false
            },
            {
              "name": "_identify_target",
              "signature": "(query:str,project:Any)->str",
              "intent": "identify target",
              "is_async": false
            },
            {
              "name": "_generate_description",
              "signature": "(intent_type:IntentType,target:str)->str",
              "intent": "creates description",
              "is_async": false
            },
            {
              "name": "_generate_suggestions",
              "signature": "(intent_type:IntentType,target:str,project:Any)->List[str]",
              "intent": "creates suggestions",
              "is_async": false
            },
            {
              "name": "analyze_intent",
              "signature": "(query:str,project:Any)->List[Intent]",
              "intent": "processes intent",
              "is_async": false
            },
            {
              "name": "detect_code_smells",
              "signature": "(project:Any)->List[dict]",
              "intent": "detect code smells",
              "is_async": false
            },
            {
              "name": "suggest_refactoring",
              "signature": "(target:str,project:Any)->List[str]",
              "intent": "suggest refactoring",
              "is_async": false
            },
            {
              "name": "_find_target_object",
              "signature": "(target:str,project:Any)->Any",
              "intent": "retrieves target object",
              "is_async": false
            },
            {
              "name": "_suggest_module_refactoring",
              "signature": "(module:Any)->List[str]",
              "intent": "suggest module refactoring",
              "is_async": false
            },
            {
              "name": "_suggest_class_refactoring",
              "signature": "(cls:Any)->List[str]",
              "intent": "suggest class refactoring",
              "is_async": false
            },
            {
              "name": "_suggest_function_refactoring",
              "signature": "(func:Any)->List[str]",
              "intent": "suggest function refactoring",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "enum.auto",
        "typing.Optional",
        "typing.List",
        "typing.Any",
        "typing.TYPE_CHECKING",
        "nltk"
      ],
      "exports": [
        "IntentType",
        "Intent",
        "EnhancedIntentGenerator",
        "IntentAnalyzer"
      ]
    },
    {
      "path": "adaptive.py",
      "language": "python",
      "lines": 473,
      "classes": [
        {
          "name": "ChunkInfo",
          "bases": [],
          "docstring": "Information about a code chunk."
        },
        {
          "name": "AdaptiveResult",
          "bases": [],
          "docstring": "Result of adaptive reproduction."
        },
        {
          "name": "AdaptiveReproducer",
          "bases": [],
          "docstring": "Adaptive code reproduction with LLM capability detection.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None,model:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_get_capabilities",
              "signature": "()->Dict[str, Any]",
              "intent": "retrieves capabilities",
              "is_async": false
            },
            {
              "name": "select_format",
              "signature": "(file_path:Path,content:str)->str",
              "intent": "retrieves format",
              "is_async": false
            },
            {
              "name": "should_chunk",
              "signature": "(content:str)->bool",
              "intent": "checks chunk",
              "is_async": false
            },
            {
              "name": "chunk_content",
              "signature": "(content:str,file_path:Path)->List[ChunkInfo]",
              "intent": "chunk content",
              "is_async": false
            },
            {
              "name": "generate_chunk_spec",
              "signature": "(chunk:ChunkInfo,format_name:str)->str",
              "intent": "creates chunk spec",
              "is_async": false
            },
            {
              "name": "_gherkin_for_chunk",
              "signature": "(chunk:ChunkInfo)->str",
              "intent": "gherkin for chunk",
              "is_async": false
            },
            {
              "name": "_yaml_for_chunk",
              "signature": "(chunk:ChunkInfo)->str",
              "intent": "yaml for chunk",
              "is_async": false
            },
            {
              "name": "_json_for_chunk",
              "signature": "(chunk:ChunkInfo)->str",
              "intent": "json for chunk",
              "is_async": false
            },
            {
              "name": "reproduce",
              "signature": "(file_path:str,output_dir:str=None)->AdaptiveResult",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_reproduce_single",
              "signature": "(path:Path,content:str,format_name:str,output_dir:str=None)->AdaptiveResult",
              "intent": "reproduce single",
              "is_async": false
            },
            {
              "name": "_reproduce_chunked",
              "signature": "(path:Path,content:str,format_name:str,output_dir:str=None)->AdaptiveResult",
              "intent": "reproduce chunked",
              "is_async": false
            },
            {
              "name": "_generate_from_spec",
              "signature": "(spec:str,format_name:str,file_ext:str)->str",
              "intent": "creates from spec",
              "is_async": false
            },
            {
              "name": "_save_result",
              "signature": "(output_dir:Path,original:str,spec:str,generated:str...+1)",
              "intent": "caches result",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_llm_capabilities",
          "signature": "(model:str)->Dict[str, Any]",
          "intent": "retrieves llm capabilities",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "dataclasses.dataclass",
        "dotenv.load_dotenv",
        "llm_clients.BaseLLMClient",
        "llm_clients.get_client",
        "reproduction.compare_code",
        "reproduction.extract_code_block"
      ],
      "exports": [
        "LLM_CAPABILITIES",
        "ChunkInfo",
        "AdaptiveResult",
        "AdaptiveReproducer",
        "get_llm_capabilities"
      ]
    },
    {
      "path": "reproducer.py",
      "language": "python",
      "lines": 533,
      "classes": [
        {
          "name": "ReproductionStatus",
          "bases": [
            "Enum"
          ],
          "docstring": "Status of file reproduction."
        },
        {
          "name": "FileValidation",
          "bases": [],
          "docstring": "Validation result for a single file.",
          "methods": [
            {
              "name": "score",
              "signature": "()->float",
              "intent": "score",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "ReproductionResult",
          "bases": [],
          "docstring": "Result of reproduction process.",
          "methods": [
            {
              "name": "success_rate",
              "signature": "()->float",
              "intent": "success rate",
              "is_async": false
            },
            {
              "name": "average_score",
              "signature": "()->float",
              "intent": "average score",
              "is_async": false
            },
            {
              "name": "summary",
              "signature": "()->str",
              "intent": "summary",
              "is_async": false
            }
          ]
        },
        {
          "name": "SpecReproducer",
          "bases": [],
          "docstring": "Reproduces code structure from logic specifications.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reproduce_from_yaml",
              "signature": "(spec_path:str,output_dir:str,filter_paths:Optional[List[str]]=None)->ReproductionResult",
              "intent": "reproduce from yaml",
              "is_async": false
            },
            {
              "name": "reproduce_from_json",
              "signature": "(spec_path:str,output_dir:str,filter_paths:Optional[List[str]]=None)->ReproductionResult",
              "intent": "reproduce from json",
              "is_async": false
            },
            {
              "name": "_reproduce",
              "signature": "(spec:Dict[str,Any],output_dir:str,filter_paths:Optional[List[str]]=None)->ReproductionResult",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_generate_file",
              "signature": "(module:Dict[str,Any],output_path:Path)->bool",
              "intent": "creates file",
              "is_async": false
            },
            {
              "name": "_generate_python",
              "signature": "(module:Dict[str,Any])->str",
              "intent": "creates python",
              "is_async": false
            },
            {
              "name": "_render_docstring",
              "signature": "(text:str,indent:str)->List[str]",
              "intent": "formats docstring",
              "is_async": false
            },
            {
              "name": "_sanitize_python_property",
              "signature": "(prop:str)->str",
              "intent": "sanitize python property",
              "is_async": false
            },
            {
              "name": "_generate_python_class",
              "signature": "(cls:Dict[str,Any])->List[str]",
              "intent": "creates python class",
              "is_async": false
            },
            {
              "name": "_generate_python_method",
              "signature": "(method:Dict[str,Any])->List[str]",
              "intent": "creates python method",
              "is_async": false
            },
            {
              "name": "_generate_python_function",
              "signature": "(func:Dict[str,Any])->List[str]",
              "intent": "creates python function",
              "is_async": false
            },
            {
              "name": "_generate_typescript",
              "signature": "(module:Dict[str,Any])->str",
              "intent": "creates typescript",
              "is_async": false
            },
            {
              "name": "_generate_ts_class",
              "signature": "(cls:Dict[str,Any])->List[str]",
              "intent": "creates ts class",
              "is_async": false
            },
            {
              "name": "_generate_ts_method",
              "signature": "(method:Dict[str,Any])->List[str]",
              "intent": "creates ts method",
              "is_async": false
            },
            {
              "name": "_generate_ts_function",
              "signature": "(func:Dict[str,Any])->List[str]",
              "intent": "creates ts function",
              "is_async": false
            },
            {
              "name": "_parse_signature",
              "signature": "(sig:str)->str",
              "intent": "parses signature",
              "is_async": false
            }
          ]
        },
        {
          "name": "SpecValidator",
          "bases": [],
          "docstring": "Validates generated files against logic specification.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "validate",
              "signature": "(spec_path:str,generated_dir:str,filter_paths:Optional[List[str]]=None)->List[FileValidation]",
              "intent": "validates",
              "is_async": false
            },
            {
              "name": "_validate_file",
              "signature": "(module:Dict[str,Any],base_path:Path)->FileValidation",
              "intent": "validates file",
              "is_async": false
            },
            {
              "name": "_check_python_syntax",
              "signature": "(content:str,validation:FileValidation)->bool",
              "intent": "checks python syntax",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "reproduce_project",
          "signature": "(spec_path:str,output_dir:str,filter_paths:Optional[List[str]]=None,validate:bool=True...+1)->ReproductionResult",
          "intent": "reproduce project",
          "is_async": false
        },
        {
          "name": "validate_files",
          "signature": "(spec_path:str,generated_dir:str,filter_paths:Optional[List[str]]=None)->List[FileValidation]",
          "intent": "validates files",
          "is_async": false
        }
      ],
      "imports": [
        "yaml",
        "json",
        "re",
        "pathlib.Path",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional"
      ],
      "exports": [
        "ReproductionStatus",
        "FileValidation",
        "ReproductionResult",
        "SpecReproducer",
        "SpecValidator",
        "reproduce_project",
        "validate_files"
      ]
    },
    {
      "path": "llm_clients.py",
      "language": "python",
      "lines": 167,
      "classes": [],
      "functions": [
        {
          "name": "_get_user_llm_config_path",
          "signature": "()->str",
          "intent": "retrieves user llm config path",
          "is_async": false
        },
        {
          "name": "_load_user_llm_config",
          "signature": "()->Dict[str, Any]",
          "intent": "retrieves user llm config",
          "is_async": false
        },
        {
          "name": "_get_priority_mode",
          "signature": "()->str",
          "intent": "retrieves priority mode",
          "is_async": false
        },
        {
          "name": "get_priority_mode",
          "signature": "()->str",
          "intent": "retrieves priority mode",
          "is_async": false
        },
        {
          "name": "_get_provider_priority_overrides",
          "signature": "()->Dict[str, int]",
          "intent": "retrieves provider priority overrides",
          "is_async": false
        },
        {
          "name": "_get_model_priority_rules",
          "signature": "()->Dict[str, Dict[str, int]]",
          "intent": "retrieves model priority rules",
          "is_async": false
        },
        {
          "name": "_get_model_priority",
          "signature": "(model_string:str)->Optional[int]",
          "intent": "retrieves model priority",
          "is_async": false
        },
        {
          "name": "_get_provider_model_string",
          "signature": "(provider:str)->str",
          "intent": "retrieves provider model string",
          "is_async": false
        },
        {
          "name": "_get_priority_order",
          "signature": "()->List[str]",
          "intent": "retrieves priority order",
          "is_async": false
        },
        {
          "name": "_get_effective_provider_order",
          "signature": "()->List[tuple]",
          "intent": "retrieves effective provider order",
          "is_async": false
        },
        {
          "name": "get_effective_provider_priorities",
          "signature": "()->Dict[str, int]",
          "intent": "retrieves effective provider priorities",
          "is_async": false
        },
        {
          "name": "_candidate_litellm_yaml_paths",
          "signature": "()->List[str]",
          "intent": "candidate litellm yaml paths",
          "is_async": false
        }
      ],
      "imports": [
        "lolm.BaseLLMClient",
        "lolm.OpenRouterClient",
        "lolm.OllamaLocalClient",
        "lolm.LiteLLMClient",
        "lolm.LLMManager",
        "lolm.get_client",
        "lolm.list_available_providers",
        "lolm.RECOMMENDED_MODELS",
        "lolm.DEFAULT_MODELS",
        "lolm.DEFAULT_PROVIDER_PRIORITIES"
      ],
      "exports": [
        "get_priority_mode",
        "get_effective_provider_priorities"
      ]
    },
    {
      "path": "prompts.py",
      "language": "python",
      "lines": 120,
      "classes": [],
      "functions": [
        {
          "name": "get_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str,language:str='python'...+1)->str",
          "intent": "retrieves reproduction prompt",
          "is_async": false
        },
        {
          "name": "get_review_prompt",
          "signature": "(code:str,spec:str,fmt:str)->str",
          "intent": "retrieves review prompt",
          "is_async": false
        },
        {
          "name": "get_fix_prompt",
          "signature": "(code:str,issues:list,spec:str)->str",
          "intent": "retrieves fix prompt",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Dict"
      ],
      "exports": [
        "FORMAT_HINTS",
        "get_reproduction_prompt",
        "get_review_prompt",
        "get_fix_prompt"
      ]
    },
    {
      "path": "chunked_reproduction.py",
      "language": "python",
      "lines": 355,
      "classes": [
        {
          "name": "Chunk",
          "bases": [],
          "docstring": "A chunk of specification for reproduction."
        },
        {
          "name": "ChunkedSpec",
          "bases": [],
          "docstring": "Chunked specification."
        },
        {
          "name": "ChunkedResult",
          "bases": [],
          "docstring": "Result of chunked reproduction."
        },
        {
          "name": "ChunkedReproducer",
          "bases": [],
          "docstring": "Reproduce code from chunked specifications.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client,model_name:str='default')",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reproduce",
              "signature": "(spec:str,fmt:str,file_name:str)->ChunkedResult",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_extract_code",
              "signature": "(response:str)->str",
              "intent": "parses code",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_llm_limit",
          "signature": "(model_name:str)->int",
          "intent": "retrieves llm limit",
          "is_async": false
        },
        {
          "name": "chunk_yaml_spec",
          "signature": "(spec:str,max_tokens:int=2000)->List[Chunk]",
          "intent": "chunk yaml spec",
          "is_async": false
        },
        {
          "name": "chunk_gherkin_spec",
          "signature": "(spec:str,max_tokens:int=2000)->List[Chunk]",
          "intent": "chunk gherkin spec",
          "is_async": false
        },
        {
          "name": "chunk_markdown_spec",
          "signature": "(spec:str,max_tokens:int=2000)->List[Chunk]",
          "intent": "chunk markdown spec",
          "is_async": false
        },
        {
          "name": "chunk_spec",
          "signature": "(spec:str,fmt:str,max_tokens:int=2000)->ChunkedSpec",
          "intent": "chunk spec",
          "is_async": false
        },
        {
          "name": "get_chunk_prompt",
          "signature": "(chunk:Chunk,fmt:str,file_name:str,chunk_num:int...+1)->str",
          "intent": "retrieves chunk prompt",
          "is_async": false
        },
        {
          "name": "merge_chunk_codes",
          "signature": "(codes:List[str],file_name:str)->str",
          "intent": "merges chunk codes",
          "is_async": false
        },
        {
          "name": "auto_chunk_reproduce",
          "signature": "(spec:str,fmt:str,file_name:str,client...+1)->ChunkedResult",
          "intent": "auto chunk reproduce",
          "is_async": false
        },
        {
          "name": "adaptive_chunk_reproduce",
          "signature": "(spec:str,fmt:str,file_name:str,client...+2)->ChunkedResult",
          "intent": "adaptive chunk reproduce",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "typing.List",
        "utils.estimate_tokens"
      ],
      "exports": [
        "LLM_CONTEXT_LIMITS",
        "Chunk",
        "ChunkedSpec",
        "ChunkedResult",
        "get_llm_limit",
        "chunk_yaml_spec",
        "chunk_gherkin_spec",
        "chunk_markdown_spec",
        "chunk_spec",
        "get_chunk_prompt"
      ]
    },
    {
      "path": "__init__.py",
      "language": "python",
      "lines": 365,
      "classes": [],
      "functions": [
        {
          "name": "analyze_quality",
          "signature": "(target)",
          "intent": "processes quality",
          "is_async": false
        },
        {
          "name": "reproduce_project",
          "signature": "(source:str)",
          "intent": "reproduce project",
          "is_async": false
        }
      ],
      "imports": [
        "analyzer.ProjectAnalyzer",
        "analyzer.analyze_project",
        "models.FunctionInfo",
        "models.ClassInfo",
        "models.TypeInfo",
        "models.ModuleInfo",
        "models.DependencyNode",
        "models.ProjectInfo",
        "generators.MarkdownGenerator",
        "generators.CompactGenerator"
      ],
      "exports": [
        "analyze_quality",
        "reproduce_project"
      ]
    },
    {
      "path": "metrics.py",
      "language": "python",
      "lines": 446,
      "classes": [
        {
          "name": "TextMetrics",
          "bases": [],
          "docstring": "Text-level similarity metrics."
        },
        {
          "name": "StructuralMetrics",
          "bases": [],
          "docstring": "Structural code metrics."
        },
        {
          "name": "SemanticMetrics",
          "bases": [],
          "docstring": "Semantic preservation metrics."
        },
        {
          "name": "FormatMetrics",
          "bases": [],
          "docstring": "Format-specific efficiency metrics."
        },
        {
          "name": "ReproductionResult",
          "bases": [],
          "docstring": "Complete reproduction analysis result.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "to_report",
              "signature": "()->str",
              "intent": "converts report",
              "is_async": false
            }
          ]
        },
        {
          "name": "ReproductionMetrics",
          "bases": [],
          "docstring": "Analyze reproduction quality with multiple metrics.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "(original:str,generated:str,spec:str='',format_name:str=''...+1)->ReproductionResult",
              "intent": "processes",
              "is_async": false
            },
            {
              "name": "_compute_text_metrics",
              "signature": "(original:str,generated:str)->TextMetrics",
              "intent": "processes text metrics",
              "is_async": false
            },
            {
              "name": "_cosine_similarity",
              "signature": "(words1:List[str],words2:List[str])->float",
              "intent": "cosine similarity",
              "is_async": false
            },
            {
              "name": "_compute_structural_metrics",
              "signature": "(original:str,generated:str)->StructuralMetrics",
              "intent": "processes structural metrics",
              "is_async": false
            },
            {
              "name": "_compute_semantic_metrics",
              "signature": "(original:str,generated:str)->SemanticMetrics",
              "intent": "processes semantic metrics",
              "is_async": false
            },
            {
              "name": "_compute_format_metrics",
              "signature": "(original:str,generated:str,spec:str,format_name:str)->FormatMetrics",
              "intent": "processes format metrics",
              "is_async": false
            },
            {
              "name": "_compute_overall_score",
              "signature": "(result:ReproductionResult)->float",
              "intent": "processes overall score",
              "is_async": false
            },
            {
              "name": "_get_grade",
              "signature": "(score:float)->str",
              "intent": "retrieves grade",
              "is_async": false
            },
            {
              "name": "_generate_recommendations",
              "signature": "(result:ReproductionResult)->List[str]",
              "intent": "creates recommendations",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_reproduction",
          "signature": "(original:str,generated:str,spec:str='',format_name:str=''...+1)->ReproductionResult",
          "intent": "processes reproduction",
          "is_async": false
        },
        {
          "name": "compare_formats",
          "signature": "(original:str,results:Dict[str,Tuple[str,str]],verbose:bool=False)->Dict[str, Any]",
          "intent": "compare formats",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "difflib",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "typing.Tuple",
        "dataclasses.dataclass",
        "dataclasses.field",
        "dataclasses.asdict",
        "collections.Counter"
      ],
      "exports": [
        "TextMetrics",
        "StructuralMetrics",
        "SemanticMetrics",
        "FormatMetrics",
        "ReproductionResult",
        "ReproductionMetrics",
        "analyze_reproduction",
        "compare_formats"
      ]
    },
    {
      "path": "__main__.py",
      "language": "python",
      "lines": 12,
      "classes": [],
      "functions": [],
      "imports": [
        "cli.main"
      ],
      "exports": []
    },
    {
      "path": "refactor.py",
      "language": "python",
      "lines": 308,
      "classes": [
        {
          "name": "DuplicateGroup",
          "bases": [],
          "docstring": "Group of duplicate functions."
        },
        {
          "name": "RefactoringSuggestion",
          "bases": [],
          "docstring": "Single refactoring suggestion."
        },
        {
          "name": "RefactoringReport",
          "bases": [],
          "docstring": "Complete refactoring analysis report.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "to_markdown",
              "signature": "()->str",
              "intent": "converts markdown",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "find_duplicates",
          "signature": "(project_path:str,threshold:float=0.8)->List[DuplicateGroup]",
          "intent": "retrieves duplicates",
          "is_async": false
        },
        {
          "name": "analyze_quality",
          "signature": "(project_path:str,include_security:bool=True,include_performance:bool=True)->RefactoringReport",
          "intent": "processes quality",
          "is_async": false
        },
        {
          "name": "suggest_refactoring",
          "signature": "(project_path:str,use_llm:bool=False,client:BaseLLMClient=None)->RefactoringReport",
          "intent": "suggest refactoring",
          "is_async": false
        },
        {
          "name": "compare_codebases",
          "signature": "(project1:str,project2:str)->Dict[str, Any]",
          "intent": "compare codebases",
          "is_async": false
        },
        {
          "name": "quick_analyze",
          "signature": "(project_path:str)->Dict[str, Any]",
          "intent": "quick analyze",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "dataclasses.dataclass",
        "dataclasses.field",
        "dataclasses.asdict",
        "analyzer.analyze_project",
        "code_review.analyze_code_quality",
        "code_review.check_security_issues",
        "llm_clients.get_client"
      ],
      "exports": [
        "DuplicateGroup",
        "RefactoringSuggestion",
        "RefactoringReport",
        "find_duplicates",
        "analyze_quality",
        "suggest_refactoring",
        "compare_codebases",
        "quick_analyze"
      ]
    },
    {
      "path": "logicml.py",
      "language": "python",
      "lines": 281,
      "classes": [
        {
          "name": "LogicMLSpec",
          "bases": [],
          "docstring": "LogicML specification output."
        },
        {
          "name": "LogicMLGenerator",
          "bases": [],
          "docstring": "Generates LogicML format - optimized for LLM code reproduction.",
          "properties": [
            "FORMAT_NAME: str",
            "FILE_EXTENSION: str",
            "TOKEN_EFFICIENCY: float",
            "REPRODUCTION_FIDELITY: float"
          ],
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)->None",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard')->LogicMLSpec",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_module",
              "signature": "(module:ModuleInfo,detail:str)->str",
              "intent": "creates module",
              "is_async": false
            },
            {
              "name": "_generate_imports",
              "signature": "(imports:List[str])->str",
              "intent": "creates imports",
              "is_async": false
            },
            {
              "name": "_generate_class",
              "signature": "(cls:ClassInfo,detail:str)->str",
              "intent": "creates class",
              "is_async": false
            },
            {
              "name": "_generate_method",
              "signature": "(method:FunctionInfo,detail:str,indent:int=2)->str",
              "intent": "creates method",
              "is_async": false
            },
            {
              "name": "_generate_functions",
              "signature": "(functions:List[FunctionInfo],detail:str)->str",
              "intent": "creates functions",
              "is_async": false
            },
            {
              "name": "_detect_side_effects",
              "signature": "(method:FunctionInfo)->Optional[str]",
              "intent": "detect side effects",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_logicml",
          "signature": "(project:ProjectInfo,detail:str='standard')->str",
          "intent": "creates logicml",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "dataclasses.dataclass",
        "models.ProjectInfo",
        "models.ModuleInfo",
        "models.FunctionInfo",
        "models.ClassInfo"
      ],
      "exports": [
        "LogicMLSpec",
        "LogicMLGenerator",
        "generate_logicml",
        "LOGICML_EXAMPLE"
      ]
    },
    {
      "path": "function_logic.py",
      "language": "python",
      "lines": 209,
      "classes": [
        {
          "name": "FunctionLogicGenerator",
          "bases": [],
          "docstring": null,
          "properties": [
            "FILE_EXTENSION: str"
          ],
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)->None",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_json",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates json",
              "is_async": false
            },
            {
              "name": "generate_yaml",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates yaml",
              "is_async": false
            },
            {
              "name": "generate_toon",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates toon",
              "is_async": false
            },
            {
              "name": "_build_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates data",
              "is_async": false
            },
            {
              "name": "_module_items",
              "signature": "(module)->List[Tuple[str, str, FunctionInfo]]",
              "intent": "module items",
              "is_async": false
            },
            {
              "name": "_build_sig",
              "signature": "(func:FunctionInfo,include_async_prefix:bool=True)->str",
              "intent": "creates sig",
              "is_async": false
            },
            {
              "name": "_build_loc",
              "signature": "(func:FunctionInfo)->str",
              "intent": "creates loc",
              "is_async": false
            },
            {
              "name": "_build_does",
              "signature": "(func:FunctionInfo)->str",
              "intent": "creates does",
              "is_async": false
            },
            {
              "name": "_item_to_dict",
              "signature": "(kind:str,qualified_name:str,func:FunctionInfo,detail:str)->dict",
              "intent": "item to dict",
              "is_async": false
            },
            {
              "name": "_format_function",
              "signature": "(kind:str,qualified_name:str,func:FunctionInfo,detail:str...+1)->List[str]",
              "intent": "formats function",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "typing.List",
        "typing.Tuple",
        "models.ProjectInfo",
        "models.FunctionInfo",
        "shared_utils.remove_self_from_params",
        "shared_utils.truncate_docstring",
        "toon_format.TOONGenerator"
      ],
      "exports": [
        "FunctionLogicGenerator"
      ]
    },
    {
      "path": "utils.py",
      "language": "python",
      "lines": 16,
      "classes": [],
      "functions": [
        {
          "name": "estimate_tokens",
          "signature": "(text:str)->int",
          "intent": "estimate tokens",
          "is_async": false
        },
        {
          "name": "write_text_atomic",
          "signature": "(path:Path,content:str)->None",
          "intent": "logs text atomic",
          "is_async": false
        },
        {
          "name": "cleanup_generated_root",
          "signature": "(generated_root:Path,allowed_dirs:set[str])->None",
          "intent": "cleanup generated root",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "shutil"
      ],
      "exports": [
        "estimate_tokens",
        "write_text_atomic",
        "cleanup_generated_root"
      ]
    },
    {
      "path": "generators.py",
      "language": "python",
      "lines": 1763,
      "classes": [
        {
          "name": "MarkdownGenerator",
          "bases": [],
          "docstring": "Generates Markdown output for project analysis.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail_level:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_gen_tree",
              "signature": "(lines:List[str],project:ProjectInfo)",
              "intent": "gen tree",
              "is_async": false
            },
            {
              "name": "_print_tree",
              "signature": "(lines:List[str],tree:dict,prefix:str,depth:int=0)",
              "intent": "logs tree",
              "is_async": false
            },
            {
              "name": "_gen_module",
              "signature": "(lines:List[str],m:ModuleInfo,detail:str,proj:ProjectInfo)",
              "intent": "gen module",
              "is_async": false
            },
            {
              "name": "_gen_class",
              "signature": "(lines:List[str],cls:ClassInfo,detail:str)",
              "intent": "gen class",
              "is_async": false
            },
            {
              "name": "_sig",
              "signature": "(f:FunctionInfo)->str",
              "intent": "sig",
              "is_async": false
            }
          ]
        },
        {
          "name": "CompactGenerator",
          "bases": [],
          "docstring": "Generates ultra-compact output for token efficiency.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        },
        {
          "name": "JSONGenerator",
          "bases": [],
          "docstring": "Generates JSON output for machine processing.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,flat:bool=False,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_from_module",
              "signature": "(module:ModuleInfo,detail:str='full')->str",
              "intent": "creates from module",
              "is_async": false
            },
            {
              "name": "_generate_nested",
              "signature": "(project:ProjectInfo,detail:str)->str",
              "intent": "creates nested",
              "is_async": false
            },
            {
              "name": "_field_to_dict",
              "signature": "(field:FieldInfo)->dict",
              "intent": "field to dict",
              "is_async": false
            },
            {
              "name": "_generate_flat",
              "signature": "(project:ProjectInfo,detail:str)->str",
              "intent": "creates flat",
              "is_async": false
            },
            {
              "name": "_build_element_row",
              "signature": "(m:ModuleInfo,elem_type:str,name:str,signature:str...+3)->dict",
              "intent": "creates element row",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_compute_hash",
              "signature": "(name:str,signature:str)->str",
              "intent": "processes hash",
              "is_async": false
            }
          ]
        },
        {
          "name": "YAMLGenerator",
          "bases": [],
          "docstring": "Generates YAML output for human-readable representation.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,flat:bool=False,detail:str='standard',compact:bool=True)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_schema",
              "signature": "(format_type:str='compact')->str",
              "intent": "creates schema",
              "is_async": false
            },
            {
              "name": "_generate_compact_schema",
              "signature": "()->str",
              "intent": "creates compact schema",
              "is_async": false
            },
            {
              "name": "_generate_full_schema",
              "signature": "()->str",
              "intent": "creates full schema",
              "is_async": false
            },
            {
              "name": "_generate_hybrid_schema",
              "signature": "()->str",
              "intent": "creates hybrid schema",
              "is_async": false
            },
            {
              "name": "generate_hybrid",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates hybrid",
              "is_async": false
            },
            {
              "name": "_build_enhanced_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates enhanced signature",
              "is_async": false
            },
            {
              "name": "_extract_constants",
              "signature": "(module:ModuleInfo)->list",
              "intent": "parses constants",
              "is_async": false
            },
            {
              "name": "_extract_dataclasses",
              "signature": "(module:ModuleInfo)->list",
              "intent": "parses dataclasses",
              "is_async": false
            },
            {
              "name": "_extract_conditional_imports",
              "signature": "(module:ModuleInfo)->list",
              "intent": "parses conditional imports",
              "is_async": false
            },
            {
              "name": "generate_from_module",
              "signature": "(module:ModuleInfo,detail:str='full')->str",
              "intent": "creates from module",
              "is_async": false
            },
            {
              "name": "_build_flat_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates flat data",
              "is_async": false
            },
            {
              "name": "_build_nested_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates nested data",
              "is_async": false
            },
            {
              "name": "_constants_for_module_verbose",
              "signature": "(module:ModuleInfo,limit:int=12)->list",
              "intent": "constants for module verbose",
              "is_async": false
            },
            {
              "name": "_build_row",
              "signature": "(path:str,elem_type:str,name:str,signature:str...+3)->dict",
              "intent": "creates row",
              "is_async": false
            },
            {
              "name": "_build_function_row",
              "signature": "(path:str,f:FunctionInfo,language:str,detail:str...+2)->dict",
              "intent": "creates function row",
              "is_async": false
            },
            {
              "name": "_build_method_row",
              "signature": "(path:str,class_name:str,f:FunctionInfo,language:str...+3)->dict",
              "intent": "creates method row",
              "is_async": false
            },
            {
              "name": "_function_to_dict",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "function to dict",
              "is_async": false
            },
            {
              "name": "_method_to_dict",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "method to dict",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_compute_hash",
              "signature": "(name:str,signature:str)->str",
              "intent": "processes hash",
              "is_async": false
            },
            {
              "name": "_generate_simple_yaml",
              "signature": "(project:ProjectInfo,flat:bool,detail:str)->str",
              "intent": "creates simple yaml",
              "is_async": false
            },
            {
              "name": "_build_compact_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates compact data",
              "is_async": false
            },
            {
              "name": "_compact_imports",
              "signature": "(imports:list)->list",
              "intent": "compact imports",
              "is_async": false
            },
            {
              "name": "_compact_class",
              "signature": "(cls:ClassInfo,detail:str,module_types:Optional[list]=None)->dict",
              "intent": "compact class",
              "is_async": false
            },
            {
              "name": "_compact_function",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "compact function",
              "is_async": false
            },
            {
              "name": "_compact_method",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "compact method",
              "is_async": false
            },
            {
              "name": "_build_compact_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates compact signature",
              "is_async": false
            },
            {
              "name": "_constants_for_module_verbose",
              "signature": "(module:ModuleInfo,limit:int=10)->list",
              "intent": "constants for module verbose",
              "is_async": false
            },
            {
              "name": "_constants_for_module",
              "signature": "(module:ModuleInfo,limit:int=10)->list",
              "intent": "constants for module",
              "is_async": false
            },
            {
              "name": "_constant_to_dict",
              "signature": "(constant:ConstantInfo)->dict",
              "intent": "constant to dict",
              "is_async": false
            },
            {
              "name": "_field_to_dict",
              "signature": "(field:FieldInfo)->dict",
              "intent": "field to dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "CSVGenerator",
          "bases": [],
          "docstring": "Generates CSV output optimized for LLM processing.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_build_row",
              "signature": "(m:ModuleInfo,elem_type:str,name:str,signature:str...+3)->dict",
              "intent": "creates row",
              "is_async": false
            },
            {
              "name": "_build_function_row",
              "signature": "(m:ModuleInfo,elem_type:str,name:str,f:FunctionInfo...+3)->dict",
              "intent": "creates function row",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_compute_hash",
              "signature": "(name:str,signature:str)->str",
              "intent": "processes hash",
              "is_async": false
            },
            {
              "name": "_escape_csv",
              "signature": "(text:str)->str",
              "intent": "escape csv",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "bytes_to_kb",
          "signature": "(bytes_value:int)->float",
          "intent": "bytes to kb",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "collections.defaultdict",
        "models.ProjectInfo",
        "models.ModuleInfo",
        "models.ClassInfo",
        "models.FunctionInfo",
        "models.ConstantInfo"
      ],
      "exports": [
        "bytes_to_kb",
        "MarkdownGenerator",
        "CompactGenerator",
        "JSONGenerator",
        "YAMLGenerator",
        "CSVGenerator"
      ]
    },
    {
      "path": "markdown_format.py",
      "language": "python",
      "lines": 265,
      "classes": [
        {
          "name": "MarkdownSpec",
          "bases": [],
          "docstring": "Markdown specification for a project."
        },
        {
          "name": "MarkdownHybridGenerator",
          "bases": [],
          "docstring": "Generates optimized Markdown hybrid format.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='full')->MarkdownSpec",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_header",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates header",
              "is_async": false
            },
            {
              "name": "_generate_tree",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates tree",
              "is_async": false
            },
            {
              "name": "_generate_imports",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates imports",
              "is_async": false
            },
            {
              "name": "_generate_classes_yaml",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates classes yaml",
              "is_async": false
            },
            {
              "name": "_generate_functions_gherkin",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates functions gherkin",
              "is_async": false
            },
            {
              "name": "_generate_dependencies",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates dependencies",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_markdown_hybrid",
          "signature": "(project:ProjectInfo,detail:str='full')->str",
          "intent": "creates markdown hybrid",
          "is_async": false
        },
        {
          "name": "generate_file_markdown",
          "signature": "(file_path:str)->str",
          "intent": "creates file markdown",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "dataclasses.dataclass",
        "models.ProjectInfo",
        "gherkin.GherkinGenerator",
        "generators.YAMLGenerator"
      ],
      "exports": [
        "MarkdownSpec",
        "MarkdownHybridGenerator",
        "generate_markdown_hybrid",
        "generate_file_markdown"
      ]
    },
    {
      "path": "models.py",
      "language": "python",
      "lines": 296,
      "classes": [
        {
          "name": "FunctionInfo",
          "bases": [],
          "docstring": "Information about a function or method."
        },
        {
          "name": "ClassInfo",
          "bases": [],
          "docstring": "Information about a class or interface."
        },
        {
          "name": "TypeInfo",
          "bases": [],
          "docstring": "Information about a type alias, interface, or enum."
        },
        {
          "name": "ModuleInfo",
          "bases": [],
          "docstring": "Information about a source file/module."
        },
        {
          "name": "DependencyNode",
          "bases": [],
          "docstring": "Node in the dependency graph with metrics."
        },
        {
          "name": "ProjectInfo",
          "bases": [],
          "docstring": "Complete project analysis results."
        },
        {
          "name": "ConstantInfo",
          "bases": [],
          "docstring": "Module-level constant information."
        },
        {
          "name": "FieldInfo",
          "bases": [],
          "docstring": "Dataclass field information."
        },
        {
          "name": "AttributeInfo",
          "bases": [],
          "docstring": "Instance attribute information (self.x = ...)."
        },
        {
          "name": "PropertyInfo",
          "bases": [],
          "docstring": "Property information (@property, @x.setter)."
        },
        {
          "name": "OptionalImport",
          "bases": [],
          "docstring": "Try/except import block information."
        },
        {
          "name": "ClassInfo",
          "bases": [],
          "docstring": "Information about a class or interface."
        },
        {
          "name": "FunctionInfo",
          "bases": [],
          "docstring": "Information about a function or method."
        },
        {
          "name": "ModuleInfo",
          "bases": [],
          "docstring": "Information about a source file/module."
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Optional",
        "typing.List",
        "typing.Dict"
      ],
      "exports": [
        "FunctionInfo",
        "ClassInfo",
        "TypeInfo",
        "ModuleInfo",
        "DependencyNode",
        "ProjectInfo",
        "ConstantInfo",
        "FieldInfo",
        "AttributeInfo",
        "PropertyInfo"
      ]
    },
    {
      "path": "llm_clients_new.py",
      "language": "python",
      "lines": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "similarity.py",
      "language": "python",
      "lines": 178,
      "classes": [
        {
          "name": "SimilarityDetector",
          "bases": [],
          "docstring": "Detects similar functions using fuzzy string matching.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(threshold:float=80.0)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "find_similar_functions",
              "signature": "(modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "retrieves similar functions",
              "is_async": false
            },
            {
              "name": "find_duplicate_signatures",
              "signature": "(modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "retrieves duplicate signatures",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(name:str,params:List[str],return_type:str=None)->str",
              "intent": "creates signature",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_rapidfuzz_available",
          "signature": "()->bool",
          "intent": "is rapidfuzz available",
          "is_async": false
        },
        {
          "name": "get_refactoring_suggestions",
          "signature": "(similar_functions:Dict[str,List[str]])->List[Dict[str, any]]",
          "intent": "retrieves refactoring suggestions",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Dict",
        "typing.List",
        "models.ModuleInfo",
        "rapidfuzz.fuzz",
        "rapidfuzz.process"
      ],
      "exports": [
        "RAPIDFUZZ_AVAILABLE",
        "SimilarityDetector",
        "is_rapidfuzz_available",
        "get_refactoring_suggestions"
      ]
    },
    {
      "path": "universal.py",
      "language": "python",
      "lines": 829,
      "classes": [
        {
          "name": "ElementType",
          "bases": [
            "Enum"
          ],
          "docstring": "Types of code elements."
        },
        {
          "name": "Language",
          "bases": [
            "Enum"
          ],
          "docstring": "Supported languages."
        },
        {
          "name": "Parameter",
          "bases": [],
          "docstring": "Function/method parameter."
        },
        {
          "name": "CodeElement",
          "bases": [],
          "docstring": "Universal representation of a code element."
        },
        {
          "name": "CodeLogic",
          "bases": [],
          "docstring": "Universal code logic representation for a single file.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "_element_to_dict",
              "signature": "(elem:CodeElement)->Dict[str, Any]",
              "intent": "element to dict",
              "is_async": false
            },
            {
              "name": "to_compact",
              "signature": "()->str",
              "intent": "converts compact",
              "is_async": false
            },
            {
              "name": "_element_to_compact",
              "signature": "(elem:CodeElement,indent:int)->List[str]",
              "intent": "element to compact",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalParser",
          "bases": [],
          "docstring": "Parse source code into universal CodeLogic format.",
          "methods": [
            {
              "name": "detect_language",
              "signature": "(content:str,file_ext:str)->Language",
              "intent": "detect language",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(file_path:Union[str,Path])->CodeLogic",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses python",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(path:Path,content:str,hash_:str,lang:Language)->CodeLogic",
              "intent": "parses js ts",
              "is_async": false
            },
            {
              "name": "_parse_go",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses go",
              "is_async": false
            },
            {
              "name": "_parse_sql",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses sql",
              "is_async": false
            },
            {
              "name": "_parse_generic",
              "signature": "(path:Path,content:str,hash_:str,lang:Language)->CodeLogic",
              "intent": "parses generic",
              "is_async": false
            }
          ]
        },
        {
          "name": "CodeGenerator",
          "bases": [],
          "docstring": "Generate code from CodeLogic in target language.",
          "methods": [
            {
              "name": "generate",
              "signature": "(logic:CodeLogic,target_lang:Language)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_python",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates python",
              "is_async": false
            },
            {
              "name": "_generate_python_element",
              "signature": "(elem:CodeElement,indent:int=0)->List[str]",
              "intent": "creates python element",
              "is_async": false
            },
            {
              "name": "_generate_typescript",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates typescript",
              "is_async": false
            },
            {
              "name": "_generate_go",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates go",
              "is_async": false
            },
            {
              "name": "_generate_sql",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates sql",
              "is_async": false
            },
            {
              "name": "_generate_generic",
              "signature": "(logic:CodeLogic,target:Language)->str",
              "intent": "creates generic",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalReproducer",
          "bases": [],
          "docstring": "Universal code reproduction system.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_get_client",
              "signature": "()->BaseLLMClient",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "extract_logic",
              "signature": "(file_path:str)->CodeLogic",
              "intent": "parses logic",
              "is_async": false
            },
            {
              "name": "reproduce",
              "signature": "(source_path:str,target_lang:str=None,output_dir:str=None,use_llm:bool=True)->Dict[str, Any]",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_generate_with_llm",
              "signature": "(logic:CodeLogic,target:Language)->str",
              "intent": "creates with llm",
              "is_async": false
            },
            {
              "name": "_save_result",
              "signature": "(output_dir:Path,original:str,logic:CodeLogic,generated:str...+1)",
              "intent": "caches result",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "reproduce_file",
          "signature": "(source_path:str,target_lang:str=None,output_dir:str=None,use_llm:bool=True)->Dict[str, Any]",
          "intent": "reproduce file",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "json",
        "hashlib",
        "pathlib.Path",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "typing.Union",
        "dataclasses.dataclass",
        "dataclasses.field"
      ],
      "exports": [
        "ElementType",
        "Language",
        "Parameter",
        "CodeElement",
        "CodeLogic",
        "UniversalParser",
        "CodeGenerator",
        "UniversalReproducer",
        "reproduce_file"
      ]
    },
    {
      "path": "benchmark.py",
      "language": "python",
      "lines": 349,
      "classes": [
        {
          "name": "FormatResult",
          "bases": [],
          "docstring": "Result for a single format test."
        },
        {
          "name": "BenchmarkResult",
          "bases": [],
          "docstring": "Complete benchmark result."
        },
        {
          "name": "ReproductionBenchmark",
          "bases": [],
          "docstring": "Benchmark reproduction quality across formats.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_spec",
              "signature": "(file_path:Path,format_name:str,detail:str='full')->str",
              "intent": "creates spec",
              "is_async": false
            },
            {
              "name": "reproduce_with_format",
              "signature": "(file_path:Path,format_name:str,original_code:str)->FormatResult",
              "intent": "reproduce with format",
              "is_async": false
            },
            {
              "name": "run_single",
              "signature": "(file_path:str,formats:List[str]=None)->BenchmarkResult",
              "intent": "starts single",
              "is_async": false
            },
            {
              "name": "run_all",
              "signature": "(files:List[str],output_dir:str=None)->Dict[str, Any]",
              "intent": "starts all",
              "is_async": false
            },
            {
              "name": "_generate_summary",
              "signature": "(results:List[BenchmarkResult])->Dict[str, Any]",
              "intent": "creates summary",
              "is_async": false
            },
            {
              "name": "_save_results",
              "signature": "(output_dir:Path,results:List[BenchmarkResult],summary:Dict)",
              "intent": "caches results",
              "is_async": false
            },
            {
              "name": "_generate_report",
              "signature": "(results:List[BenchmarkResult],summary:Dict)->str",
              "intent": "creates report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "run_benchmark",
          "signature": "(files:List[str],output_dir:str='benchmark_results',provider:str=None,model:str=None)->Dict[str, Any]",
          "intent": "starts benchmark",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "time",
        "dotenv.load_dotenv",
        "pathlib.Path",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "typing.Optional",
        "datetime",
        "dataclasses.dataclass"
      ],
      "exports": [
        "FormatResult",
        "BenchmarkResult",
        "FORMAT_PROMPTS",
        "ReproductionBenchmark",
        "run_benchmark"
      ]
    },
    {
      "path": "terminal.py",
      "language": "python",
      "lines": 496,
      "classes": [
        {
          "name": "ShellRenderer",
          "bases": [],
          "docstring": "Renders colorized markdown output in terminal.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(use_colors:bool=True,verbose:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_supports_colors",
              "signature": "()->bool",
              "intent": "supports colors",
              "is_async": false
            },
            {
              "name": "enable_log",
              "signature": "()->None",
              "intent": "enable log",
              "is_async": false
            },
            {
              "name": "get_log",
              "signature": "()->str",
              "intent": "retrieves log",
              "is_async": false
            },
            {
              "name": "clear_log",
              "signature": "()->None",
              "intent": "deletes log",
              "is_async": false
            },
            {
              "name": "_log",
              "signature": "(text:str)->None",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "_c",
              "signature": "(color:str,text:str)->str",
              "intent": "c",
              "is_async": false
            },
            {
              "name": "heading",
              "signature": "(level:int,text:str)->None",
              "intent": "heading",
              "is_async": false
            },
            {
              "name": "codeblock",
              "signature": "(language:Language,content:str)->None",
              "intent": "codeblock",
              "is_async": false
            },
            {
              "name": "render_markdown",
              "signature": "(text:str)->None",
              "intent": "formats markdown",
              "is_async": false
            },
            {
              "name": "success",
              "signature": "(message:str)->None",
              "intent": "success",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(message:str)->None",
              "intent": "error",
              "is_async": false
            },
            {
              "name": "warning",
              "signature": "(message:str)->None",
              "intent": "warning",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(message:str)->None",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "status",
              "signature": "(icon:str,message:str,type:Literal[info,success,warning,error]='info')->None",
              "intent": "status",
              "is_async": false
            },
            {
              "name": "kv",
              "signature": "(key:str,value:Any)->None",
              "intent": "kv",
              "is_async": false
            },
            {
              "name": "progress",
              "signature": "(done:int,total:int,label:str='')->None",
              "intent": "progress",
              "is_async": false
            },
            {
              "name": "separator",
              "signature": "(char:str='',width:int=60)->None",
              "intent": "separator",
              "is_async": false
            },
            {
              "name": "table",
              "signature": "(headers:List[str],rows:List[List[Any]],widths:Optional[List[int]]=None)->None",
              "intent": "table",
              "is_async": false
            },
            {
              "name": "task",
              "signature": "(name:str,status:Literal[pending,running,done,failed],duration:Optional[float]=None)->None",
              "intent": "task",
              "is_async": false
            },
            {
              "name": "inline",
              "signature": "(text:str)->str",
              "intent": "inline",
              "is_async": false
            },
            {
              "name": "print",
              "signature": "(text:str,color:Optional[str]=None)->None",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "newline",
              "signature": "()->None",
              "intent": "newline",
              "is_async": false
            },
            {
              "name": "_highlight_line",
              "signature": "(line:str,language:str)->str",
              "intent": "highlight line",
              "is_async": false
            },
            {
              "name": "_highlight_yaml",
              "signature": "(line:str)->str",
              "intent": "highlight yaml",
              "is_async": false
            },
            {
              "name": "_highlight_json",
              "signature": "(line:str)->str",
              "intent": "highlight json",
              "is_async": false
            },
            {
              "name": "_highlight_python",
              "signature": "(line:str)->str",
              "intent": "highlight python",
              "is_async": false
            },
            {
              "name": "_highlight_bash",
              "signature": "(line:str)->str",
              "intent": "highlight bash",
              "is_async": false
            },
            {
              "name": "_highlight_js",
              "signature": "(line:str)->str",
              "intent": "highlight js",
              "is_async": false
            },
            {
              "name": "_highlight_gherkin",
              "signature": "(line:str)->str",
              "intent": "highlight gherkin",
              "is_async": false
            },
            {
              "name": "_highlight_log",
              "signature": "(line:str)->str",
              "intent": "highlight log",
              "is_async": false
            },
            {
              "name": "_highlight_markdown",
              "signature": "(line:str)->str",
              "intent": "highlight markdown",
              "is_async": false
            },
            {
              "name": "save_log",
              "signature": "(filepath:str)->None",
              "intent": "caches log",
              "is_async": false
            }
          ]
        },
        {
          "name": "RenderAPI",
          "bases": [],
          "docstring": "Convenience API for terminal rendering.",
          "methods": [
            {
              "name": "heading",
              "signature": "(level:int,text:str)->None",
              "intent": "heading",
              "is_async": false
            },
            {
              "name": "code",
              "signature": "(lang:Language,content:str)->None",
              "intent": "code",
              "is_async": false
            },
            {
              "name": "codeblock",
              "signature": "(lang:Language,content:str)->None",
              "intent": "codeblock",
              "is_async": false
            },
            {
              "name": "markdown",
              "signature": "(text:str)->None",
              "intent": "markdown",
              "is_async": false
            },
            {
              "name": "success",
              "signature": "(message:str)->None",
              "intent": "success",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(message:str)->None",
              "intent": "error",
              "is_async": false
            },
            {
              "name": "warning",
              "signature": "(message:str)->None",
              "intent": "warning",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(message:str)->None",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "status",
              "signature": "(icon:str,message:str,type:Literal[info,success,warning,error]='info')->None",
              "intent": "status",
              "is_async": false
            },
            {
              "name": "kv",
              "signature": "(key:str,value:Any)->None",
              "intent": "kv",
              "is_async": false
            },
            {
              "name": "progress",
              "signature": "(done:int,total:int,label:str='')->None",
              "intent": "progress",
              "is_async": false
            },
            {
              "name": "separator",
              "signature": "(char:str='',width:int=60)->None",
              "intent": "separator",
              "is_async": false
            },
            {
              "name": "table",
              "signature": "(headers:List[str],rows:List[List[Any]],widths:Optional[List[int]]=None)->None",
              "intent": "table",
              "is_async": false
            },
            {
              "name": "task",
              "signature": "(name:str,status:Literal[pending,running,done,failed],duration:Optional[float]=None)->None",
              "intent": "task",
              "is_async": false
            },
            {
              "name": "inline",
              "signature": "(text:str)->str",
              "intent": "inline",
              "is_async": false
            },
            {
              "name": "print",
              "signature": "(text:str,color:Optional[str]=None)->None",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "newline",
              "signature": "()->None",
              "intent": "newline",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_renderer",
          "signature": "(use_colors:bool=True,verbose:bool=True)->ShellRenderer",
          "intent": "retrieves renderer",
          "is_async": false
        },
        {
          "name": "set_renderer",
          "signature": "(renderer:ShellRenderer)->None",
          "intent": "updates renderer",
          "is_async": false
        }
      ],
      "imports": [
        "os",
        "re",
        "sys",
        "typing.Literal",
        "typing.Optional",
        "typing.List",
        "typing.Any"
      ],
      "exports": [
        "COLORS",
        "ShellRenderer",
        "get_renderer",
        "set_renderer",
        "RenderAPI"
      ]
    },
    {
      "path": "toon_format.py",
      "language": "python",
      "lines": 540,
      "classes": [
        {
          "name": "TOONGenerator",
          "bases": [],
          "docstring": "Generates TOON format output from ProjectInfo.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(delimiter:str=',',use_tabs:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_modules",
              "signature": "(modules:List[ModuleInfo],detail:str)->List[str]",
              "intent": "creates modules",
              "is_async": false
            },
            {
              "name": "_generate_types",
              "signature": "(types:List[TypeInfo],indent:int=0)->List[str]",
              "intent": "creates types",
              "is_async": false
            },
            {
              "name": "_generate_classes",
              "signature": "(classes:List[ClassInfo],detail:str,indent:int=0)->List[str]",
              "intent": "creates classes",
              "is_async": false
            },
            {
              "name": "_generate_methods",
              "signature": "(methods:List[FunctionInfo],detail:str='standard',indent:int=0)->List[str]",
              "intent": "creates methods",
              "is_async": false
            },
            {
              "name": "_generate_functions",
              "signature": "(functions:List[FunctionInfo],detail:str,indent:int=0)->List[str]",
              "intent": "creates functions",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_quote",
              "signature": "(value:Any)->str",
              "intent": "quote",
              "is_async": false
            },
            {
              "name": "generate_compact",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates compact",
              "is_async": false
            },
            {
              "name": "generate_full",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates full",
              "is_async": false
            },
            {
              "name": "generate_schema",
              "signature": "(format_type:str='standard')->str",
              "intent": "creates schema",
              "is_async": false
            },
            {
              "name": "generate_ultra_compact",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates ultra compact",
              "is_async": false
            }
          ]
        },
        {
          "name": "TOONParser",
          "bases": [],
          "docstring": "Parse TOON format back to Python dict.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(content:str)->Dict[str, Any]",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_value",
              "signature": "(value:str)->Any",
              "intent": "parses value",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_toon",
          "signature": "(project:ProjectInfo,detail:str='standard',use_tabs:bool=False)->str",
          "intent": "creates toon",
          "is_async": false
        },
        {
          "name": "parse_toon",
          "signature": "(content:str)->Dict[str, Any]",
          "intent": "parses toon",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "models.ProjectInfo",
        "models.ModuleInfo",
        "models.ClassInfo",
        "models.FunctionInfo",
        "models.TypeInfo",
        "shared_utils.compact_imports"
      ],
      "exports": [
        "TOONGenerator",
        "TOONParser",
        "generate_toon",
        "parse_toon"
      ]
    },
    {
      "path": "dependency.py",
      "language": "python",
      "lines": 187,
      "classes": [
        {
          "name": "DependencyAnalyzer",
          "bases": [],
          "docstring": "Analyzes dependency graphs using NetworkX.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "build_graph",
              "signature": "(modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "creates graph",
              "is_async": false
            },
            {
              "name": "analyze_metrics",
              "signature": "()->Dict[str, DependencyNode]",
              "intent": "processes metrics",
              "is_async": false
            },
            {
              "name": "get_entrypoints",
              "signature": "()->List[str]",
              "intent": "retrieves entrypoints",
              "is_async": false
            },
            {
              "name": "get_hubs",
              "signature": "()->List[str]",
              "intent": "retrieves hubs",
              "is_async": false
            },
            {
              "name": "detect_cycles",
              "signature": "()->List[List[str]]",
              "intent": "detect cycles",
              "is_async": false
            },
            {
              "name": "get_strongly_connected_components",
              "signature": "()->List[List[str]]",
              "intent": "retrieves strongly connected components",
              "is_async": false
            },
            {
              "name": "_detect_clusters",
              "signature": "()->Dict[str, int]",
              "intent": "detect clusters",
              "is_async": false
            },
            {
              "name": "_module_name",
              "signature": "(path:str)->str",
              "intent": "module name",
              "is_async": false
            },
            {
              "name": "get_dependency_depth",
              "signature": "(module_path:str)->int",
              "intent": "retrieves dependency depth",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_networkx_available",
          "signature": "()->bool",
          "intent": "is networkx available",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "models.ModuleInfo",
        "models.DependencyNode",
        "networkx"
      ],
      "exports": [
        "NETWORKX_AVAILABLE",
        "DependencyAnalyzer",
        "is_networkx_available"
      ]
    },
    {
      "path": "mcp_server.py",
      "language": "python",
      "lines": 291,
      "classes": [],
      "functions": [
        {
          "name": "handle_request",
          "signature": "(request:dict)->dict",
          "intent": "handles request",
          "is_async": false
        },
        {
          "name": "call_tool",
          "signature": "(tool_name:str,arguments:dict)->str",
          "intent": "call tool",
          "is_async": false
        },
        {
          "name": "run_server",
          "signature": "()",
          "intent": "starts server",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "sys",
        "__version__"
      ],
      "exports": [
        "handle_request",
        "call_tool",
        "run_server"
      ]
    },
    {
      "path": "reproduction.py",
      "language": "python",
      "lines": 333,
      "classes": [
        {
          "name": "CodeReproducer",
          "bases": [],
          "docstring": "Code reproduction workflow using LLM.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None,provider:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reproduce_file",
              "signature": "(source_path:str,output_dir:str=None)->Dict[str, Any]",
              "intent": "reproduce file",
              "is_async": false
            },
            {
              "name": "generate_from_gherkin",
              "signature": "(gherkin:str,language:str='python')->str",
              "intent": "creates from gherkin",
              "is_async": false
            },
            {
              "name": "_save_results",
              "signature": "(output_dir:Path,results:Dict[str,Any])",
              "intent": "caches results",
              "is_async": false
            },
            {
              "name": "_generate_report",
              "signature": "(results:Dict[str,Any])->str",
              "intent": "creates report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_file_gherkin",
          "signature": "(file_path:Path)->str",
          "intent": "creates file gherkin",
          "is_async": false
        },
        {
          "name": "compare_code",
          "signature": "(original:str,generated:str)->Dict[str, Any]",
          "intent": "compare code",
          "is_async": false
        },
        {
          "name": "extract_code_block",
          "signature": "(text:str,language:str='python')->str",
          "intent": "parses code block",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "difflib",
        "pathlib.Path",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "datetime",
        "llm_clients.BaseLLMClient",
        "llm_clients.get_client"
      ],
      "exports": [
        "generate_file_gherkin",
        "compare_code",
        "extract_code_block",
        "CodeReproducer"
      ]
    },
    {
      "path": "gherkin.py",
      "language": "python",
      "lines": 764,
      "classes": [
        {
          "name": "GherkinScenario",
          "bases": [],
          "docstring": "Represents a single Gherkin scenario."
        },
        {
          "name": "GherkinFeature",
          "bases": [],
          "docstring": "Represents a Gherkin feature file."
        },
        {
          "name": "StepDefinition",
          "bases": [],
          "docstring": "Represents a step definition."
        },
        {
          "name": "GherkinGenerator",
          "bases": [],
          "docstring": "Generates Gherkin feature files from code analysis.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(language:str='en')",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard',group_by:str='domain')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_test_scenarios",
              "signature": "(project:ProjectInfo,group_by:str='domain')->List[GherkinFeature]",
              "intent": "creates test scenarios",
              "is_async": false
            },
            {
              "name": "get_step_definitions",
              "signature": "()->List[StepDefinition]",
              "intent": "retrieves step definitions",
              "is_async": false
            },
            {
              "name": "_extract_features",
              "signature": "(project:ProjectInfo,group_by:str)->List[GherkinFeature]",
              "intent": "parses features",
              "is_async": false
            },
            {
              "name": "_create_feature",
              "signature": "(group_name:str,items:List[dict],project:ProjectInfo,group_by:str)->GherkinFeature",
              "intent": "creates feature",
              "is_async": false
            },
            {
              "name": "_create_scenario",
              "signature": "(category:str,items:List[dict],domain:str)->GherkinScenario",
              "intent": "creates scenario",
              "is_async": false
            },
            {
              "name": "_create_edge_case_scenarios",
              "signature": "(category:str,items:List[dict])->List[GherkinScenario]",
              "intent": "creates edge case scenarios",
              "is_async": false
            },
            {
              "name": "_create_when_step",
              "signature": "(func:FunctionInfo,verb:str)->str",
              "intent": "creates when step",
              "is_async": false
            },
            {
              "name": "_create_background",
              "signature": "(domain:str,items:List[dict])->Optional[List[str]]",
              "intent": "creates background",
              "is_async": false
            },
            {
              "name": "_create_examples_table",
              "signature": "(items:List[dict])->List[Dict[str, str]]",
              "intent": "creates examples table",
              "is_async": false
            },
            {
              "name": "_extract_param_placeholders",
              "signature": "(func:FunctionInfo)->str",
              "intent": "parses param placeholders",
              "is_async": false
            },
            {
              "name": "_register_step",
              "signature": "(step_type:str,pattern:str,func:FunctionInfo)",
              "intent": "registers step",
              "is_async": false
            },
            {
              "name": "_render_features",
              "signature": "(features:List[GherkinFeature],detail:str)->str",
              "intent": "formats features",
              "is_async": false
            },
            {
              "name": "_render_feature",
              "signature": "(feature:GherkinFeature,detail:str)->str",
              "intent": "formats feature",
              "is_async": false
            },
            {
              "name": "_render_scenario",
              "signature": "(scenario:GherkinScenario,detail:str)->str",
              "intent": "formats scenario",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_name_to_readable",
              "signature": "(name:str)->str",
              "intent": "name to readable",
              "is_async": false
            },
            {
              "name": "_step_to_func_name",
              "signature": "(step:str)->str",
              "intent": "step to func name",
              "is_async": false
            }
          ]
        },
        {
          "name": "StepDefinitionGenerator",
          "bases": [],
          "docstring": "Generates step definition stubs from Gherkin features.",
          "methods": [
            {
              "name": "generate_pytest_bdd",
              "signature": "(features:List[GherkinFeature])->str",
              "intent": "creates pytest bdd",
              "is_async": false
            },
            {
              "name": "generate_behave",
              "signature": "(features:List[GherkinFeature])->str",
              "intent": "creates behave",
              "is_async": false
            },
            {
              "name": "generate_cucumber_js",
              "signature": "(features:List[GherkinFeature])->str",
              "intent": "creates cucumber js",
              "is_async": false
            },
            {
              "name": "_step_to_func_name",
              "signature": "(step:str)->str",
              "intent": "step to func name",
              "is_async": false
            }
          ]
        },
        {
          "name": "CucumberYAMLGenerator",
          "bases": [],
          "docstring": "Generates Cucumber YAML configuration and test data.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "csv_to_gherkin",
          "signature": "(csv_content:str,language:str='en')->str",
          "intent": "csv to gherkin",
          "is_async": false
        },
        {
          "name": "gherkin_to_test_data",
          "signature": "(gherkin_content:str)->Dict[str, Any]",
          "intent": "gherkin to test data",
          "is_async": false
        }
      ],
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "typing.Any",
        "collections.defaultdict",
        "dataclasses.dataclass",
        "re",
        "models.ProjectInfo",
        "models.FunctionInfo"
      ],
      "exports": [
        "GherkinScenario",
        "GherkinFeature",
        "StepDefinition",
        "GherkinGenerator",
        "StepDefinitionGenerator",
        "CucumberYAMLGenerator",
        "csv_to_gherkin",
        "gherkin_to_test_data"
      ]
    },
    {
      "path": "schemas/logicml_schema.py",
      "language": "python",
      "lines": 184,
      "classes": [
        {
          "name": "LogicMLMethod",
          "bases": [],
          "docstring": "Schema for LogicML method."
        },
        {
          "name": "LogicMLClass",
          "bases": [],
          "docstring": "Schema for LogicML class."
        },
        {
          "name": "LogicMLModule",
          "bases": [],
          "docstring": "Schema for LogicML module."
        },
        {
          "name": "LogicMLSchema",
          "bases": [],
          "docstring": "Complete LogicML specification schema.\n    \n    Design Principles:\n    1."
        }
      ],
      "functions": [
        {
          "name": "validate_logicml",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates logicml",
          "is_async": false
        },
        {
          "name": "parse_logicml_header",
          "signature": "(line:str)->Optional[Dict[str, Any]]",
          "intent": "parses logicml header",
          "is_async": false
        },
        {
          "name": "extract_logicml_signature",
          "signature": "(sig_line:str)->Dict[str, Any]",
          "intent": "parses logicml signature",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "re"
      ],
      "exports": [
        "LogicMLMethod",
        "LogicMLClass",
        "LogicMLModule",
        "LogicMLSchema",
        "validate_logicml",
        "parse_logicml_header",
        "extract_logicml_signature"
      ]
    },
    {
      "path": "schemas/__init__.py",
      "language": "python",
      "lines": 25,
      "classes": [],
      "functions": [],
      "imports": [
        "yaml_schema.YAMLSchema",
        "yaml_schema.validate_yaml",
        "logicml_schema.LogicMLSchema",
        "logicml_schema.validate_logicml",
        "markdown_schema.MarkdownSchema",
        "markdown_schema.validate_markdown",
        "json_schema.JSONSchema",
        "json_schema.validate_json",
        "json_schema.parse_json_spec"
      ],
      "exports": []
    },
    {
      "path": "schemas/yaml_schema.py",
      "language": "python",
      "lines": 164,
      "classes": [
        {
          "name": "MethodSchema",
          "bases": [],
          "docstring": "Schema for method definition."
        },
        {
          "name": "ClassSchema",
          "bases": [],
          "docstring": "Schema for class definition."
        },
        {
          "name": "FunctionSchema",
          "bases": [],
          "docstring": "Schema for function definition."
        },
        {
          "name": "ModuleSchema",
          "bases": [],
          "docstring": "Schema for module definition."
        },
        {
          "name": "YAMLSchema",
          "bases": [],
          "docstring": "Complete YAML specification schema."
        }
      ],
      "functions": [
        {
          "name": "validate_yaml",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates yaml",
          "is_async": false
        },
        {
          "name": "_validate_module",
          "signature": "(module:Dict,index:int)->List[str]",
          "intent": "validates module",
          "is_async": false
        },
        {
          "name": "_validate_class",
          "signature": "(cls:Dict,prefix:str)->List[str]",
          "intent": "validates class",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Tuple",
        "yaml"
      ],
      "exports": [
        "MethodSchema",
        "ClassSchema",
        "FunctionSchema",
        "ModuleSchema",
        "YAMLSchema",
        "validate_yaml"
      ]
    },
    {
      "path": "schemas/json_schema.py",
      "language": "python",
      "lines": 206,
      "classes": [
        {
          "name": "JSONMethodSchema",
          "bases": [],
          "docstring": "Schema for JSON method definition."
        },
        {
          "name": "JSONClassSchema",
          "bases": [],
          "docstring": "Schema for JSON class definition."
        },
        {
          "name": "JSONFunctionSchema",
          "bases": [],
          "docstring": "Schema for JSON function definition."
        },
        {
          "name": "JSONModuleSchema",
          "bases": [],
          "docstring": "Schema for JSON module definition."
        },
        {
          "name": "JSONSchema",
          "bases": [],
          "docstring": "Complete JSON specification schema."
        }
      ],
      "functions": [
        {
          "name": "validate_json",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates json",
          "is_async": false
        },
        {
          "name": "_validate_json_module",
          "signature": "(module:Dict,index:int)->List[str]",
          "intent": "validates json module",
          "is_async": false
        },
        {
          "name": "_validate_json_class",
          "signature": "(cls:Dict,prefix:str)->List[str]",
          "intent": "validates json class",
          "is_async": false
        },
        {
          "name": "parse_json_spec",
          "signature": "(spec:str)->Optional[JSONSchema]",
          "intent": "parses json spec",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "json"
      ],
      "exports": [
        "JSONMethodSchema",
        "JSONClassSchema",
        "JSONFunctionSchema",
        "JSONModuleSchema",
        "JSONSchema",
        "validate_json",
        "parse_json_spec"
      ]
    },
    {
      "path": "schemas/markdown_schema.py",
      "language": "python",
      "lines": 118,
      "classes": [
        {
          "name": "MarkdownMethod",
          "bases": [],
          "docstring": "Schema for Markdown method."
        },
        {
          "name": "MarkdownClass",
          "bases": [],
          "docstring": "Schema for Markdown class."
        },
        {
          "name": "MarkdownModule",
          "bases": [],
          "docstring": "Schema for Markdown module."
        },
        {
          "name": "MarkdownSchema",
          "bases": [],
          "docstring": "Complete Markdown specification schema."
        }
      ],
      "functions": [
        {
          "name": "validate_markdown",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates markdown",
          "is_async": false
        },
        {
          "name": "extract_markdown_sections",
          "signature": "(spec:str)->Dict[str, Any]",
          "intent": "parses markdown sections",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Tuple",
        "re"
      ],
      "exports": [
        "MarkdownMethod",
        "MarkdownClass",
        "MarkdownModule",
        "MarkdownSchema",
        "validate_markdown",
        "extract_markdown_sections"
      ]
    },
    {
      "path": "benchmarks/common.py",
      "language": "python",
      "lines": 206,
      "classes": [],
      "functions": [
        {
          "name": "create_single_project",
          "signature": "(module_info,file_path:Path)->ProjectInfo",
          "intent": "creates single project",
          "is_async": false
        },
        {
          "name": "generate_spec",
          "signature": "(project:ProjectInfo,fmt:str)->str",
          "intent": "creates spec",
          "is_async": false
        },
        {
          "name": "_generate_token_json",
          "signature": "(project:ProjectInfo)->str",
          "intent": "creates token json",
          "is_async": false
        },
        {
          "name": "_generate_token_json_compact",
          "signature": "(project:ProjectInfo)->str",
          "intent": "creates token json compact",
          "is_async": false
        },
        {
          "name": "generate_spec_token",
          "signature": "(project:ProjectInfo,fmt:str)->str",
          "intent": "creates spec token",
          "is_async": false
        },
        {
          "name": "get_async_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str,with_tests:bool=False)->str",
          "intent": "retrieves async reproduction prompt",
          "is_async": false
        },
        {
          "name": "get_token_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str)->str",
          "intent": "retrieves token reproduction prompt",
          "is_async": false
        },
        {
          "name": "get_simple_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str)->str",
          "intent": "retrieves simple reproduction prompt",
          "is_async": false
        }
      ],
      "imports": [
        "datetime",
        "pathlib.Path",
        "json",
        "gherkin.GherkinGenerator",
        "generators.JSONGenerator",
        "generators.YAMLGenerator",
        "logicml.LogicMLGenerator",
        "markdown_format.MarkdownHybridGenerator",
        "toon_format.TOONGenerator",
        "models.ProjectInfo"
      ],
      "exports": [
        "create_single_project",
        "generate_spec",
        "generate_spec_token",
        "get_async_reproduction_prompt",
        "get_token_reproduction_prompt",
        "get_simple_reproduction_prompt"
      ]
    },
    {
      "path": "benchmarks/runner.py",
      "language": "python",
      "lines": 633,
      "classes": [
        {
          "name": "BenchmarkRunner",
          "bases": [],
          "docstring": "Unified benchmark runner for code2logic.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:Optional[BaseLLMClient]=None,config:Optional[BenchmarkConfig]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_should_use_llm",
              "signature": "()->bool",
              "intent": "checks use llm",
              "is_async": false
            },
            {
              "name": "_get_client",
              "signature": "()->BaseLLMClient",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "_template_generate_code",
              "signature": "(spec:str,fmt:str,file_name:str)->str",
              "intent": "template generate code",
              "is_async": false
            },
            {
              "name": "run_format_benchmark",
              "signature": "(folder:str,formats:List[str]=None,limit:Optional[int]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts format benchmark",
              "is_async": false
            },
            {
              "name": "_test_format",
              "signature": "(project,original:str,fmt:str,file_name:str...+2)->FormatResult",
              "intent": "checks format",
              "is_async": false
            },
            {
              "name": "run_file_benchmark",
              "signature": "(file_path:str,formats:List[str]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts file benchmark",
              "is_async": false
            },
            {
              "name": "run_function_benchmark",
              "signature": "(file_path:str,function_names:List[str]=None,limit:Optional[int]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts function benchmark",
              "is_async": false
            },
            {
              "name": "_test_function",
              "signature": "(func,content:str,language:str,file_path:Path...+2)->FunctionResult",
              "intent": "checks function",
              "is_async": false
            },
            {
              "name": "run_project_benchmark",
              "signature": "(project_path:str,formats:List[str]=None,limit:Optional[int]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts project benchmark",
              "is_async": false
            },
            {
              "name": "_reproduce_module",
              "signature": "(module_info,fmt:str,project_root:str,client:Optional[BaseLLMClient]...+1)->FileResult",
              "intent": "reproduce module",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_test_python_syntax",
          "signature": "(code:str)->bool",
          "intent": "checks python syntax",
          "is_async": false
        },
        {
          "name": "_test_python_runs",
          "signature": "(code:str,timeout:int=5)->bool",
          "intent": "checks python runs",
          "is_async": false
        },
        {
          "name": "_extract_code",
          "signature": "(response:str)->str",
          "intent": "parses code",
          "is_async": false
        },
        {
          "name": "run_benchmark",
          "signature": "(source:str,benchmark_type:str='format',formats:List[str]=None,limit:Optional[int]=None...+2)->BenchmarkResult",
          "intent": "starts benchmark",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "time",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "analyzer.analyze_project",
        "llm_clients.get_client",
        "llm_clients.BaseLLMClient",
        "utils.estimate_tokens",
        "metrics.ReproductionMetrics"
      ],
      "exports": [
        "BenchmarkRunner",
        "run_benchmark"
      ]
    },
    {
      "path": "benchmarks/__init__.py",
      "language": "python",
      "lines": 34,
      "classes": [],
      "functions": [],
      "imports": [
        "common.create_single_project",
        "common.generate_spec",
        "common.generate_spec_token",
        "common.get_async_reproduction_prompt",
        "common.get_token_reproduction_prompt",
        "common.get_simple_reproduction_prompt",
        "results.BenchmarkResult",
        "results.BenchmarkConfig",
        "results.FileResult",
        "results.FunctionResult"
      ],
      "exports": []
    },
    {
      "path": "benchmarks/results.py",
      "language": "python",
      "lines": 148,
      "classes": [
        {
          "name": "FormatResult",
          "bases": [],
          "docstring": "Result for a single format test.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "FileResult",
          "bases": [],
          "docstring": "Result for single file reproduction.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "FunctionResult",
          "bases": [],
          "docstring": "Result for single function reproduction.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "BenchmarkResult",
          "bases": [],
          "docstring": "Complete benchmark result.",
          "methods": [
            {
              "name": "__post_init__",
              "signature": "()",
              "intent": "creates init",
              "is_async": false
            },
            {
              "name": "calculate_aggregates",
              "signature": "()",
              "intent": "processes aggregates",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "to_json",
              "signature": "(indent:int=2)->str",
              "intent": "converts json",
              "is_async": false
            },
            {
              "name": "save",
              "signature": "(path:str)",
              "intent": "caches",
              "is_async": false
            },
            {
              "name": "load",
              "signature": "(path:str)->'BenchmarkResult'",
              "intent": "retrieves",
              "is_async": false
            }
          ]
        },
        {
          "name": "BenchmarkConfig",
          "bases": [],
          "docstring": "Configuration for benchmark runs.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "dataclasses.asdict",
        "datetime",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Any",
        "pathlib.Path",
        "json"
      ],
      "exports": [
        "FormatResult",
        "FileResult",
        "FunctionResult",
        "BenchmarkResult",
        "BenchmarkConfig"
      ]
    },
    {
      "path": "core/__init__.py",
      "language": "python",
      "lines": 20,
      "classes": [],
      "functions": [],
      "imports": [
        "models.FunctionInfo",
        "models.ClassInfo",
        "models.TypeInfo",
        "models.ModuleInfo",
        "models.DependencyNode",
        "models.ProjectInfo",
        "analyzer.ProjectAnalyzer",
        "analyzer.analyze_project",
        "dependency.DependencyAnalyzer",
        "errors.ErrorSeverity"
      ],
      "exports": []
    },
    {
      "path": "formats/__init__.py",
      "language": "python",
      "lines": 27,
      "classes": [],
      "functions": [],
      "imports": [
        "generators.YAMLGenerator",
        "generators.JSONGenerator",
        "generators.CompactGenerator",
        "generators.CSVGenerator",
        "generators.MarkdownGenerator",
        "gherkin.GherkinGenerator",
        "gherkin.StepDefinitionGenerator",
        "gherkin.CucumberYAMLGenerator",
        "gherkin.csv_to_gherkin",
        "gherkin.gherkin_to_test_data"
      ],
      "exports": []
    },
    {
      "path": "tools/__init__.py",
      "language": "python",
      "lines": 21,
      "classes": [],
      "functions": [],
      "imports": [
        "benchmark.ReproductionBenchmark",
        "benchmark.run_benchmark",
        "benchmark.FormatResult",
        "benchmark.BenchmarkResult",
        "code_review.analyze_code_quality",
        "code_review.check_security_issues",
        "code_review.check_performance_issues",
        "code_review.CodeReviewer",
        "refactor.RefactoringReport",
        "refactor.RefactoringSuggestion"
      ],
      "exports": []
    },
    {
      "path": "llm/__init__.py",
      "language": "python",
      "lines": 28,
      "classes": [],
      "functions": [],
      "imports": [
        "lolm.BaseLLMClient",
        "lolm.OpenRouterClient",
        "lolm.OllamaLocalClient",
        "lolm.LiteLLMClient",
        "lolm.get_client",
        "lolm.LLMManager",
        "lolm.LLMConfig",
        "lolm.RECOMMENDED_MODELS",
        "lolm.DEFAULT_MODELS",
        "intent.EnhancedIntentGenerator"
      ],
      "exports": []
    },
    {
      "path": "integrations/__init__.py",
      "language": "python",
      "lines": 5,
      "classes": [],
      "functions": [],
      "imports": [
        "mcp_server.handle_request",
        "mcp_server.call_tool",
        "mcp_server.run_server"
      ],
      "exports": []
    }
  ]
}