{
  "name": "code2logic",
  "statistics": {
    "files": 24,
    "lines": 8219,
    "languages": {
      "python": 24
    }
  },
  "entrypoints": [
    "code2logic/cli.py",
    "code2logic/llm.py",
    "code2logic/analyzer.py",
    "code2logic/parsers.py",
    "code2logic/intent.py",
    "code2logic/__init__.py",
    "code2logic/generators.py",
    "code2logic/models.py",
    "code2logic/similarity.py",
    "code2logic/dependency.py"
  ],
  "modules": [
    {
      "path": "code2logic/cli.py",
      "language": "python",
      "lines": 187,
      "imports": [
        "argparse",
        "os",
        "sys",
        "subprocess"
      ],
      "exports": [
        "ensure_dependencies",
        "main"
      ],
      "functions": [
        {
          "name": "ensure_dependencies",
          "signature": "()",
          "intent": "Auto-install optional dependencies for best results.",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "Main CLI entry point.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/llm.py",
      "language": "python",
      "lines": 355,
      "imports": [
        "json"
      ],
      "exports": [
        "OllamaClient",
        "LiteLLMClient",
        "CodeAnalyzer",
        "get_available_backends"
      ],
      "classes": [
        {
          "name": "OllamaClient",
          "bases": [],
          "docstring": "Direct Ollama API client.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self,config:LLMConfig)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(self,prompt:str,system:Optional[str])->str",
              "intent": "Generate completion from Ollama.",
              "is_async": false
            },
            {
              "name": "chat",
              "signature": "(self,messages:List[Dict[str, str]])->str",
              "intent": "Chat completion from Ollama.",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "(self)->bool",
              "intent": "Check if Ollama is running.",
              "is_async": false
            },
            {
              "name": "list_models",
              "signature": "(self)->List[str]",
              "intent": "List available models.",
              "is_async": false
            }
          ]
        },
        {
          "name": "LiteLLMClient",
          "bases": [],
          "docstring": "LiteLLM client for unified API access.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self,config:LLMConfig)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(self,prompt:str,system:Optional[str])->str",
              "intent": "Generate completion via LiteLLM.",
              "is_async": false
            },
            {
              "name": "chat",
              "signature": "(self,messages:List[Dict[str, str]])->str",
              "intent": "Chat completion via LiteLLM.",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "(self)->bool",
              "intent": "Check if LiteLLM backend is available.",
              "is_async": false
            }
          ]
        },
        {
          "name": "CodeAnalyzer",
          "bases": [],
          "docstring": "LLM-powered code analysis for Code2Logic.\n    \n    Example:\n        >>> from code2logic import analy",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self,model:str,provider:str,base_url:str)",
              "intent": "Initialize CodeAnalyzer.",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "(self)->bool",
              "intent": "Check if LLM backend is available.",
              "is_async": false
            },
            {
              "name": "suggest_refactoring",
              "signature": "(self,project)->List[Dict[str, Any]]",
              "intent": "Analyze project and suggest refactoring improvements.",
              "is_async": false
            },
            {
              "name": "find_semantic_duplicates",
              "signature": "(self,project)->List[Dict[str, Any]]",
              "intent": "Find semantically similar functions using LLM.",
              "is_async": false
            },
            {
              "name": "generate_code",
              "signature": "(self,project,target_lang:str,module_filter:Optional[str])->Dict[str, str]",
              "intent": "Generate code in target language from project analysis.",
              "is_async": false
            },
            {
              "name": "translate_function",
              "signature": "(self,name:str,signature:str,intent:str...+2)->str",
              "intent": "Translate a single function to another language.",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(self,f)->str",
              "intent": "Build compact signature.",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_available_backends",
          "signature": "()->Dict[str, bool]",
          "intent": "availability status of LLM backends.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/analyzer.py",
      "language": "python",
      "lines": 221,
      "imports": [
        "sys"
      ],
      "exports": [
        "ProjectAnalyzer",
        "\n    path: str,",
        "us() -> Dict[str, "
      ],
      "classes": [
        {
          "name": "ProjectAnalyzer",
          "bases": [],
          "docstring": "Main class for analyzing software projects.\n    \n    Orchestrates:\n    - File scanning and language ",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self,root_path:str,use_treesitter:bool,verbose:bool...+1)",
              "intent": "Initialize the project analyzer.",
              "is_async": false
            },
            {
              "name": "_print_status",
              "signature": "(self)",
              "intent": "Print library availability status.",
              "is_async": false
            },
            {
              "name": " Projec",
              "signature": "(Info)->     \"\"\"\n  ",
              "intent": "yze the project.",
              "is_async": false
            },
            {
              "name": "):\n        ",
              "signature": "(\"\"Sc)",
              "intent": "e all source files.\"\"\"",
              "is_async": false
            },
            {
              "name": "nts(self) -> List[s",
              "signature": "(r]:\n)->   \"\"\"Det",
              "intent": "t entry points.\"\"\"",
              "is_async": false
            },
            {
              "name": "elf) -> Dict:\n",
              "signature": "(    )->\"\n  ",
              "intent": "analysis statistics.",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "\n    path: str,",
          "signature": "(se_t:esi,bool = True,\n : ver,False,\n:-> P)-> \"\"\"\n    Co",
          "intent": "nce function to analyze a project.",
          "is_async": false
        },
        {
          "name": "us() -> Dict[str, ",
          "signature": "()->\n    \"\"\"\n    Ge",
          "intent": "lability status of optional libraries.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/parsers.py",
      "language": "python",
      "lines": 772,
      "imports": [
        "ast",
        "re"
      ],
      "exports": [
        "TreeSitterParser",
        "UniversalParser",
        "is_tree_sitter_available"
      ],
      "classes": [
        {
          "name": "TreeSitterParser",
          "bases": [],
          "docstring": "Parser using Tree-sitter for high-accuracy AST parsing.\n    \n    Supports Python, JavaScript, and Ty",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "intent": "Initialize Tree-sitter parsers for available languages.",
              "is_async": false
            },
            {
              "name": "_init_parsers",
              "signature": "(self)",
              "intent": "Initialize parsers for each supported language.",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "(self,language:str)->bool",
              "intent": "Check if Tree-sitter parser is available for a language.",
              "is_async": false
            },
            {
              "name": "get_supported_languages",
              "signature": "(cls)->List[str]",
              "intent": "list of potentially supported languages.",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(self,filepath:str,content:str,language:str)->Optional[ModuleInfo]",
              "intent": "Parse a source file using Tree-sitter.",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(self,filepath:str,content:str,tree)->ModuleInfo",
              "intent": "Parse Python source using Tree-sitter AST.",
              "is_async": false
            },
            {
              "name": "_extract_py_function",
              "signature": "(self,node,content:str,decorated_node)->Optional[FunctionInfo]",
              "intent": "Extract Python function from AST node.",
              "is_async": false
            },
            {
              "name": "_extract_py_class",
              "signature": "(self,node,content:str)->Optional[ClassInfo]",
              "intent": "Extract Python class from AST node.",
              "is_async": false
            },
            {
              "name": "_extract_py_import",
              "signature": "(self,node,content:str)->List[str]",
              "intent": "Extract import statement.",
              "is_async": false
            },
            {
              "name": "_extract_py_from_import",
              "signature": "(self,node,content:str)->List[str]",
              "intent": "Extract from ... import ... statement.",
              "is_async": false
            },
            {
              "name": "_extract_py_constant",
              "signature": "(self,node,content:str)->Optional[str]",
              "intent": "Extract constant (UPPERCASE assignment).",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(self,filepath:str,content:str,tree...+1)->ModuleInfo",
              "intent": "Parse JavaScript/TypeScript source using Tree-sitter AST.",
              "is_async": false
            },
            {
              "name": "_extract_js_class",
              "signature": "(self,node,content:str)->Optional[ClassInfo]",
              "intent": "Extract JS/TS class from AST node.",
              "is_async": false
            },
            {
              "name": "_extract_js_method",
              "signature": "(self,node,content:str)->Optional[FunctionInfo]",
              "intent": "Extract JS/TS method from AST node.",
              "is_async": false
            },
            {
              "name": "_extract_js_function",
              "signature": "(self,node,content:str)->Optional[FunctionInfo]",
              "intent": "Extract JS/TS function from AST node.",
              "is_async": false
            },
            {
              "name": "_extract_js_arrow_fn",
              "signature": "(self,node,content:str)->Optional[FunctionInfo]",
              "intent": "Extract arrow function assigned to const.",
              "is_async": false
            },
            {
              "name": "_extract_js_params",
              "signature": "(self,params_node,content:str)->List[str]",
              "intent": "Extract JS/TS function parameters.",
              "is_async": false
            },
            {
              "name": "_extract_ts_type",
              "signature": "(self,node,content:str)->Optional[TypeInfo]",
              "intent": "Extract TypeScript interface or type alias.",
              "is_async": false
            },
            {
              "name": "_extract_ts_enum",
              "signature": "(self,node,content:str)->Optional[TypeInfo]",
              "intent": "Extract TypeScript enum.",
              "is_async": false
            },
            {
              "name": "_extract_js_constant",
              "signature": "(self,node,content:str)->Optional[str]",
              "intent": "Extract constant (UPPERCASE const).",
              "is_async": false
            },
            {
              "name": "_extract_js_comment",
              "signature": "(self,node,content:str)->Optional[str]",
              "intent": "Extract JS comment content.",
              "is_async": false
            },
            {
              "name": "_find_child",
              "signature": "(self,node,type_name:str)",
              "intent": "Find first child of given type.",
              "is_async": false
            },
            {
              "name": "_text",
              "signature": "(self,node,content:str)->str",
              "intent": "text content of node.",
              "is_async": false
            },
            {
              "name": "_extract_string",
              "signature": "(self,node,content:str)->str",
              "intent": "Extract string content without quotes.",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalParser",
          "bases": [],
          "docstring": "Fallback parser using Python AST and regex.\n    \n    Used when Tree-sitter is not available. Provide",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "intent": "Initialize the universal parser.",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(self,filepath:str,content:str,language:str)->Optional[ModuleInfo]",
              "intent": "Parse a source file using AST or regex.",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(self,filepath:str,content:str)->Optional[ModuleInfo]",
              "intent": "Parse Python using built-in AST.",
              "is_async": false
            },
            {
              "name": "_extract_ast_function",
              "signature": "(self,node)->FunctionInfo",
              "intent": "Extract function from Python AST node.",
              "is_async": false
            },
            {
              "name": "_extract_ast_class",
              "signature": "(self,node:ast.ClassDef)->ClassInfo",
              "intent": "Extract class from Python AST node.",
              "is_async": false
            },
            {
              "name": "_ann_str",
              "signature": "(self,node)->str",
              "intent": "Convert AST annotation to string.",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(self,filepath:str,content:str,language:str)->ModuleInfo",
              "intent": "Parse JS/TS using regex patterns.",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_tree_sitter_available",
          "signature": "()->bool",
          "intent": "Check if Tree-sitter is available.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/intent.py",
      "language": "python",
      "lines": 180,
      "imports": [
        "re"
      ],
      "exports": [
        "EnhancedIntentGenerator"
      ],
      "classes": [
        {
          "name": "EnhancedIntentGenerator",
          "bases": [],
          "docstring": "Generator intencji z NLP - lemmatyzacja, ekstrakcja z docstringÃ³w.\n    \n    Supports both English an",
          "methods": [
            {
              "name": "__(self,",
              "signature": "(lang,str :'en)",
              "intent": "Initialize the intent generator.",
              "is_async": false
            },
            {
              "name": "te(self,",
              "signature": "(name,str,:ocs,ing: Opti:al[str] = Non)->   ",
              "intent": "Generate intent from function name and optional docstring.",
              "is_async": false
            },
            {
              "name": "ct_from_docstring(self,",
              "signature": "(docs,ing: str):> O)->al[str]:\n    ",
              "intent": "ract intent from docstring's first line.\"\"\"",
              "is_async": false
            },
            {
              "name": "_name(self,",
              "signature": "(name,str):> L)->tr]:\n    ",
              "intent": "Split function name into words.",
              "is_async": false
            },
            {
              "name": "ailable_features(cls) ",
              "signature": "(> d)->tr, bool]:\n    ",
              "intent": "dictionary of available NLP features.",
              "is_async": false
            }
          ]
        }
      ]
    },
    {
      "path": "code2logic/__init__.py",
      "language": "python",
      "lines": 76,
      "imports": [],
      "exports": []
    },
    {
      "path": "code2logic/generators.py",
      "language": "python",
      "lines": 827,
      "imports": [
        "json"
      ],
      "exports": [
        "MarkdownGenerator",
        "ltra-compact out",
        " output for m",
        " output for h",
        "utput optimi"
      ],
      "classes": [
        {
          "name": "MarkdownGenerator",
          "bases": [],
          "docstring": "Generates Markdown output for project analysis.\n    \n    Produces human-readable documentation with:",
          "methods": [
            {
              "name": "generate",
              "signature": "(self,project:ProjectInfo,detail_level:str)->str",
              "intent": "Generate Markdown output.",
              "is_async": false
            },
            {
              "name": ": List[st",
              "signature": "(], p,ject::rojectInf,:\n     : \"\"\"Generat)",
              "intent": "tructure tree.\"\"\"",
              "is_async": false
            },
            {
              "name": ": List[str]",
              "signature": "( tre, dict:prefix: s,, de:h: i, = 0)::   ...+1)",
              "intent": "ee structure.\"\"\"",
              "is_async": false
            },
            {
              "name": ": ModuleInf",
              "signature": "(, \n ,     :         ,e:il: str, p,    \"\":ene...+1)",
              "intent": "fn = Path(m.path).name",
              "is_async": false
            },
            {
              "name": "lassInfo, ",
              "signature": "(etai, str):        \",Gen:ate class,ocumen:tio)",
              "intent": "kind = \"interface\" if cls.is_int",
              "is_async": false
            },
            {
              "name": "   \"",
              "signature": "(\"Gen,a: function si)->re.",
              "intent": "\"",
              "is_async": false
            }
          ]
        },
        {
          "name": "ltra-compact out",
          "bases": [],
          "docstring": "r token efficiency.\n    \n    Optimized for minimal token usage while preserving\n    essential inform",
          "methods": [
            {
              "name": "tr:\n    ",
              "signature": "(   \",\n      :Generate co)-> ou",
              "intent": "tr:",
              "is_async": false
            }
          ]
        },
        {
          "name": " output for m",
          "bases": [],
          "docstring": " processing.\n    \n    Suitable for:\n    - RAG (Retrieval-Augmented Generation) systems\n    - Databas",
          "methods": [
            {
              "name": ": bool =",
              "signature": "(Fals, \n     :          d,ail::tr =, \"\"\"\n :   )->tpu",
              "intent": ": bool =",
              "is_async": false
            },
            {
              "name": "fo, detail: str)",
              "signature": "(-> s,:\n     : \"\"\"Generat,nested:SON)->ctu",
              "intent": "def ser_func(f: FunctionInfo) ->",
              "is_async": false
            },
            {
              "name": ", detail: str)",
              "signature": "(-> s,:\n     : \"\"\"Generat,flat J:N l)->or ",
              "intent": ", detail: str)",
              "is_async": false
            },
            {
              "name": "lem_type: str, nam",
              "signature": "(: st,\n:          ,         : si,atur: st...+4)->ow f",
              "intent": "lem type: str, nam",
              "is_async": false
            },
            {
              "name": "> str:\n        \"",
              "signature": "(\"Bui, :mpact signat)->\"\"\n",
              "intent": "rams = ','.join(f.params[:4])",
              "is_async": false
            },
            {
              "name": "    \"\"\"Cate",
              "signature": "(oriz,by n:e p)->n.\"",
              "intent": "name_lower = name.lower().split(",
              "is_async": false
            },
            {
              "name": "        \"\"\"Extr",
              "signature": "(ct d,ain :om )->\"\"\"",
              "intent": "arts = path.lower().replace('\\\\",
              "is_async": false
            },
            {
              "name": " str) -> str:",
              "signature": "(    ,  \"\":omp,e short h:h.\")->   ",
              "intent": " str)  > str:",
              "is_async": false
            }
          ]
        },
        {
          "name": " output for h",
          "bases": [],
          "docstring": "eadable representation.\n    \n    Supports both nested (hierarchical) and flat (table-like) formats.\n",
          "methods": [
            {
              "name": ": bool =",
              "signature": "(Fals, \n     :          d,ail::tr =, \"\"\"\n :   )->tpu",
              "intent": ": bool =",
              "is_async": false
            },
            {
              "name": "fo, detail: str)",
              "signature": "(-> d,t:\n    :  \"\"\"Build ,at dat:str)->e op",
              "intent": "r comparisons.\"\"\"",
              "is_async": false
            },
            {
              "name": "Info, detail: str)",
              "signature": "(-> d,t:\n    :  \"\"\"Build ,sted h:rar)->l da",
              "intent": "info, detail: str)",
              "is_async": false
            },
            {
              "name": "r, name: s",
              "signature": "(r, s,natu:: s,,\n       :   ,    :ang...+4)->lat ",
              "intent": "r, name: s",
              "is_async": false
            },
            {
              "name": "unctionInfo, langua",
              "signature": "(e: s,,\n  :   , :            , detail::tr,...+3)-> fun",
              "intent": "sig = self._build_signature(f)",
              "is_async": false
            },
            {
              "name": "name: str, f: Fun",
              "signature": "(tion,fo,\n:   ,          :   , :nguage: str,...+4)->od.\"",
              "intent": "sig = self._build_signature(f)",
              "is_async": false
            },
            {
              "name": "detail: str) -> d",
              "signature": "(ct:\n, :   \"\"\"Conver,functi: to)-> for",
              "intent": "detail: str)  > d",
              "is_async": false
            },
            {
              "name": "tail: str) -> d",
              "signature": "(ct:\n, :   \"\"\"Conver,method:o d)->or n",
              "intent": "tail: str)  > d",
              "is_async": false
            },
            {
              "name": "> str:\n        \"",
              "signature": "(\"Bui, :mpact signat)->tri",
              "intent": "params = ','.join(f.params[:4])",
              "is_async": false
            },
            {
              "name": "    \"\"\"Cate",
              "signature": "(oriz,func:on )->me ",
              "intent": "name_lower = name.lower()",
              "is_async": false
            },
            {
              "name": "        \"\"\"Extr",
              "signature": "(ct d,ain :om )->pat",
              "intent": "parts = path.lower().replace('\\\\",
              "is_async": false
            },
            {
              "name": " str) -> str:",
              "signature": "(    ,  \"\":omp,e short h:h f)->ick",
              "intent": " str)  > str:",
              "is_async": false
            },
            {
              "name": "ectInfo, flat: bool, ",
              "signature": "(    ,       :           ,  de:il: ,YAML g:era)->wit",
              "intent": "ect info, flat: bool,",
              "is_async": false
            }
          ]
        },
        {
          "name": "utput optimi",
          "bases": [],
          "docstring": "r LLM processing.\n    \n    CSV is the most token-efficient format (~50% smaller than JSON).\n    Each",
          "methods": [
            {
              "name": "il: str ",
              "signature": "( 'st,dard') : str:\n     , \"\"\"\n :   )->put",
              "intent": "il: str",
              "is_async": false
            },
            {
              "name": ": str, nam",
              "signature": "(: st, :          ,      sig:tur, str:cal...+4)->\"\"\n ",
              "intent": ": str, nam",
              "is_async": false
            },
            {
              "name": "elem_type: str, nam",
              "signature": "(: st,\n:          ,         :  f,Func:onI...+4)->on/m",
              "intent": "sig = self._build_signature(f)",
              "is_async": false
            },
            {
              "name": "> str:\n        \"",
              "signature": "(\"Bui, :mpact signat)->\"\"\n",
              "intent": "rams = ','.join(p.split(':')[0",
              "is_async": false
            },
            {
              "name": "    \"\"\"Cate",
              "signature": "(oriz,func:on )->me ",
              "intent": "name_lower = name.lower().split",
              "is_async": false
            },
            {
              "name": "        \"\"\"Extr",
              "signature": "(ct d,ain :om )->pat",
              "intent": "parts = path.lower().replace('\\\\",
              "is_async": false
            },
            {
              "name": " str) -> str:",
              "signature": "(    ,  \"\":omp,e short h:h f)->ick",
              "intent": " str)  > str:",
              "is_async": false
            },
            {
              "name": "    \"\"\"Esca",
              "signature": "(e te, for:SV )->ve ",
              "intent": "limit commas).\"\"\"",
              "is_async": false
            }
          ]
        }
      ]
    },
    {
      "path": "code2logic/models.py",
      "language": "python",
      "lines": 150,
      "imports": [],
      "exports": []
    },
    {
      "path": "code2logic/similarity.py",
      "language": "python",
      "lines": 123,
      "imports": [],
      "exports": [
        "SimilarityDetector",
        "is_rapidfuzz_available"
      ],
      "classes": [
        {
          "name": "SimilarityDetector",
          "bases": [],
          "docstring": "Detects similar functions using fuzzy string matching.\n    \n    Uses Rapidfuzz for fast similarity c",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self,threshold:float)",
              "intent": "Initialize the similarity detector.",
              "is_async": false
            },
            {
              "name": "find_similar_functions",
              "signature": "(self,modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "Find similar functions across all modules.",
              "is_async": false
            },
            {
              "name": "find_duplicate_signatures",
              "signature": "(self,modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "Find functions with identical signatures.",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(self,name:str,params:List[str],return_type:str)->str",
              "intent": "Build a normalized signature string.",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_rapidfuzz_available",
          "signature": "()->bool",
          "intent": "Check if Rapidfuzz is available.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/dependency.py",
      "language": "python",
      "lines": 187,
      "imports": [],
      "exports": [
        "DependencyAnalyzer",
        "is_networkx_available"
      ],
      "classes": [
        {
          "name": "DependencyAnalyzer",
          "bases": [],
          "docstring": "Analyzes dependency graphs using NetworkX.\n    \n    Computes:\n    - PageRank: Importance metric for ",
          "methods": [
            {
              "name": "__init__",
              "signature": "(self)",
              "intent": "Initialize the dependency analyzer.",
              "is_async": false
            },
            {
              "name": "build_graph",
              "signature": "(self,modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "Build dependency graph from modules.",
              "is_async": false
            },
            {
              "name": "analyze_metrics",
              "signature": "(self)->Dict[str, DependencyNode]",
              "intent": "Compute metrics for each node in the graph.",
              "is_async": false
            },
            {
              "name": "get_entrypoints",
              "signature": "(self)->List[str]",
              "intent": "entry points (nodes with no incoming edges).",
              "is_async": false
            },
            {
              "name": "get_hubs",
              "signature": "(self)->List[str]",
              "intent": "hub modules (high centrality).",
              "is_async": false
            },
            {
              "name": "detect_cycles",
              "signature": "(self)->List[List[str]]",
              "intent": "Detect dependency cycles.",
              "is_async": false
            },
            {
              "name": "get_strongly_connected_components",
              "signature": "(self)->List[List[str]]",
              "intent": "strongly connected components.",
              "is_async": false
            },
            {
              "name": "_detect_clusters",
              "signature": "(self)->Dict[str, int]",
              "intent": "Detect clusters using connected components.",
              "is_async": false
            },
            {
              "name": "_module_name",
              "signature": "(self,path:str)->str",
              "intent": "Convert file path to module name.",
              "is_async": false
            },
            {
              "name": "get_dependency_depth",
              "signature": "(self,module_path:str)->int",
              "intent": "the maximum depth of dependencies for a module.",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_networkx_available",
          "signature": "()->bool",
          "intent": "Check if NetworkX is available.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/mcp_server.py",
      "language": "python",
      "lines": 292,
      "imports": [
        "json",
        "sys"
      ],
      "exports": [
        "handle_request",
        "call_tool",
        "run_server"
      ],
      "functions": [
        {
          "name": "handle_request",
          "signature": "(request:dict)->dict",
          "intent": "Handle incoming MCP request.",
          "is_async": false
        },
        {
          "name": "call_tool",
          "signature": "(tool_name:str,arguments:dict)->str",
          "intent": "Execute a tool and return result.",
          "is_async": false
        },
        {
          "name": "run_server",
          "signature": "()",
          "intent": "Run the MCP server.",
          "is_async": false
        }
      ]
    },
    {
      "path": "code2logic/gherkin.py",
      "language": "python",
      "lines": 766,
      "imports": [
        "re",
        "hashlib"
      ],
      "exports": [
        "GherkinGenerator",
        "nitionGenerator:\n    \"\"",
        "YAMLGenerator:\n    \"\"",
        "herkin(csv_con"
      ],
      "classes": [
        {
          "name": "GherkinGenerator",
          "bases": [],
          "docstring": "Generates Gherkin feature files from code analysis.\n    \n    Achieves ~50x token compression compare",
          "methods": [
            {
              "name": "(self, l",
              "signature": "(ngua,: str = :n'))",
              "intent": "Initialize GherkinGenerator.",
              "is_async": false
            },
            {
              "name": "(self, p",
              "signature": "(ojec, Projec:nfo, detail,str = :tan,: str = :oma)->   ",
              "intent": "Generate Gherkin feature files from project analysis.",
              "is_async": false
            },
            {
              "name": "_test_scenarios(self, p",
              "signature": "(ojec, Projec:nfo,\n      ,: str = :oma)->rkinFeature]:\n      ",
              "intent": "Generate structured test scenarios for programmatic use.",
              "is_async": false
            },
            {
              "name": "_definitions(self) -",
              "signature": "( Lis)->pDefinition]:\n      ",
              "intent": "ll unique step definitions from generated features.\"\"\"",
              "is_async": false
            },
            {
              "name": "_features(self, p",
              "signature": "(ojec, Projec:nfo, \n     ,: str) -:Lis)->rkinFeature]:\n      ",
              "intent": "ct Gherkin features from project.\"\"\"",
              "is_async": false
            },
            {
              "name": "feature(self, g",
              "signature": "(oup_,me: str, i:ms:,ist[d:t], \n     , Projec:nfo, group_...+1)->eature:\n      ",
              "intent": "e a Gherkin feature from grouped items.\"\"\"",
              "is_async": false
            },
            {
              "name": "scenario(self, c",
              "signature": "(tego,: str, i:ms:,ist[d:t], \n     ,str) -:Ghe)->cenario:\n      ",
              "intent": "e a scenario from category items.\"\"\"",
              "is_async": false
            },
            {
              "name": "edge_case_scenarios(self, c",
              "signature": "(tego,: str, \n:   ,ist[d:t]) -> Lis)->rkinScenario]:\n      ",
              "intent": "e edge case scenarios for thorough testing.\"\"\"",
              "is_async": false
            },
            {
              "name": "when_step(self, f",
              "signature": "(nc: ,ncti:Info, verb: ,r) -:str)->   ",
              "intent": "e a When step from function info.\"\"\"",
              "is_async": false
            },
            {
              "name": "background(self, d",
              "signature": "(main,str, \n:   ,ist[d:t]) -> Opt)->[List[str]]:\n      ",
              "intent": "e background steps for common setup.\"\"\"",
              "is_async": false
            },
            {
              "name": "examples_table(self, i",
              "signature": "(ems:,ist[d:t]) -> Lis)->t[str, str]]:\n      ",
              "intent": "e Examples table for Scenario Outline.\"\"\"",
              "is_async": false
            },
            {
              "name": "_param_placeholders(self, f",
              "signature": "(nc: ,ncti:Info) -> str)->   ",
              "intent": "ct parameter placeholders for Gherkin steps.\"\"\"",
              "is_async": false
            },
            {
              "name": "r_step(self, s",
              "signature": "(ep_t,e: str, p:ter, str, f:c: ,ncti:Info):\n     )",
              "intent": "ter a step definition for later generation.\"\"\"",
              "is_async": false
            },
            {
              "name": "features(self, f",
              "signature": "(atur,: List[G:rkinFeature], \n     ,str) -:str)->   ",
              "intent": "r features to Gherkin text.\"\"\"",
              "is_async": false
            },
            {
              "name": "feature(self, f",
              "signature": "(atur, Gherki:eature, detail,str) -:str)->   ",
              "intent": "r a single feature.\"\"\"",
              "is_async": false
            },
            {
              "name": "scenario(self, s",
              "signature": "(enar,: Gherki:cenario, detail,str) -:str)->   ",
              "intent": "r a single scenario.\"\"\"",
              "is_async": false
            },
            {
              "name": "ize(self, n",
              "signature": "(me: ,r) -:str)->   ",
              "intent": "orize function by name pattern.\"\"\"",
              "is_async": false
            },
            {
              "name": "_domain(self, p",
              "signature": "(th: ,r) -:str)->   ",
              "intent": "ct domain from file path.\"\"\"",
              "is_async": false
            },
            {
              "name": "_readable(self, n",
              "signature": "(me: ,r) -:str)->   ",
              "intent": "rt function name to readable text.\"\"\"",
              "is_async": false
            },
            {
              "name": "_func_name(self, s",
              "signature": "(ep: ,r) -:str)->   ",
              "intent": "rt step text to valid function name.\"\"\"",
              "is_async": false
            }
          ]
        },
        {
          "name": "nitionGenerator:\n    \"\"",
          "bases": [],
          "docstring": "Generates step definition stubs from Gherkin features.\n    \n    Supports multiple frameworks:\n    - ",
          "methods": [
            {
              "name": "_pytest_bdd(self, f",
              "signature": "(atur,: List[G:rkinFeature]) -> str)->   ",
              "intent": "ate pytest-bdd step definitions.\"\"\"",
              "is_async": false
            },
            {
              "name": "_behave(self, f",
              "signature": "(atur,: List[G:rkinFeature]) -> str)->   ",
              "intent": "ate behave step definitions.\"\"\"",
              "is_async": false
            },
            {
              "name": "_cucumber_js(self, f",
              "signature": "(atur,: List[G:rkinFeature]) -> str)->   ",
              "intent": "ate Cucumber.js step definitions.\"\"\"",
              "is_async": false
            },
            {
              "name": "_func_name(self, s",
              "signature": "(ep: ,r) -:str)->   ",
              "intent": "rt step text to valid function name.\"\"\"",
              "is_async": false
            }
          ]
        },
        {
          "name": "YAMLGenerator:\n    \"\"",
          "bases": [],
          "docstring": "Generates Cucumber YAML configuration and test data.\n    \n    YAML format provides ~5x token compres",
          "methods": [
            {
              "name": "(self, p",
              "signature": "(ojec, Projec:nfo, detail,str = :tan)->   ",
              "intent": "ate Cucumber YAML configuration.\"\"\"",
              "is_async": false
            },
            {
              "name": "_domain(self, p",
              "signature": "(th: ,r) -:str)->   ",
              "intent": "ct domain from path.\"\"\"",
              "is_async": false
            },
            {
              "name": "ize(self, n",
              "signature": "(me: ,r) -:str)->   ",
              "intent": "orize by name pattern.\"\"\"",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "herkin(csv_con",
          "signature": "(ent: str, l:gua,: str = :n'))-> \"\"",
          "intent": "Convert CSV analysis directly to Gherkin.",
          "is_async": false
        },
        {
          "name": "_test_data(gherkin_c",
          "signature": "(ntent: str) -> :ct[)->Any]:\n    \"\"\"\n",
          "intent": "tract structured test data from Gherkin for LLM processing.",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/refactor_suggestions.py",
      "language": "python",
      "lines": 203,
      "imports": [
        "sys",
        "json"
      ],
      "exports": [
        "check_ollama",
        "generate_with_ollama",
        "find_issues",
        "get_llm_suggestions",
        "main"
      ],
      "functions": [
        {
          "name": "check_ollama",
          "signature": "()->bool",
          "intent": "Check if Ollama is running.",
          "is_async": false
        },
        {
          "name": "generate_with_ollama",
          "signature": "(prompt:str,system:str)->str",
          "intent": "Generate text using Ollama.",
          "is_async": false
        },
        {
          "name": "find_issues",
          "signature": "(project)->list",
          "intent": "Find potential code issues.",
          "is_async": false
        },
        {
          "name": "get_llm_suggestions",
          "signature": "(issues:list,project)->str",
          "intent": "detailed suggestions from LLM.",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "Main refactoring analysis.",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/token_efficiency.py",
      "language": "python",
      "lines": 168,
      "imports": [
        "sys"
      ],
      "exports": [
        "count_tokens",
        "estimate_cost",
        "analyze_format",
        "main"
      ],
      "functions": [
        {
          "name": "count_tokens",
          "signature": "(text:str)->int",
          "intent": "Approximate token count (~4 chars per token for English).",
          "is_async": false
        },
        {
          "name": "estimate_cost",
          "signature": "(tokens:int,model:str)->float",
          "intent": "Estimate API cost based on token count.",
          "is_async": false
        },
        {
          "name": "analyze_format",
          "signature": "(name:str,content:str,baseline_tokens:int)->Dict[str, Any]",
          "intent": "Analyze a single format's efficiency.",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "Run token efficiency analysis.",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/bdd_workflow.py",
      "language": "python",
      "lines": 169,
      "imports": [
        "s\ni",
        "on\nf"
      ],
      "exports": [
        "lculate_token_savings(c",
        "in()"
      ],
      "functions": [
        {
          "name": "lculate_token_savings(c",
          "signature": "(v_content: :r, ,erkin_content: :r) )->ct:\n",
          "intent": "Calculate token savings between formats.\"\"\"",
          "is_async": false
        },
        {
          "name": "in()",
          "signature": "()",
          "intent": "Run BDD workflow.\"\"\"",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/compare_projects.py",
      "language": "python",
      "lines": 176,
      "imports": [
        "sys",
        "json"
      ],
      "exports": [
        "compute_hash",
        "extract_elements",
        "compare_projects",
        "print_comparison",
        "\"Mai"
      ],
      "functions": [
        {
          "name": "compute_hash",
          "signature": "(name:str,signature:str)->str",
          "intent": "Compute hash for function comparison.",
          "is_async": false
        },
        {
          "name": "extract_elements",
          "signature": "(project)->dict",
          "intent": "Extract all elements from project with hashes.",
          "is_async": false
        },
        {
          "name": "compare_projects",
          "signature": "(project1,project2)->dict",
          "intent": "Compare two projects.",
          "is_async": false
        },
        {
          "name": "print_comparison",
          "signature": "(result:dict)",
          "intent": "Print comparison results.",
          "is_async": false
        },
        {
          "name": "\"Mai",
          "signature": "()",
          "intent": "\"mai",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/quick_start.py",
      "language": "python",
      "lines": 151,
      "imports": [
        "sys"
      ],
      "exports": [
        "main"
      ],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/generate_code.py",
      "language": "python",
      "lines": 111,
      "imports": [
        "sys",
        "json"
      ],
      "exports": [
        "check_ollama",
        "generate_with_ollama",
        "generate_code_from_csv",
        "main"
      ],
      "functions": [
        {
          "name": "check_ollama",
          "signature": "()",
          "intent": "Check if Ollama is running.",
          "is_async": false
        },
        {
          "name": "generate_with_ollama",
          "signature": "(prompt:str,system:str)->str",
          "intent": "Generate text using Ollama API.",
          "is_async": false
        },
        {
          "name": "generate_code_from_csv",
          "signature": "(csv_content:str,target_lang:str)->dict",
          "intent": "Generate code from CSV analysis.",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "Main example.",
          "is_async": false
        }
      ]
    },
    {
      "path": "examples/duplicate_detection.py",
      "language": "python",
      "lines": 286,
      "imports": [
        "sys",
        "json",
        "hashlib"
      ],
      "exports": [
        "compute_signature_hash",
        "compute_name_hash",
        "normalize_intent",
        "find_duplicates",
        "categorize",
        "extract_domain",
        "generate_report",
        "main"
      ],
      "functions": [
        {
          "name": "compute_signature_hash",
          "signature": "(params:List[str],return_type:str)->str",
          "intent": "Compute hash of function signature (ignoring name).",
          "is_async": false
        },
        {
          "name": "compute_name_hash",
          "signature": "(name:str,params:List[str])->str",
          "intent": "Compute hash for exact duplicate detection.",
          "is_async": false
        },
        {
          "name": "normalize_intent",
          "signature": "(intent:str)->str",
          "intent": "Normalize intent for comparison.",
          "is_async": false
        },
        {
          "name": "find_duplicates",
          "signature": "(project)->Dict[str, Any]",
          "intent": "Find all types of duplicates in project.",
          "is_async": false
        },
        {
          "name": "categorize",
          "signature": "(name:str)->str",
          "intent": "Categorize function by name.",
          "is_async": false
        },
        {
          "name": "extract_domain",
          "signature": "(path:str)->str",
          "intent": "Extract domain from path.",
          "is_async": false
        },
        {
          "name": "generate_report",
          "signature": "(results:Dict[str, Any],project_name:str)->str",
          "intent": "Generate markdown deduplication report.",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "Run duplicate detection.",
          "is_async": false
        }
      ]
    },
    {
      "path": "tests/conftest.py",
      "language": "python",
      "lines": 233,
      "imports": [
        "pytest",
        "tempfile"
      ],
      "exports": [
        "sample_python_code",
        "sample_javascript_code",
        "sample_java_code",
        "temp_project_dir",
        "sample_project",
        "sample_module",
        "sample_project_model",
        "mock_llm_config",
        "sample_analysis_result"
      ],
      "functions": [
        {
          "name": "sample_python_code",
          "signature": "()->str",
          "intent": "Sample Python code for testing.",
          "is_async": false
        },
        {
          "name": "sample_javascript_code",
          "signature": "()->str",
          "intent": "Sample JavaScript code for testing.",
          "is_async": false
        },
        {
          "name": "sample_java_code",
          "signature": "()->str",
          "intent": "Sample Java code for testing.",
          "is_async": false
        },
        {
          "name": "temp_project_dir",
          "signature": "()",
          "intent": "a temporary project directory.",
          "is_async": false
        },
        {
          "name": "sample_project",
          "signature": "(temp_project_dir,sample_python_code)",
          "intent": "a sample project with Python files.",
          "is_async": false
        },
        {
          "name": "sample_module",
          "signature": "()",
          "intent": "a sample module for testing.",
          "is_async": false
        },
        {
          "name": "sample_project_model",
          "signature": "()",
          "intent": "a sample project model for testing.",
          "is_async": false
        },
        {
          "name": "mock_llm_config",
          "signature": "()",
          "intent": "Mock LLM configuration for testing.",
          "is_async": false
        },
        {
          "name": "sample_analysis_result",
          "signature": "()",
          "intent": "Sample analysis result for testing.",
          "is_async": false
        }
      ]
    },
    {
      "path": "tests/__init__.py",
      "language": "python",
      "lines": 3,
      "imports": [],
      "exports": []
    },
    {
      "path": "tests/test_generators.py",
      "language": "python",
      "lines": 207,
      "imports": [
        "json",
        "pytest"
      ],
      "exports": [
        "sample_project",
        "TestMarkdownGenerator",
        "tCompactGenerator:\n ",
        "tJSONGenerator:\n "
      ],
      "classes": [
        {
          "name": "TestMarkdownGenerator",
          "bases": [],
          "docstring": "Tests for MarkdownGenerator.",
          "methods": [
            {
              "name": "test_generate_basic",
              "signature": "(self,sample_project)",
              "intent": "Test basic Markdown generation.",
              "is_async": false
            },
            {
              "name": "t_generate_includes_modules(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that modules are included.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_includes_classes(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that classes are included.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_includes_functions(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that functions are included.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_includes_entrypoints(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that entrypoints are included.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_detail_levels(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test different detail levels.\"\"\"",
              "is_async": false
            }
          ]
        },
        {
          "name": "tCompactGenerator:\n ",
          "bases": [],
          "docstring": "Tests for CompactGenerator.\"\"\"\n\n ",
          "methods": [
            {
              "name": "t_generate_basic(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test basic compact generation.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_includes_hubs(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that ENTRY is included.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_compact_is_smaller(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that compact output is smaller than markdown.\"\"\"",
              "is_async": false
            }
          ]
        },
        {
          "name": "tJSONGenerator:\n ",
          "bases": [],
          "docstring": "Tests for JSONGenerator.\"\"\"\n\n ",
          "methods": [
            {
              "name": "t_generate_valid_json(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test that output is valid JSON.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_structure(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test JSON structure.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_modules(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test module structure in JSON.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_functions(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test function structure in JSON.\"\"\"",
              "is_async": false
            },
            {
              "name": "t_generate_classes(se",
              "signature": "(f, s,ple_project):\n)",
              "intent": "Test class structure in JSON.\"\"\"",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "sample_project",
          "signature": "()",
          "intent": "a sample project for testing generators.",
          "is_async": false
        }
      ]
    },
    {
      "path": "tests/test_intent.py",
      "language": "python",
      "lines": 356,
      "imports": [
        "pytest"
      ],
      "exports": [
        "TestIntentAnalyzer"
      ],
      "classes": [
        {
          "name": "TestIntentAnalyzer",
          "bases": [],
          "docstring": "Test cases for IntentAnalyzer.",
          "methods": [
            {
              "name": "test_init",
              "signature": "(self)",
              "intent": "Test IntentAnalyzer initialization.",
              "is_async": false
            },
            {
              "name": "test_extract_keywords",
              "signature": "(self)",
              "intent": "Test keyword extraction from queries.",
              "is_async": false
            },
            {
              "name": "test_calculate_intent_confidence",
              "signature": "(self)",
              "intent": "Test intent confidence calculation.",
              "is_async": false
            },
            {
              "name": "test_identify_target_module",
              "signature": "(self,sample_project_model)",
              "intent": "Test target identification for modules.",
              "is_async": false
            },
            {
              "name": "test_identify_target_function",
              "signature": "(self,sample_project_model)",
              "intent": "Test target identification for functions.",
              "is_async": false
            },
            {
              "name": "test_identify_target_class",
              "signature": "(self,sample_project_model)",
              "intent": "Test target identification for classes.",
              "is_async": false
            },
            {
              "name": "test_identify_target_project",
              "signature": "(self,sample_project_model)",
              "intent": "Test target identification for project-level queries.",
              "is_async": false
            },
            {
              "name": "test_generate_description",
              "signature": "(self)",
              "intent": "Test description generation for intents.",
              "is_async": false
            },
            {
              "name": "test_generate_suggestions_refactor",
              "signature": "(self)",
              "intent": "Test suggestion generation for refactor intent.",
              "is_async": false
            },
            {
              "name": "test_generate_suggestions_analyze",
              "signature": "(self)",
              "intent": "Test suggestion generation for analyze intent.",
              "is_async": false
            },
            {
              "name": "test_generate_suggestions_optimize",
              "signature": "(self)",
              "intent": "Test suggestion generation for optimize intent.",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_refactor",
              "signature": "(self,sample_project_model)",
              "intent": "Test intent analysis for refactoring.",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_analyze",
              "signature": "(self,sample_project_model)",
              "intent": "Test intent analysis for analysis.",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_optimize",
              "signature": "(self,sample_project_model)",
              "intent": "Test intent analysis for optimization.",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_multiple",
              "signature": "(self,sample_project_model)",
              "intent": "Test intent analysis with multiple possible intents.",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_sorting",
              "signature": "(self,sample_project_model)",
              "intent": "Test that intents are sorted by confidence.",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_long_module",
              "signature": "(self)",
              "intent": "Test code smell detection for long modules.",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_complex_function",
              "signature": "(self)",
              "intent": "Test code smell detection for complex functions.",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_large_class",
              "signature": "(self)",
              "intent": "Test code smell detection for large classes.",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_too_many_imports",
              "signature": "(self)",
              "intent": "Test code smell detection for too many imports.",
              "is_async": false
            },
            {
              "name": "test_suggest_refactoring_module",
              "signature": "(self,sample_project_model)",
              "intent": "Test refactoring suggestions for modules.",
              "is_async": false
            },
            {
              "name": "test_suggest_refactoring_class",
              "signature": "(self,sample_project_model)",
              "intent": "Test refactoring suggestions for classes.",
              "is_async": false
            },
            {
              "name": "test_suggest_refactoring_function",
              "signature": "(self,sample_project_model)",
              "intent": "Test refactoring suggestions for functions.",
              "is_async": false
            },
            {
              "name": "test_find_target_object_module",
              "signature": "(self,sample_project_model)",
              "intent": "Test finding target object for module.",
              "is_async": false
            },
            {
              "name": "test_find_target_object_function",
              "signature": "(self,sample_project_model)",
              "intent": "Test finding target object for function.",
              "is_async": false
            },
            {
              "name": "test_find_target_object_class",
              "signature": "(self,sample_project_model)",
              "intent": "Test finding target object for class.",
              "is_async": false
            },
            {
              "name": "test_find_target_object_not_found",
              "signature": "(self,sample_project_model)",
              "intent": "Test finding non-existent target object.",
              "is_async": false
            },
            {
              "name": "test_suggest_module_refactoring",
              "signature": "(self)",
              "intent": "Test module-specific refactoring suggestions.",
              "is_async": false
            },
            {
              "name": "test_suggest_class_refactoring",
              "signature": "(self)",
              "intent": "Test class-specific refactoring suggestions.",
              "is_async": false
            },
            {
              "name": "test_suggest_function_refactoring",
              "signature": "(self)",
              "intent": "Test function-specific refactoring suggestions.",
              "is_async": false
            }
          ]
        }
      ]
    },
    {
      "path": "tests/test_analyzer.py",
      "language": "python",
      "lines": 193,
      "imports": [
        "pytest"
      ],
      "exports": [
        "TestProjectAnalyzer"
      ],
      "classes": [
        {
          "name": "TestProjectAnalyzer",
          "bases": [],
          "docstring": "Test cases for ProjectAnalyzer.",
          "methods": [
            {
              "name": "test_init",
              "signature": "(self,temp_project_dir)",
              "intent": "Test ProjectAnalyzer initialization.",
              "is_async": false
            },
            {
              "name": "test_init_with_config",
              "signature": "(self,temp_project_dir)",
              "intent": "Test ProjectAnalyzer initialization with config.",
              "is_async": false
            },
            {
              "name": "test_discover_source_files",
              "signature": "(self,sample_project)",
              "intent": "Test source file discovery.",
              "is_async": false
            },
            {
              "name": "test_discover_source_files_filters_non_source",
              "signature": "(self,temp_project_dir)",
              "intent": "Test that non-source files are filtered out.",
              "is_async": false
            },
            {
              "name": "test_discover_source_files_ignores_common_dirs",
              "signature": "(self,temp_project_dir)",
              "intent": "Test that common directories are ignored.",
              "is_async": false
            },
            {
              "name": "test_parse_file_tree_sitter_success",
              "signature": "(self,mock_fallback,mock_tree_sitter,sample_project)",
              "intent": "Test successful parsing with Tree-sitter.",
              "is_async": false
            },
            {
              "name": "test_parse_file_fallback_success",
              "signature": "(self,mock_fallback,mock_tree_sitter,sample_project)",
              "intent": "Test fallback parsing when Tree-sitter fails.",
              "is_async": false
            },
            {
              "name": "test_parse_file_both_fail",
              "signature": "(self,mock_fallback,mock_tree_sitter,sample_project)",
              "intent": "Test when both parsers fail.",
              "is_async": false
            },
            {
              "name": "test_extract_metadata",
              "signature": "(self,sample_project)",
              "intent": "Test metadata extraction.",
              "is_async": false
            },
            {
              "name": "test_analyze_complete",
              "signature": "(self,mock_similarity,mock_dependency,sample_project)",
              "intent": "Test complete analysis process.",
              "is_async": false
            },
            {
              "name": "test_analyze_without_files",
              "signature": "(self,temp_project_dir)",
              "intent": "Test analysis with no source files.",
              "is_async": false
            },
            {
              "name": "test_generate_output",
              "signature": "(self,mock_generator_class,sample_project_model)",
              "intent": "Test output generation.",
              "is_async": false
            },
            {
              "name": "test_generate_output_without_analysis",
              "signature": "(self,sample_project_model)",
              "intent": "Test output generation without prior analysis.",
              "is_async": false
            },
            {
              "name": "test_read_project_file_error",
              "signature": "(self,temp_project_dir)",
              "intent": "Test error handling in _read_project_file.",
              "is_async": false
            },
            {
              "name": "test_analysis_with_config",
              "signature": "(self,sample_project)",
              "intent": "Test analysis with custom configuration.",
              "is_async": false
            }
          ]
        }
      ]
    }
  ]
}