# llm_profiler.py | python | 23 functions
functions:
  _get_profiles_path:
    kind: function
    sig: () -> Path
    loc: 171-175
    does: "Get path to profiles storage."
  load_profiles:
    kind: function
    sig: () -> Dict[str,LLMProfile]
    loc: 178-191
    does: "Load all saved profiles."
  save_profile:
    kind: function
    sig: (profile:LLMProfile) -> None
    loc: 194-204
    does: "Save a profile to storage."
  get_profile:
    kind: function
    sig: (provider:str, model:str) -> Optional[LLMProfile]
    loc: 207-211
    does: "Get profile for a specific model."
  get_or_create_profile:
    kind: function
    sig: (provider:str, model:str) -> LLMProfile
    loc: 214-221
    does: "Get existing profile or create default one."
  _create_default_profile:
    kind: function
    sig: (provider:str, model:str) -> LLMProfile
    loc: 224-270
    does: "Create default profile based on model characteristics."
  profile_llm:
    kind: function
    sig: (client, quick:bool=False) -> LLMProfile
    loc: 641-644
    does: "Profile an LLM client."
  get_adaptive_chunker:
    kind: function
    sig: (provider:str, model:str) -> AdaptiveChunker
    loc: 647-650
    does: "Get adaptive chunker for a model."
  LLMProfile.__post_init__:
    kind: method
    sig: () -> None
    loc: 148-154
    does: "creates init"
  LLMProfiler.__init__:
    kind: method
    sig: (client, verbose:bool=True) -> None
    loc: 283-294
    does: "Initialize profiler."
  LLMProfiler.run_profile:
    kind: method
    sig: (quick:bool=False) -> LLMProfile
    loc: 296-348
    does: "Run full profiling suite."
  LLMProfiler._test_reproduction:
    kind: method
    sig: (name:str, code:str) -> ProfileTestResult
    loc: 350-397
    does: "Test reproduction of a code snippet."
  LLMProfiler._code_to_spec:
    kind: method
    sig: (code:str) -> str
    loc: 399-427
    does: "Convert code to simple YAML spec."
  LLMProfiler._extract_code:
    kind: method
    sig: (response:str) -> str
    loc: 429-444
    does: "Extract code from LLM response."
  LLMProfiler._check_syntax:
    kind: method
    sig: (code:str) -> bool
    loc: 446-452
    does: "Check if code has valid Python syntax."
  LLMProfiler._calculate_similarity:
    kind: method
    sig: (original:str, reproduced:str) -> float
    loc: 454-460
    does: "Calculate code similarity."
  LLMProfiler._calculate_metrics:
    kind: method
    sig: (profile:LLMProfile, results:List[ProfileTestResult]) -> LLMProfile
    loc: 462-499
    does: "Calculate aggregate metrics from test results."
  LLMProfiler._test_consistency:
    kind: method
    sig: (profile:LLMProfile) -> LLMProfile
    loc: 501-516
    does: "Test output consistency by running same prompt twice."
  AdaptiveChunker.__init__:
    kind: method
    sig: (profile:Optional[LLMProfile]=None) -> None
    loc: 527-537
    does: "Initialize chunker."
  AdaptiveChunker.get_optimal_settings:
    kind: method
    sig: () -> Dict[str,Any]
    loc: 539-546
    does: "Get optimal settings for the profiled model."
  AdaptiveChunker.chunk_spec:
    kind: method
    sig: (spec:str, format:str='yaml') -> List[Dict[str,Any]]
    loc: 548-606
    does: "Chunk specification based on profile."
  AdaptiveChunker.recommend_format:
    kind: method
    sig: (spec_size_tokens:int) -> str
    loc: 608-631
    does: "Recommend best format based on spec size and model."
  AdaptiveChunker.estimate_chunks_needed:
    kind: method
    sig: (spec_size_tokens:int) -> int
    loc: 633-637
    does: "Estimate number of chunks needed."

# config.py | python | 15 functions
functions:
  load_env:
    kind: function
    sig: () -> None
    loc: 184-189
    does: "Load environment variables from .env file."
  get_api_key:
    kind: function
    sig: (provider:str) -> Optional[str]
    loc: 192-194
    does: "Convenience function to get API key."
  get_model:
    kind: function
    sig: (provider:str) -> str
    loc: 197-199
    does: "Convenience function to get model."
  Config.__init__:
    kind: method
    sig: (env_file:str=None) -> None
    loc: 56-64
    does: "Initialize configuration."
  Config._load_env_file:
    kind: method
    sig: (env_file:str=None) -> None
    loc: 66-79
    does: "Load environment variables from .env file."
  Config._parse_env_file:
    kind: method
    sig: (path:Path) -> None
    loc: 81-94
    does: "Parse .env file and set environment variables."
  Config._load_config_file:
    kind: method
    sig: () -> None
    loc: 96-104
    does: "Load configuration from JSON file."
  Config.get_api_key:
    kind: method
    sig: (provider:str) -> Optional[str]
    loc: 106-118
    does: "Get API key for a provider."
  Config.get_model:
    kind: method
    sig: (provider:str) -> str
    loc: 120-142
    does: "Get model for a provider."
  Config.get_ollama_host:
    kind: method
    sig: () -> str
    loc: 144-146
    does: "Get Ollama host URL."
  Config.get_default_provider:
    kind: method
    sig: () -> str
    loc: 148-150
    does: "Get default LLM provider."
  Config.is_verbose:
    kind: method
    sig: () -> bool
    loc: 152-154
    does: "Check if verbose mode is enabled."
  Config.get_cache_dir:
    kind: method
    sig: () -> Path
    loc: 156-159
    does: "Get cache directory path."
  Config.list_configured_providers:
    kind: method
    sig: () -> Dict[str,bool]
    loc: 161-170
    does: "List all providers and their configuration status."
  Config.to_dict:
    kind: method
    sig: () -> Dict[str,Any]
    loc: 172-181
    does: "Export configuration as dictionary."

# file_formats.py | python | 4 functions
functions:
  generate_file_csv:
    kind: function
    sig: (file_path:Path) -> str
    loc: 14-67
    does: "Generate detailed CSV specification for a single file."
  generate_file_json:
    kind: function
    sig: (file_path:Path) -> str
    loc: 70-137
    does: "Generate detailed JSON specification for a single file."
  generate_file_yaml:
    kind: function
    sig: (file_path:Path) -> str
    loc: 140-216
    does: "Generate detailed YAML specification for a single file."
  _parse_file_elements:
    kind: function
    sig: (content:str) -> Dict[str, Any]
    loc: 219-352
    does: "Parse file content to extract code elements."

# project_reproducer.py | python | 8 functions
functions:
  reproduce_project:
    kind: function
    sig: (project_path:str, output_dir:str=None, target_lang:str=None, parallel:bool=False, use_llm:bool=True) -> ProjectResult
    loc: 382-401
    does: "Convenience function for project reproduction."
  ProjectReproducer.__init__:
    kind: method
    sig: (client:BaseLLMClient=None, max_workers:int=4, target_lang:str=None, use_llm:bool=True) -> None
    loc: 92-111
    does: "Initialize project reproducer."
  ProjectReproducer._get_client:
    kind: method
    sig: () -> BaseLLMClient
    loc: 113-119
    does: "Get or create LLM client."
  ProjectReproducer.find_source_files:
    kind: method
    sig: (project_path:str, extensions:Set[str]=None, exclude_patterns:List[str]=None) -> List[Path]
    loc: 121-160
    does: "Find all source files in project."
  ProjectReproducer.reproduce_file:
    kind: method
    sig: (file_path:Path, output_dir:Path) -> FileResult
    loc: 162-212
    does: "Reproduce a single file."
  ProjectReproducer.reproduce_project:
    kind: method
    sig: (project_path:str, output_dir:str=None, parallel:bool=False) -> ProjectResult
    loc: 214-274
    does: "Reproduce entire project."
  ProjectReproducer._aggregate_results:
    kind: method
    sig: (project_path:str, results:List[FileResult]) -> ProjectResult
    loc: 276-333
    does: "Aggregate file results into project result."
  ProjectReproducer._save_report:
    kind: method
    sig: (output_dir:Path, result:ProjectResult) -> None
    loc: 335-379
    does: "Save project reproduction report."

# base.py | python | 11 functions
functions:
  VerboseMixin.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 17-21
    does: "creates"
  VerboseMixin.log:
    kind: method
    sig: (msg:str, level:str='info') -> None
    loc: 23-27
    does: "Log message if verbose mode enabled."
  VerboseMixin.debug:
    kind: method
    sig: (msg:str) -> None
    loc: 29-31
    does: "Log debug message."
  VerboseMixin.info:
    kind: method
    sig: (msg:str) -> None
    loc: 33-35
    does: "Log info message."
  VerboseMixin.warn:
    kind: method
    sig: (msg:str) -> None
    loc: 37-39
    does: "Log warning message."
  VerboseMixin.error:
    kind: method
    sig: (msg:str) -> None
    loc: 41-43
    does: "Log error message."
  BaseParser.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 49-50
    does: "creates"
  BaseParser.parse:
    kind: method
    sig: (content:str, language:str=None) -> None
    loc: 52-54
    does: "Parse source code content."
  BaseParser.parse_file:
    kind: method
    sig: (path:str) -> None
    loc: 56-58
    does: "Parse source file."
  BaseGenerator.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 64-65
    does: "creates"
  BaseGenerator.generate:
    kind: method
    sig: (project, detail:str='full') -> str
    loc: 67-69
    does: "Generate output from project analysis."

# cli.py | python | 27 functions
functions:
  ensure_dependencies:
    kind: function
    sig: () -> None
    loc: 99-135
    does: "Auto-install optional dependencies for best results."
  _get_env_file_path:
    kind: function
    sig: () -> str
    loc: 138-139
    does: "retrieves env file path"
  _read_text_file:
    kind: function
    sig: (path:str) -> str
    loc: 142-147
    does: "retrieves text file"
  _write_text_file:
    kind: function
    sig: (path:str, content:str) -> None
    loc: 150-152
    does: "logs text file"
  _set_env_var:
    kind: function
    sig: (var_name:str, value:str) -> str
    loc: 155-180
    does: "updates env var"
  _unset_env_var:
    kind: function
    sig: (var_name:str) -> str
    loc: 183-192
    does: "unset env var"
  _get_litellm_config_path:
    kind: function
    sig: () -> str
    loc: 195-196
    does: "retrieves litellm config path"
  _get_user_llm_config_path:
    kind: function
    sig: () -> str
    loc: 199-200
    does: "retrieves user llm config path"
  _load_user_llm_config:
    kind: function
    sig: () -> dict
    loc: 203-211
    does: "retrieves user llm config"
  _save_user_llm_config:
    kind: function
    sig: (data:dict) -> str
    loc: 214-219
    does: "caches user llm config"
  _load_litellm_yaml:
    kind: function
    sig: () -> dict
    loc: 222-238
    does: "retrieves litellm yaml"
  _save_litellm_yaml:
    kind: function
    sig: (data:dict) -> str
    loc: 241-250
    does: "caches litellm yaml"
  _infer_provider_from_litellm_model:
    kind: function
    sig: (litellm_model:str) -> str
    loc: 253-258
    does: "infer provider from litellm model"
  _code2logic_llm_cli:
    kind: function
    sig: (argv:list[str]) -> None
    loc: 261-506
    does: "code2logic llm cli"
  main:
    kind: function
    sig: () -> None
    loc: 509-975
    does: "Main CLI entry point."
  Logger.__init__:
    kind: method
    sig: (verbose:bool=False, debug:bool=False) -> None
    loc: 39-43
    does: "creates"
  Logger._elapsed:
    kind: method
    sig: () -> str
    loc: 45-48
    does: "Get elapsed time string."
  Logger.info:
    kind: method
    sig: (msg:str) -> None
    loc: 50-52
    does: "Print info message."
  Logger.success:
    kind: method
    sig: (msg:str) -> None
    loc: 54-56
    does: "Print success message."
  Logger.warning:
    kind: method
    sig: (msg:str) -> None
    loc: 58-60
    does: "Print warning message."
  Logger.error:
    kind: method
    sig: (msg:str) -> None
    loc: 62-64
    does: "Print error message."
  Logger.step:
    kind: method
    sig: (msg:str) -> None
    loc: 66-70
    does: "Print step message with counter."
  Logger.detail:
    kind: method
    sig: (msg:str) -> None
    loc: 72-75
    does: "Print detail message (only in verbose mode)."
  Logger.debug_msg:
    kind: method
    sig: (msg:str) -> None
    loc: 77-80
    does: "Print debug message (only in debug mode)."
  Logger.stats:
    kind: method
    sig: (label:str, value) -> None
    loc: 82-85
    does: "Print statistics."
  Logger.separator:
    kind: method
    sig: () -> None
    loc: 87-90
    does: "Print separator line."
  Logger.header:
    kind: method
    sig: (msg:str) -> None
    loc: 92-96
    does: "Print header."

# llm.py | python | 17 functions
functions:
  get_available_backends:
    kind: function
    sig: () -> Dict[str, bool]
    loc: 463-478
    does: "Get availability status of LLM backends."
  OllamaClient.__init__:
    kind: method
    sig: (config:LLMConfig) -> None
    loc: 60-64
    does: "creates"
  OllamaClient.generate:
    kind: method
    sig: (prompt:str, system:Optional[str]=None) -> str
    loc: 66-86
    does: "Generate completion from Ollama."
  OllamaClient.chat:
    kind: method
    sig: (messages:List[Dict[str,str]]) -> str
    loc: 88-105
    does: "Chat completion from Ollama."
  OllamaClient.is_available:
    kind: method
    sig: () -> bool
    loc: 107-113
    does: "Check if Ollama is running."
  OllamaClient.list_models:
    kind: method
    sig: () -> List[str]
    loc: 115-122
    does: "List available models."
  LiteLLMClient.__init__:
    kind: method
    sig: (config:LLMConfig) -> None
    loc: 128-131
    does: "creates"
  LiteLLMClient.generate:
    kind: method
    sig: (prompt:str, system:Optional[str]=None) -> str
    loc: 133-140
    does: "Generate completion via LiteLLM."
  LiteLLMClient.chat:
    kind: method
    sig: (messages:List[Dict[str,str]]) -> str
    loc: 142-155
    does: "Chat completion via LiteLLM."
  LiteLLMClient.is_available:
    kind: method
    sig: () -> bool
    loc: 157-163
    does: "Check if LiteLLM backend is available."
  CodeAnalyzer.__init__:
    kind: method
    sig: (model:str=None, provider:str=None, base_url:str=None, api_key:str=None) -> None
    loc: 193-237
    does: "Initialize CodeAnalyzer."
  CodeAnalyzer.is_available:
    kind: method
    sig: () -> bool
    loc: 239-241
    does: "Check if LLM backend is available."
  CodeAnalyzer.suggest_refactoring:
    kind: method
    sig: (project) -> List[Dict[str, Any]]
    loc: 243-292
    does: "Analyze project and suggest refactoring improvements."
  CodeAnalyzer.find_semantic_duplicates:
    kind: method
    sig: (project) -> List[Dict[str, Any]]
    loc: 294-352
    does: "Find semantically similar functions using LLM."
  CodeAnalyzer.generate_code:
    kind: method
    sig: (project, target_lang:str, module_filter:Optional[str]=None) -> Dict[str, str]
    loc: 354-416
    does: "Generate code in target language from project analysis."
  CodeAnalyzer.translate_function:
    kind: method
    sig: (name:str, signature:str, intent:str, source_lang:str, target_lang:str) -> str
    loc: 418-452
    does: "Translate a single function to another language."
  CodeAnalyzer._build_signature:
    kind: method
    sig: (f) -> str
    loc: 454-460
    does: "Build compact signature."

# errors.py | python | 13 functions
functions:
  create_error_handler:
    kind: function
    sig: (mode:str='lenient', max_file_size_mb:float=10.0) -> ErrorHandler
    loc: 432-437
    does: "Create an error handler with default settings."
  AnalysisError.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 61-69
    does: "converts dict"
  AnalysisResult.add_error:
    kind: method
    sig: (error:AnalysisError) -> None
    loc: 82-89
    does: "Add an error to the result."
  AnalysisResult.has_errors:
    kind: method
    sig: () -> bool
    loc: 91-92
    does: "has errors"
  AnalysisResult.summary:
    kind: method
    sig: () -> str
    loc: 94-102
    does: "Generate error summary."
  ErrorHandler.__init__:
    kind: method
    sig: (mode:str='lenient', max_file_size_mb:float=10.0, timeout_seconds:float=30.0, logger:Optional[Any]=None) -> None
    loc: 137-148
    does: "creates"
  ErrorHandler.reset:
    kind: method
    sig: () -> None
    loc: 150-152
    does: "Reset error state for new analysis."
  ErrorHandler.handle_error:
    kind: method
    sig: (error_type:ErrorType, path:str, message:str, exception:Optional[Exception]=None, severity:Optional[ErrorSeverity]=None) -> bool
    loc: 154-188
    does: "Handle an error."
  ErrorHandler._default_severity:
    kind: method
    sig: (error_type:ErrorType) -> ErrorSeverity
    loc: 190-206
    does: "Get default severity for error type."
  ErrorHandler._log_error:
    kind: method
    sig: (error:AnalysisError) -> None
    loc: 208-216
    does: "Log an error."
  ErrorHandler.safe_read_file:
    kind: method
    sig: (path:Path) -> Optional[str]
    loc: 218-329
    does: "Safely read a file with error handling."
  ErrorHandler.safe_write_file:
    kind: method
    sig: (path:Path, content:str) -> bool
    loc: 331-376
    does: "Safely write a file with error handling."
  ErrorHandler.safe_parse:
    kind: method
    sig: (path:str, content:str, parser_func:Callable) -> Any
    loc: 378-429
    does: "Safely parse content with error handling."

# code_review.py | python | 6 functions
functions:
  analyze_code_quality:
    kind: function
    sig: (project) -> Dict[str,List[Dict]]
    loc: 40-100
    does: "Analyze code quality issues."
  check_security_issues:
    kind: function
    sig: (project) -> Dict[str,List[Dict]]
    loc: 103-139
    does: "Check for security vulnerabilities."
  check_performance_issues:
    kind: function
    sig: (project) -> Dict[str,List[Dict]]
    loc: 142-166
    does: "Check for performance anti-patterns."
  CodeReviewer.__init__:
    kind: method
    sig: (client=None) -> None
    loc: 172-178
    does: "Initialize reviewer."
  CodeReviewer.review:
    kind: method
    sig: (project, focus:str='all') -> Dict[str,Any]
    loc: 180-221
    does: "Perform code review."
  CodeReviewer.generate_report:
    kind: method
    sig: (results:Dict[str,Any], project_name:str='Project') -> str
    loc: 223-272
    does: "Generate markdown review report."

# analyzer.py | python | 8 functions
functions:
  analyze_project:
    kind: function
    sig: (path:str, use_treesitter:bool=True, verbose:bool=False) -> ProjectInfo
    loc: 262-284
    does: "Convenience function to analyze a project."
  get_library_status:
    kind: function
    sig: () -> Dict[str, bool]
    loc: 287-300
    does: "Get availability status of optional libraries."
  ProjectAnalyzer.__init__:
    kind: method
    sig: (root_path:str, use_treesitter:bool=True, verbose:bool=False, include_private:bool=False) -> None
    loc: 83-118
    does: "Initialize the project analyzer."
  ProjectAnalyzer._print_status:
    kind: method
    sig: () -> None
    loc: 120-127
    does: "Print library availability status."
  ProjectAnalyzer.analyze:
    kind: method
    sig: () -> ProjectInfo
    loc: 129-162
    does: "Analyze the project."
  ProjectAnalyzer._scan_files:
    kind: method
    sig: () -> None
    loc: 164-216
    does: "Scan and parse all source files."
  ProjectAnalyzer._detect_entrypoints:
    kind: method
    sig: () -> List[str]
    loc: 218-243
    does: "Detect project entry points."
  ProjectAnalyzer.get_statistics:
    kind: method
    sig: () -> Dict
    loc: 245-259
    does: "Get analysis statistics."

# quality.py | python | 10 functions
functions:
  analyze_quality:
    kind: function
    sig: (project:ProjectInfo, thresholds:Dict[str,int]=None) -> QualityReport
    loc: 212-224
    does: "Convenience function to analyze project quality."
  get_quality_summary:
    kind: function
    sig: (report:QualityReport) -> str
    loc: 227-264
    does: "Generate human-readable quality summary."
  QualityReport.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 31-49
    does: "Convert to dictionary."
  QualityAnalyzer.__init__:
    kind: method
    sig: (thresholds:Dict[str,int]=None) -> None
    loc: 71-75
    does: "Initialize with custom thresholds."
  QualityAnalyzer.analyze:
    kind: method
    sig: (project:ProjectInfo) -> QualityReport
    loc: 77-108
    does: "Analyze project quality."
  QualityAnalyzer.analyze_modules:
    kind: method
    sig: (modules:List[ModuleInfo]) -> QualityReport
    loc: 110-129
    does: "Analyze a list of modules."
  QualityAnalyzer._analyze_module:
    kind: method
    sig: (module:ModuleInfo, report:QualityReport) -> None
    loc: 131-152
    does: "Analyze a single module."
  QualityAnalyzer._check_function:
    kind: method
    sig: (func, file_path:str, report:QualityReport) -> None
    loc: 154-179
    does: "Check function quality."
  QualityAnalyzer._check_class:
    kind: method
    sig: (file_path:str, report:QualityReport) -> None
    loc: 181-197
    does: "Check class quality."
  QualityAnalyzer._get_file_recommendation:
    kind: method
    sig: (module:ModuleInfo) -> str
    loc: 199-209
    does: "Generate recommendation for long file."

# shared_utils.py | python | 12 functions
functions:
  compact_imports:
    kind: function
    sig: (imports:List[str], max_items:int=10) -> List[str]
    loc: 24-66
    does: "Compact imports by grouping submodules."
  deduplicate_imports:
    kind: function
    sig: (imports:List[str]) -> List[str]
    loc: 69-99
    does: "Remove redundant imports."
  abbreviate_type:
    kind: function
    sig: (type_str:str) -> str
    loc: 128-152
    does: "Abbreviate type annotations for compactness."
  expand_type:
    kind: function
    sig: (abbrev:str) -> str
    loc: 155-173
    does: "Expand abbreviated type back to full form."
  build_signature:
    kind: function
    sig: (params:List[str], return_type:Optional[str]=None, include_self:bool=False, abbreviate:bool=False, max_params:int=6) -> str
    loc: 180-232
    does: "Build compact function signature."
  remove_self_from_params:
    kind: function
    sig: (params:List[str]) -> List[str]
    loc: 235-247
    does: "Remove 'self' and 'cls' from parameter list."
  categorize_function:
    kind: function
    sig: (name:str) -> str
    loc: 268-285
    does: "Categorize function by name pattern."
  extract_domain:
    kind: function
    sig: (path:str) -> str
    loc: 297-315
    does: "Extract domain from file path."
  compute_hash:
    kind: function
    sig: (name:str, signature:str, length:int=8) -> str
    loc: 322-335
    does: "Compute short hash for quick comparison."
  truncate_docstring:
    kind: function
    sig: (docstring:Optional[str], max_length:int=60) -> str
    loc: 342-376
    does: "Truncate docstring to first sentence or max_length."
  escape_for_yaml:
    kind: function
    sig: (text:str) -> str
    loc: 379-399
    does: "Escape text for safe YAML inclusion."
  clean_identifier:
    kind: function
    sig: (name:str) -> str
    loc: 402-414
    does: "Clean identifier by removing whitespace and special characters."

# parsers.py | python | 70 functions
functions:
  _normalize_import_path:
    kind: function
    sig: (import_path:str) -> str
    loc: 28-35
    does: "Normalize import path by removing duplicate suffix segments."
  _clean_imports:
    kind: function
    sig: (imports:List[str]) -> List[str]
    loc: 38-49
    does: "Deduplicate and normalize import paths while preserving order."
  _combine_import_name:
    kind: function
    sig: (module_name:str, identifier:str) -> str
    loc: 52-59
    does: "Combine module and identifier while avoiding duplicate suffixes."
  _truncate_constant_value:
    kind: function
    sig: (value_text:str, limit:int=400) -> str
    loc: 62-69
    does: "Return a trimmed single-line snippet for constant values."
  _py_expr_to_dotted_name:
    kind: function
    sig: (expr) -> str
    loc: 72-84
    does: "py expr to dotted name"
  _analyze_python_function_node:
    kind: function
    sig: (func_node) -> None
    loc: 204-208
    does: "processes python function node"
  is_tree_sitter_available:
    kind: function
    sig: () -> bool
    loc: 1836-1838
    does: "Check if Tree-sitter is available."
  _PyFunctionBodyAnalyzer.__init__:
    kind: method
    sig: () -> None
    loc: 88-93
    does: "creates"
  _PyFunctionBodyAnalyzer._add_call:
    kind: method
    sig: (name:str) -> None
    loc: 95-103
    does: "creates call"
  _PyFunctionBodyAnalyzer._add_raise:
    kind: method
    sig: (name:str) -> None
    loc: 105-113
    does: "creates raise"
  _PyFunctionBodyAnalyzer.visit_Call:
    kind: method
    sig: (node) -> None
    loc: 115-122
    does: "visit call"
  _PyFunctionBodyAnalyzer.visit_Raise:
    kind: method
    sig: (node) -> None
    loc: 124-139
    does: "visit raise"
  _PyFunctionBodyAnalyzer.visit_If:
    kind: method
    sig: (node) -> None
    loc: 141-143
    does: "visit if"
  _PyFunctionBodyAnalyzer.visit_For:
    kind: method
    sig: (node) -> None
    loc: 145-147
    does: "visit for"
  _PyFunctionBodyAnalyzer.visit_AsyncFor:
    kind: method
    sig: (node) -> None
    loc: 149-151
    does: "visit asyncfor"
  _PyFunctionBodyAnalyzer.visit_While:
    kind: method
    sig: (node) -> None
    loc: 153-155
    does: "visit while"
  _PyFunctionBodyAnalyzer.visit_IfExp:
    kind: method
    sig: (node) -> None
    loc: 157-159
    does: "visit ifexp"
  _PyFunctionBodyAnalyzer.visit_BoolOp:
    kind: method
    sig: (node) -> None
    loc: 161-167
    does: "visit boolop"
  _PyFunctionBodyAnalyzer.visit_Try:
    kind: method
    sig: (node) -> None
    loc: 169-174
    does: "visit try"
  _PyFunctionBodyAnalyzer.visit_comprehension:
    kind: method
    sig: (node) -> None
    loc: 176-182
    does: "visit comprehension"
  _PyFunctionBodyAnalyzer.visit_Match:
    kind: method
    sig: (node) -> None
    loc: 184-189
    does: "visit match"
  _PyFunctionBodyAnalyzer.visit_FunctionDef:
    kind: method
    sig: (node) -> None
    loc: 191-192
    does: "visit functiondef"
  _PyFunctionBodyAnalyzer.visit_AsyncFunctionDef:
    kind: method
    sig: (node) -> None
    loc: 194-195
    does: "visit asyncfunctiondef"
  _PyFunctionBodyAnalyzer.visit_ClassDef:
    kind: method
    sig: (node) -> None
    loc: 197-198
    does: "visit classdef"
  _PyFunctionBodyAnalyzer.visit_Lambda:
    kind: method
    sig: (node) -> None
    loc: 200-201
    does: "visit lambda"
  TreeSitterParser.__init__:
    kind: method
    sig: () -> None
    loc: 224-231
    does: "Initialize Tree-sitter parsers for available languages."
  TreeSitterParser._init_parsers:
    kind: method
    sig: () -> None
    loc: 233-255
    does: "Initialize parsers for each supported language."
  TreeSitterParser.is_available:
    kind: method
    sig: (language:str) -> bool
    loc: 257-259
    does: "Check if Tree-sitter parser is available for a language."
  TreeSitterParser.get_supported_languages:
    kind: method
    sig: () -> List[str]
    loc: 262-264
    does: "Get list of potentially supported languages."
  TreeSitterParser.parse:
    kind: method
    sig: (filepath:str, content:str, language:str) -> Optional[ModuleInfo]
    loc: 266-289
    does: "Parse a source file using Tree-sitter."
  TreeSitterParser._parse_python:
    kind: method
    sig: (filepath:str, content:str, tree) -> ModuleInfo
    loc: 291-404
    does: "Parse Python source using Tree-sitter AST."
  TreeSitterParser._extract_constants:
    kind: method
    sig: (tree, content:str) -> List[ConstantInfo]
    loc: 406-435
    does: "Extract module-level UPPERCASE constants."
  TreeSitterParser._extract_type_checking_imports:
    kind: method
    sig: (tree, content:str) -> List[str]
    loc: 437-460
    does: "Extract TYPE_CHECKING block imports."
  TreeSitterParser._extract_conditional_imports:
    kind: method
    sig: (node, content:str) -> List[str]
    loc: 462-475
    does: "Extract imports from try/except blocks."
  TreeSitterParser._extract_aliases:
    kind: method
    sig: (tree, content:str) -> dict
    loc: 477-522
    does: "Extract module aliases (import X as Y)."
  TreeSitterParser._extract_py_function:
    kind: method
    sig: (node, content:str, decorated_node=None) -> Optional[FunctionInfo]
    loc: 524-625
    does: "Extract Python function from AST node."
  TreeSitterParser._extract_py_enum:
    kind: method
    sig: (node, content:str) -> Optional[TypeInfo]
    loc: 627-667
    does: "Extract Python Enum (values) as TypeInfo(kind='enum')."
  TreeSitterParser._extract_py_class:
    kind: method
    sig: (node, content:str, decorated_node=None) -> Optional[ClassInfo]
    loc: 669-752
    does: "Extract Python class from AST node."
  TreeSitterParser._extract_dataclass_field:
    kind: method
    sig: (node, content:str) -> Optional[FieldInfo]
    loc: 754-816
    does: "Extract dataclass field from assignment."
  TreeSitterParser._extract_class_attribute:
    kind: method
    sig: (node, content:str) -> Optional[AttributeInfo]
    loc: 818-846
    does: "Extract class attribute from self.x = ..."
  TreeSitterParser._extract_init_attributes:
    kind: method
    sig: (func_node, content:str) -> List[AttributeInfo]
    loc: 848-871
    does: "Extract self.x = ..."
  TreeSitterParser._extract_class_property:
    kind: method
    sig: (node, content:str) -> Optional[str]
    loc: 873-886
    does: "Extract class-level property from annotated assignment."
  TreeSitterParser._extract_py_import:
    kind: method
    sig: (node, content:str) -> List[str]
    loc: 888-898
    does: "Extract import statement."
  TreeSitterParser._extract_py_from_import:
    kind: method
    sig: (node, content:str) -> List[str]
    loc: 900-938
    does: "Extract from ..."
  TreeSitterParser._extract_py_constant:
    kind: method
    sig: (node, content:str) -> Optional[ConstantInfo]
    loc: 940-998
    does: "Extract constant (UPPERCASE assignment) with value."
  TreeSitterParser._extract_conditional_imports:
    kind: method
    sig: (node, content:str) -> List[str]
    loc: 1000-1013
    does: "Extract imports from try/except blocks."
  TreeSitterParser._parse_js_ts:
    kind: method
    sig: (filepath:str, content:str, tree, language:str) -> ModuleInfo
    loc: 1015-1100
    does: "Parse JavaScript/TypeScript source using Tree-sitter AST."
  TreeSitterParser._extract_js_class:
    kind: method
    sig: (node, content:str) -> Optional[ClassInfo]
    loc: 1102-1136
    does: "Extract JS/TS class from AST node."
  TreeSitterParser._extract_js_method:
    kind: method
    sig: (node, content:str) -> Optional[FunctionInfo]
    loc: 1138-1177
    does: "Extract JS/TS method from AST node."
  TreeSitterParser._extract_js_function:
    kind: method
    sig: (node, content:str) -> Optional[FunctionInfo]
    loc: 1179-1213
    does: "Extract JS/TS function from AST node."
  TreeSitterParser._extract_js_arrow_fn:
    kind: method
    sig: (node, content:str) -> Optional[FunctionInfo]
    loc: 1215-1245
    does: "Extract arrow function assigned to const."
  TreeSitterParser._extract_js_params:
    kind: method
    sig: (params_node, content:str) -> List[str]
    loc: 1247-1265
    does: "Extract JS/TS function parameters."
  TreeSitterParser._extract_ts_type:
    kind: method
    sig: (node, content:str) -> Optional[TypeInfo]
    loc: 1267-1274
    does: "Extract TypeScript interface or type alias."
  TreeSitterParser._extract_ts_enum:
    kind: method
    sig: (node, content:str) -> Optional[TypeInfo]
    loc: 1276-1297
    does: "Extract TypeScript enum."
  TreeSitterParser._extract_js_constant:
    kind: method
    sig: (node, content:str) -> Optional[str]
    loc: 1299-1308
    does: "Extract constant (UPPERCASE const)."
  TreeSitterParser._extract_js_comment:
    kind: method
    sig: (node, content:str) -> Optional[str]
    loc: 1310-1320
    does: "Extract JS comment content."
  TreeSitterParser._find_child:
    kind: method
    sig: (node, type_name:str) -> None
    loc: 1323-1328
    does: "Find first child of given type."
  TreeSitterParser._text:
    kind: method
    sig: (node, content:str) -> str
    loc: 1330-1336
    does: "Get text content of node."
  TreeSitterParser._extract_string:
    kind: method
    sig: (node, content:str) -> str
    loc: 1338-1345
    does: "Extract string content without quotes."
  TreeSitterParser._truncate_docstring:
    kind: method
    sig: (docstring:Optional[str], max_len:int=80) -> Optional[str]
    loc: 1347-1369
    does: "Truncate docstring to first sentence or max_len characters."
  UniversalParser.__init__:
    kind: method
    sig: () -> None
    loc: 1385-1387
    does: "Initialize the universal parser."
  UniversalParser.parse:
    kind: method
    sig: (filepath:str, content:str, language:str) -> Optional[ModuleInfo]
    loc: 1389-1409
    does: "Parse a source file using AST or regex."
  UniversalParser._parse_python:
    kind: method
    sig: (filepath:str, content:str) -> Optional[ModuleInfo]
    loc: 1411-1483
    does: "Parse Python using built-in AST."
  UniversalParser._extract_ast_enum:
    kind: method
    sig: (node:Any) -> Optional[TypeInfo]
    loc: 1485-1529
    does: "Extract Enum values from Python AST class."
  UniversalParser._extract_ast_function:
    kind: method
    sig: (node) -> FunctionInfo
    loc: 1531-1600
    does: "Extract function from Python AST node."
  UniversalParser._extract_ast_class:
    kind: method
    sig: (node:Any) -> ClassInfo
    loc: 1602-1660
    does: "Extract class from Python AST node."
  UniversalParser._extract_ast_constant:
    kind: method
    sig: (node:Any, content:str) -> Optional[ConstantInfo]
    loc: 1662-1702
    does: "Extract ConstantInfo from an AST assignment node if applicable."
  UniversalParser._format_ast_value:
    kind: method
    sig: (value_node:Any, content:str) -> str
    loc: 1704-1722
    does: "Best-effort string representation of an AST value node."
  UniversalParser._ann_str:
    kind: method
    sig: (node) -> str
    loc: 1724-1737
    does: "Convert AST annotation to string."
  UniversalParser._parse_js_ts:
    kind: method
    sig: (filepath:str, content:str, language:str) -> ModuleInfo
    loc: 1739-1833
    does: "Parse JS/TS using regex patterns."

# intent.py | python | 18 functions
functions:
  EnhancedIntentGenerator.__init__:
    kind: method
    sig: (lang:str='en') -> None
    loc: 131-163
    does: "Initialize the intent generator."
  EnhancedIntentGenerator.generate:
    kind: method
    sig: (name:str, docstring:Optional[str]=None) -> str
    loc: 165-210
    does: "Generate intent from function name and optional docstring."
  EnhancedIntentGenerator._extract_from_docstring:
    kind: method
    sig: (docstring:str) -> Optional[str]
    loc: 212-230
    does: "Extract intent from docstring's first line."
  EnhancedIntentGenerator._split_name:
    kind: method
    sig: (name:str) -> List[str]
    loc: 232-258
    does: "Split function name into words."
  EnhancedIntentGenerator.get_available_features:
    kind: method
    sig: () -> dict[str, bool]
    loc: 261-271
    does: "Get dictionary of available NLP features."
  IntentAnalyzer.__init__:
    kind: method
    sig: () -> None
    loc: 282-297
    does: "Initialize the intent analyzer with patterns."
  IntentAnalyzer._extract_keywords:
    kind: method
    sig: (query:str) -> List[str]
    loc: 299-304
    does: "Extract keywords from a query string."
  IntentAnalyzer._calculate_intent_confidence:
    kind: method
    sig: (keywords:List[str], patterns:List[str]) -> float
    loc: 306-311
    does: "Calculate confidence score based on keyword matches."
  IntentAnalyzer._identify_target:
    kind: method
    sig: (query:str, project:Any) -> str
    loc: 313-331
    does: "Identify the target of the query (module, function, class, or project)."
  IntentAnalyzer._generate_description:
    kind: method
    sig: (intent_type:IntentType, target:str) -> str
    loc: 333-343
    does: "Generate a description for the detected intent."
  IntentAnalyzer._generate_suggestions:
    kind: method
    sig: (intent_type:IntentType, target:str, project:Any) -> List[str]
    loc: 345-379
    does: "Generate suggestions based on intent type."
  IntentAnalyzer.analyze_intent:
    kind: method
    sig: (query:str, project:Any) -> List[Intent]
    loc: 381-411
    does: "Analyze a query and return detected intents sorted by confidence."
  IntentAnalyzer.detect_code_smells:
    kind: method
    sig: (project:Any) -> List[dict]
    loc: 413-464
    does: "Detect code smells in the project."
  IntentAnalyzer.suggest_refactoring:
    kind: method
    sig: (target:str, project:Any) -> List[str]
    loc: 466-489
    does: "Generate refactoring suggestions for a target."
  IntentAnalyzer._find_target_object:
    kind: method
    sig: (target:str, project:Any) -> Any
    loc: 491-507
    does: "Find the object referenced by target string."
  IntentAnalyzer._suggest_module_refactoring:
    kind: method
    sig: (module:Any) -> List[str]
    loc: 509-523
    does: "Generate refactoring suggestions for a module."
  IntentAnalyzer._suggest_class_refactoring:
    kind: method
    sig: (cls:Any) -> List[str]
    loc: 525-536
    does: "Generate refactoring suggestions for a class."
  IntentAnalyzer._suggest_function_refactoring:
    kind: method
    sig: (func:Any) -> List[str]
    loc: 538-557
    does: "Generate refactoring suggestions for a function."

# adaptive.py | python | 15 functions
functions:
  get_llm_capabilities:
    kind: function
    sig: (model:str) -> Dict[str,Any]
    loc: 604-620
    does: "Get capabilities for a specific model."
  AdaptiveReproducer.__init__:
    kind: method
    sig: (client:BaseLLMClient=None, model:str=None) -> None
    loc: 127-136
    does: "Initialize adaptive reproducer."
  AdaptiveReproducer._get_capabilities:
    kind: method
    sig: () -> Dict[str,Any]
    loc: 138-149
    does: "Get LLM capabilities for current model."
  AdaptiveReproducer.select_format:
    kind: method
    sig: (file_path:Path, content:str) -> str
    loc: 151-185
    does: "Select optimal format based on file and LLM capabilities."
  AdaptiveReproducer.should_chunk:
    kind: method
    sig: (content:str) -> bool
    loc: 187-206
    does: "Determine if content should be chunked."
  AdaptiveReproducer.chunk_content:
    kind: method
    sig: (content:str, file_path:Path) -> List[ChunkInfo]
    loc: 208-325
    does: "Split content into logical chunks."
  AdaptiveReproducer.generate_chunk_spec:
    kind: method
    sig: (chunk:ChunkInfo, format_name:str) -> str
    loc: 327-347
    does: "Generate specification for a single chunk."
  AdaptiveReproducer._gherkin_for_chunk:
    kind: method
    sig: (chunk:ChunkInfo) -> str
    loc: 349-380
    does: "Generate Gherkin for a chunk."
  AdaptiveReproducer._yaml_for_chunk:
    kind: method
    sig: (chunk:ChunkInfo) -> str
    loc: 382-394
    does: "Generate YAML for a chunk."
  AdaptiveReproducer._json_for_chunk:
    kind: method
    sig: (chunk:ChunkInfo) -> str
    loc: 396-405
    does: "Generate JSON for a chunk."
  AdaptiveReproducer.reproduce:
    kind: method
    sig: (file_path:str, output_dir:str=None) -> AdaptiveResult
    loc: 407-430
    does: "Reproduce code with adaptive format selection."
  AdaptiveReproducer._reproduce_single:
    kind: method
    sig: (path:Path, content:str, format_name:str, output_dir:str=None) -> AdaptiveResult
    loc: 432-482
    does: "Reproduce without chunking."
  AdaptiveReproducer._reproduce_chunked:
    kind: method
    sig: (path:Path, content:str, format_name:str, output_dir:str=None) -> AdaptiveResult
    loc: 484-532
    does: "Reproduce with chunking."
  AdaptiveReproducer._generate_from_spec:
    kind: method
    sig: (spec:str, format_name:str, file_ext:str) -> str
    loc: 534-565
    does: "Generate code from specification."
  AdaptiveReproducer._save_result:
    kind: method
    sig: (output_dir:Path, original:str, spec:str, generated:str, result:AdaptiveResult) -> None
    loc: 567-601
    does: "Save reproduction results."

# reproducer.py | python | 27 functions
functions:
  reproduce_project:
    kind: function
    sig: (spec_path:str, output_dir:str, filter_paths:Optional[List[str]]=None, validate:bool=True, verbose:bool=True) -> ReproductionResult
    loc: 633-685
    does: "Convenience function to reproduce and validate a project."
  validate_files:
    kind: function
    sig: (spec_path:str, generated_dir:str, filter_paths:Optional[List[str]]=None) -> List[FileValidation]
    loc: 688-705
    does: "Validate specific files against spec."
  FileValidation.score:
    kind: method
    sig: () -> float
    loc: 43-58
    does: "Calculate match score 0-100."
  FileValidation.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 60-69
    does: "converts dict"
  ReproductionResult.success_rate:
    kind: method
    sig: () -> float
    loc: 84-87
    does: "success rate"
  ReproductionResult.average_score:
    kind: method
    sig: () -> float
    loc: 90-93
    does: "average score"
  ReproductionResult.summary:
    kind: method
    sig: () -> str
    loc: 95-107
    does: "summary"
  SpecReproducer.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 122-123
    does: "creates"
  SpecReproducer.reproduce_from_yaml:
    kind: method
    sig: (spec_path:str, output_dir:str, filter_paths:Optional[List[str]]=None) -> ReproductionResult
    loc: 125-142
    does: "Reproduce files from YAML specification."
  SpecReproducer.reproduce_from_json:
    kind: method
    sig: (spec_path:str, output_dir:str, filter_paths:Optional[List[str]]=None) -> ReproductionResult
    loc: 144-154
    does: "Reproduce files from JSON specification."
  SpecReproducer._reproduce:
    kind: method
    sig: (spec:Dict[str,Any], output_dir:str, filter_paths:Optional[List[str]]=None) -> ReproductionResult
    loc: 156-196
    does: "Internal reproduction logic."
  SpecReproducer._generate_file:
    kind: method
    sig: (module:Dict[str,Any], output_path:Path) -> bool
    loc: 198-214
    does: "Generate a single file from module spec."
  SpecReproducer._generate_python:
    kind: method
    sig: (module:Dict[str,Any]) -> str
    loc: 216-261
    does: "Generate Python file content."
  SpecReproducer._render_docstring:
    kind: method
    sig: (text:str, indent:str) -> List[str]
    loc: 263-290
    does: "Render a safe Python docstring or fall back to comments."
  SpecReproducer._sanitize_python_property:
    kind: method
    sig: (prop:str) -> str
    loc: 292-320
    does: "Sanitize a Python class property declaration for valid syntax."
  SpecReproducer._generate_python_class:
    kind: method
    sig: (cls:Dict[str,Any]) -> List[str]
    loc: 322-363
    does: "Generate Python class."
  SpecReproducer._generate_python_method:
    kind: method
    sig: (method:Dict[str,Any]) -> List[str]
    loc: 365-391
    does: "Generate Python method."
  SpecReproducer._generate_python_function:
    kind: method
    sig: (func:Dict[str,Any]) -> List[str]
    loc: 393-412
    does: "Generate Python function."
  SpecReproducer._generate_typescript:
    kind: method
    sig: (module:Dict[str,Any]) -> str
    loc: 414-442
    does: "Generate TypeScript file content."
  SpecReproducer._generate_ts_class:
    kind: method
    sig: (cls:Dict[str,Any]) -> List[str]
    loc: 444-466
    does: "Generate TypeScript class."
  SpecReproducer._generate_ts_method:
    kind: method
    sig: (method:Dict[str,Any]) -> List[str]
    loc: 468-481
    does: "Generate TypeScript method."
  SpecReproducer._generate_ts_function:
    kind: method
    sig: (func:Dict[str,Any]) -> List[str]
    loc: 483-496
    does: "Generate TypeScript function."
  SpecReproducer._parse_signature:
    kind: method
    sig: (sig:str) -> str
    loc: 498-513
    does: "Parse and clean signature."
  SpecValidator.__init__:
    kind: method
    sig: () -> None
    loc: 529-530
    does: "creates"
  SpecValidator.validate:
    kind: method
    sig: (spec_path:str, generated_dir:str, filter_paths:Optional[List[str]]=None) -> List[FileValidation]
    loc: 532-568
    does: "Validate generated files against spec."
  SpecValidator._validate_file:
    kind: method
    sig: (module:Dict[str,Any], base_path:Path) -> FileValidation
    loc: 570-621
    does: "Validate a single file."
  SpecValidator._check_python_syntax:
    kind: method
    sig: (content:str, validation:FileValidation) -> bool
    loc: 623-630
    does: "Check Python syntax."

# llm_clients.py | python | 30 functions
functions:
  _get_user_llm_config_path:
    kind: function
    sig: () -> str
    loc: 75-76
    does: "retrieves user llm config path"
  _load_user_llm_config:
    kind: function
    sig: () -> Dict[str,Any]
    loc: 79-87
    does: "retrieves user llm config"
  _get_priority_mode:
    kind: function
    sig: () -> str
    loc: 90-92
    does: "retrieves priority mode"
  get_priority_mode:
    kind: function
    sig: () -> str
    loc: 95-96
    does: "retrieves priority mode"
  _get_provider_priority_overrides:
    kind: function
    sig: () -> Dict[str,int]
    loc: 99-108
    does: "retrieves provider priority overrides"
  _get_model_priority_rules:
    kind: function
    sig: () -> Dict[str,Dict[str,int]]
    loc: 111-131
    does: "retrieves model priority rules"
  _get_model_priority:
    kind: function
    sig: (model_string:str) -> Optional[int]
    loc: 134-150
    does: "retrieves model priority"
  _get_provider_model_string:
    kind: function
    sig: (provider:str) -> str
    loc: 153-172
    does: "retrieves provider model string"
  get_client:
    kind: function
    sig: (provider:str=None, model:str=None) -> BaseLLMClient
    loc: 380-411
    does: "Get appropriate LLM client based on provider."
  _try_client:
    kind: function
    sig: (provider:str, model:str=None) -> Optional[BaseLLMClient]
    loc: 414-428
    does: "try client"
  _get_priority_order:
    kind: function
    sig: () -> List[str]
    loc: 431-432
    does: "retrieves priority order"
  _get_effective_provider_order:
    kind: function
    sig: () -> List[tuple[str,int]]
    loc: 435-486
    does: "retrieves effective provider order"
  get_effective_provider_priorities:
    kind: function
    sig: () -> Dict[str,int]
    loc: 489-490
    does: "retrieves effective provider priorities"
  _get_provider_priorities_from_litellm_yaml:
    kind: function
    sig: () -> Dict[str,int]
    loc: 493-517
    does: "retrieves provider priorities from litellm yaml"
  _candidate_litellm_yaml_paths:
    kind: function
    sig: () -> List[str]
    loc: 520-526
    does: "candidate litellm yaml paths"
  BaseLLMClient.generate:
    kind: method
    sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
    loc: 190-192
    does: "Generate completion."
  BaseLLMClient.is_available:
    kind: method
    sig: () -> bool
    loc: 195-197
    does: "Check if client is available."
  BaseLLMClient.chat:
    kind: method
    sig: (messages:List[Dict[str,str]], max_tokens:int=4000) -> str
    loc: 199-209
    does: "Chat completion (default implementation)."
  OpenRouterClient.__init__:
    kind: method
    sig: (api_key:str=None, model:str=None) -> None
    loc: 218-226
    does: "Initialize OpenRouter client."
  OpenRouterClient.generate:
    kind: method
    sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
    loc: 228-264
    does: "Generate completion using OpenRouter."
  OpenRouterClient.is_available:
    kind: method
    sig: () -> bool
    loc: 266-268
    does: "Check if OpenRouter is configured."
  OpenRouterClient.list_recommended_models:
    kind: method
    sig: () -> List[tuple]
    loc: 271-273
    does: "List recommended models for code tasks."
  OllamaLocalClient.__init__:
    kind: method
    sig: (model:str=None, host:str=None) -> None
    loc: 281-289
    does: "Initialize Ollama client."
  OllamaLocalClient.generate:
    kind: method
    sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
    loc: 291-310
    does: "Generate completion using Ollama."
  OllamaLocalClient.is_available:
    kind: method
    sig: () -> bool
    loc: 312-320
    does: "Check if Ollama is running."
  OllamaLocalClient.list_models:
    kind: method
    sig: () -> List[str]
    loc: 322-333
    does: "List available Ollama models."
  OllamaLocalClient.list_recommended_models:
    kind: method
    sig: () -> List[tuple]
    loc: 336-338
    does: "List recommended models for code tasks."
  LiteLLMClient.__init__:
    kind: method
    sig: (model:str=None) -> None
    loc: 346-352
    does: "Initialize LiteLLM client."
  LiteLLMClient.generate:
    kind: method
    sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
    loc: 354-373
    does: "Generate completion using LiteLLM."
  LiteLLMClient.is_available:
    kind: method
    sig: () -> bool
    loc: 375-377
    does: "Check if LiteLLM is available."

# prompts.py | python | 3 functions
functions:
  get_reproduction_prompt:
    kind: function
    sig: (spec:str, fmt:str, file_name:str, language:str='python', max_spec_length:int=5000) -> str
    loc: 57-91
    does: "Generate optimized reproduction prompt."
  get_review_prompt:
    kind: function
    sig: (code:str, spec:str, fmt:str) -> str
    loc: 94-126
    does: "Generate code review prompt."
  get_fix_prompt:
    kind: function
    sig: (code:str, issues:list, spec:str) -> str
    loc: 129-156
    does: "Generate code fix prompt."

# chunked_reproduction.py | python | 12 functions
functions:
  get_llm_limit:
    kind: function
    sig: (model_name:str) -> int
    loc: 71-79
    does: "Get context limit for LLM model."
  chunk_yaml_spec:
    kind: function
    sig: (spec:str, max_tokens:int=2000) -> List[Chunk]
    loc: 82-144
    does: "Chunk YAML specification by modules/classes/functions."
  chunk_gherkin_spec:
    kind: function
    sig: (spec:str, max_tokens:int=2000) -> List[Chunk]
    loc: 147-225
    does: "Chunk Gherkin specification by Features/Scenarios."
  chunk_markdown_spec:
    kind: function
    sig: (spec:str, max_tokens:int=2000) -> List[Chunk]
    loc: 228-276
    does: "Chunk Markdown specification by sections."
  chunk_spec:
    kind: function
    sig: (spec:str, fmt:str, max_tokens:int=2000) -> ChunkedSpec
    loc: 279-298
    does: "Chunk specification based on format."
  get_chunk_prompt:
    kind: function
    sig: (chunk:Chunk, fmt:str, file_name:str, chunk_num:int, total_chunks:int) -> str
    loc: 301-319
    does: "Generate prompt for a single chunk."
  merge_chunk_codes:
    kind: function
    sig: (codes:List[str], file_name:str) -> str
    loc: 322-348
    does: "Merge code from multiple chunks."
  auto_chunk_reproduce:
    kind: function
    sig: (spec:str, fmt:str, file_name:str, client, model_name:str='default') -> ChunkedResult
    loc: 431-440
    does: "Auto-chunking reproduction with LLM adaptation."
  adaptive_chunk_reproduce:
    kind: function
    sig: (spec:str, fmt:str, file_name:str, client, provider:str='unknown', model:str='unknown') -> ChunkedResult
    loc: 443-479
    does: "Adaptive chunking reproduction using LLM profile."
  ChunkedReproducer.__init__:
    kind: method
    sig: (client, model_name:str='default') -> None
    loc: 354-357
    does: "creates"
  ChunkedReproducer.reproduce:
    kind: method
    sig: (spec:str, fmt:str, file_name:str) -> ChunkedResult
    loc: 359-420
    does: "Reproduce code from specification, chunking if needed."
  ChunkedReproducer._extract_code:
    kind: method
    sig: (response:str) -> str
    loc: 422-428
    does: "Extract code from LLM response."

# __init__.py | python | 2 functions
functions:
  analyze_quality:
    kind: function
    sig: (target) -> None
    loc: 188-191
    does: "processes quality"
  reproduce_project:
    kind: function
    sig: (source:str) -> None
    loc: 194-198
    does: "reproduce project"

# metrics.py | python | 14 functions
functions:
  analyze_reproduction:
    kind: function
    sig: (original:str, generated:str, spec:str='', format_name:str='', verbose:bool=False) -> ReproductionResult
    loc: 530-550
    does: "Convenience function for reproduction analysis."
  compare_formats:
    kind: function
    sig: (original:str, results:Dict[str,Tuple[str,str]], verbose:bool=False) -> Dict[str, Any]
    loc: 553-597
    does: "Compare reproduction quality across formats."
  ReproductionResult.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 117-118
    does: "converts dict"
  ReproductionResult.to_report:
    kind: method
    sig: () -> str
    loc: 120-180
    does: "Generate detailed markdown report."
  ReproductionMetrics.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 186-189
    does: "creates"
  ReproductionMetrics.analyze:
    kind: method
    sig: (original:str, generated:str, spec:str='', format_name:str='', source_file:str='') -> ReproductionResult
    loc: 191-244
    does: "Analyze reproduction quality."
  ReproductionMetrics._compute_text_metrics:
    kind: method
    sig: (original:str, generated:str) -> TextMetrics
    loc: 246-288
    does: "Compute text-level metrics."
  ReproductionMetrics._cosine_similarity:
    kind: method
    sig: (words1:List[str], words2:List[str]) -> float
    loc: 290-304
    does: "Compute cosine similarity between word lists."
  ReproductionMetrics._compute_structural_metrics:
    kind: method
    sig: (original:str, generated:str) -> StructuralMetrics
    loc: 306-359
    does: "Compute structural metrics."
  ReproductionMetrics._compute_semantic_metrics:
    kind: method
    sig: (original:str, generated:str) -> SemanticMetrics
    loc: 361-417
    does: "Compute semantic preservation metrics."
  ReproductionMetrics._compute_format_metrics:
    kind: method
    sig: (original:str, generated:str, spec:str, format_name:str) -> FormatMetrics
    loc: 419-453
    does: "Compute format efficiency metrics."
  ReproductionMetrics._compute_overall_score:
    kind: method
    sig: (result:ReproductionResult) -> float
    loc: 455-484
    does: "Compute weighted overall score."
  ReproductionMetrics._get_grade:
    kind: method
    sig: (score:float) -> str
    loc: 486-497
    does: "Get letter grade from score."
  ReproductionMetrics._generate_recommendations:
    kind: method
    sig: (result:ReproductionResult) -> List[str]
    loc: 499-527
    does: "Generate improvement recommendations."

# refactor.py | python | 7 functions
functions:
  find_duplicates:
    kind: function
    sig: (project_path:str, threshold:float=0.8) -> List[DuplicateGroup]
    loc: 112-167
    does: "Find duplicate functions in a project."
  analyze_quality:
    kind: function
    sig: (project_path:str, include_security:bool=True, include_performance:bool=True) -> RefactoringReport
    loc: 170-229
    does: "Analyze code quality and generate refactoring report."
  suggest_refactoring:
    kind: function
    sig: (project_path:str, use_llm:bool=False, client:BaseLLMClient=None) -> RefactoringReport
    loc: 232-294
    does: "Generate refactoring suggestions for a project."
  compare_codebases:
    kind: function
    sig: (project1:str, project2:str) -> Dict[str, Any]
    loc: 297-350
    does: "Compare two codebases for similarities and differences."
  quick_analyze:
    kind: function
    sig: (project_path:str) -> Dict[str, Any]
    loc: 353-388
    does: "Quick analysis for a project."
  RefactoringReport.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 65-66
    does: "converts dict"
  RefactoringReport.to_markdown:
    kind: method
    sig: () -> str
    loc: 68-109
    does: "Generate markdown report."

# logicml.py | python | 9 functions
functions:
  generate_logicml:
    kind: function
    sig: (project:ProjectInfo, detail:str='standard') -> str
    loc: 340-344
    does: "Convenience function to generate LogicML format."
  LogicMLGenerator.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 80-81
    does: "creates"
  LogicMLGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='standard') -> LogicMLSpec
    loc: 83-105
    does: "Generate LogicML specification for a project."
  LogicMLGenerator._generate_module:
    kind: method
    sig: (module:ModuleInfo, detail:str) -> str
    loc: 107-165
    does: "Generate LogicML for a single module."
  LogicMLGenerator._generate_imports:
    kind: method
    sig: (imports:List[str]) -> str
    loc: 167-193
    does: "Generate compact imports section."
  LogicMLGenerator._generate_class:
    kind: method
    sig: (cls:ClassInfo, detail:str) -> str
    loc: 195-247
    does: "Generate LogicML for a class."
  LogicMLGenerator._generate_method:
    kind: method
    sig: (method:FunctionInfo, detail:str, indent:int=2) -> str
    loc: 249-295
    does: "Generate LogicML for a method."
  LogicMLGenerator._generate_functions:
    kind: method
    sig: (functions:List[FunctionInfo], detail:str) -> str
    loc: 297-305
    does: "Generate LogicML for top-level functions."
  LogicMLGenerator._detect_side_effects:
    kind: method
    sig: (method:FunctionInfo) -> Optional[str]
    loc: 307-337
    does: "Detect side effects from method calls and name patterns."

# function_logic.py | python | 12 functions
functions:
  FunctionLogicGenerator.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 13-14
    does: "creates"
  FunctionLogicGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='full') -> str
    loc: 16-42
    does: "creates"
  FunctionLogicGenerator.generate_json:
    kind: method
    sig: (project:ProjectInfo, detail:str='full') -> str
    loc: 44-50
    does: "creates json"
  FunctionLogicGenerator.generate_yaml:
    kind: method
    sig: (project:ProjectInfo, detail:str='full') -> str
    loc: 52-60
    does: "creates yaml"
  FunctionLogicGenerator.generate_toon:
    kind: method
    sig: (project:ProjectInfo, detail:str='full') -> str
    loc: 62-126
    does: "creates toon"
  FunctionLogicGenerator._build_data:
    kind: method
    sig: (project:ProjectInfo, detail:str) -> dict
    loc: 128-145
    does: "creates data"
  FunctionLogicGenerator._module_items:
    kind: method
    sig: (module) -> List[Tuple[str, str, FunctionInfo]]
    loc: 147-157
    does: "module items"
  FunctionLogicGenerator._build_sig:
    kind: method
    sig: (func:FunctionInfo, include_async_prefix:bool=True) -> str
    loc: 159-166
    does: "creates sig"
  FunctionLogicGenerator._build_loc:
    kind: method
    sig: (func:FunctionInfo) -> str
    loc: 168-173
    does: "creates loc"
  FunctionLogicGenerator._build_does:
    kind: method
    sig: (func:FunctionInfo) -> str
    loc: 175-179
    does: "creates does"
  FunctionLogicGenerator._item_to_dict:
    kind: method
    sig: (kind:str, qualified_name:str, func:FunctionInfo, detail:str) -> dict
    loc: 181-218
    does: "item to dict"
  FunctionLogicGenerator._format_function:
    kind: method
    sig: (kind:str, qualified_name:str, func:FunctionInfo, detail:str, indent:int) -> List[str]
    loc: 220-267
    does: "formats function"

# utils.py | python | 3 functions
functions:
  estimate_tokens:
    kind: function
    sig: (text:str) -> int
    loc: 7-8
    does: "estimate tokens"
  write_text_atomic:
    kind: function
    sig: (path:Path, content:str) -> None
    loc: 11-15
    does: "logs text atomic"
  cleanup_generated_root:
    kind: function
    sig: (generated_root:Path, allowed_dirs:set[str]) -> None
    loc: 18-24
    does: "cleanup generated root"

# generators.py | python | 60 functions
functions:
  bytes_to_kb:
    kind: function
    sig: (bytes_value:int) -> float
    loc: 22-26
    does: "Convert bytes to kilobytes with single decimal precision."
  MarkdownGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail_level:str='standard') -> str
    loc: 45-143
    does: "Generate Markdown output."
  MarkdownGenerator._gen_tree:
    kind: method
    sig: (lines:List[str], project:ProjectInfo) -> None
    loc: 145-169
    does: "Generate project structure tree."
  MarkdownGenerator._print_tree:
    kind: method
    sig: (lines:List[str], tree:dict, prefix:str, depth:int=0) -> None
    loc: 171-186
    does: "Recursively print tree structure."
  MarkdownGenerator._gen_module:
    kind: method
    sig: (lines:List[str], m:ModuleInfo, detail:str, proj:ProjectInfo) -> None
    loc: 188-243
    does: "Generate module documentation."
  MarkdownGenerator._gen_class:
    kind: method
    sig: (lines:List[str], cls:ClassInfo, detail:str) -> None
    loc: 245-269
    does: "Generate class documentation."
  MarkdownGenerator._sig:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 271-288
    does: "Generate function signature."
  CompactGenerator.generate:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 304-352
    does: "Generate compact output."
  JSONGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, flat:bool=False, detail:str='standard') -> str
    loc: 370-385
    does: "Generate JSON output."
  JSONGenerator.generate_from_module:
    kind: method
    sig: (module:ModuleInfo, detail:str='full') -> str
    loc: 387-401
    does: "creates from module"
  JSONGenerator._generate_nested:
    kind: method
    sig: (project:ProjectInfo, detail:str) -> str
    loc: 403-468
    does: "Generate nested JSON structure."
  JSONGenerator._field_to_dict:
    kind: method
    sig: (field:FieldInfo) -> dict
    loc: 470-479
    does: "Serialize dataclass FieldInfo to dictionary."
  JSONGenerator._generate_flat:
    kind: method
    sig: (project:ProjectInfo, detail:str) -> str
    loc: 481-516
    does: "Generate flat JSON list for comparisons."
  JSONGenerator._build_element_row:
    kind: method
    sig: (m:ModuleInfo, elem_type:str, name:str, signature:str, f:FunctionInfo, deps:list, detail:str) -> dict
    loc: 518-545
    does: "Build a single element row for flat output."
  JSONGenerator._build_signature:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 547-556
    does: "Build compact signature."
  JSONGenerator._categorize:
    kind: method
    sig: (name:str) -> str
    loc: 558-560
    does: "Categorize by name pattern."
  JSONGenerator._extract_domain:
    kind: method
    sig: (path:str) -> str
    loc: 562-564
    does: "Extract domain from path."
  JSONGenerator._compute_hash:
    kind: method
    sig: (name:str, signature:str) -> str
    loc: 566-568
    does: "Compute short hash."
  YAMLGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, flat:bool=False, detail:str='standard', compact:bool=True) -> str
    loc: 605-638
    does: "Generate YAML output."
  YAMLGenerator.generate_schema:
    kind: method
    sig: (format_type:str='compact') -> str
    loc: 640-655
    does: "Generate JSON Schema for the YAML format."
  YAMLGenerator._generate_compact_schema:
    kind: method
    sig: () -> str
    loc: 657-781
    does: "Generate JSON Schema for compact YAML format with meta.legend."
  YAMLGenerator._generate_full_schema:
    kind: method
    sig: () -> str
    loc: 783-861
    does: "Generate JSON Schema for full YAML format."
  YAMLGenerator._generate_hybrid_schema:
    kind: method
    sig: () -> str
    loc: 863-978
    does: "Generate JSON Schema for hybrid format."
  YAMLGenerator.generate_hybrid:
    kind: method
    sig: (project:ProjectInfo, detail:str='standard') -> str
    loc: 980-1229
    does: "Generate hybrid format combining TOON compactness with YAML completeness."
  YAMLGenerator._build_enhanced_signature:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 1231-1250
    does: "Build enhanced signature with better parameter handling."
  YAMLGenerator._extract_constants:
    kind: method
    sig: (module:ModuleInfo) -> list
    loc: 1252-1265
    does: "Extract constants and type definitions from module."
  YAMLGenerator._extract_dataclasses:
    kind: method
    sig: (module:ModuleInfo) -> list
    loc: 1267-1276
    does: "Extract dataclass information from classes."
  YAMLGenerator._extract_conditional_imports:
    kind: method
    sig: (module:ModuleInfo) -> list
    loc: 1278-1288
    does: "Extract conditional imports from constants."
  YAMLGenerator.generate_from_module:
    kind: method
    sig: (module:ModuleInfo, detail:str='full') -> str
    loc: 1290-1304
    does: "creates from module"
  YAMLGenerator._build_flat_data:
    kind: method
    sig: (project:ProjectInfo, detail:str) -> dict
    loc: 1306-1340
    does: "Build flat data structure optimized for comparisons."
  YAMLGenerator._build_nested_data:
    kind: method
    sig: (project:ProjectInfo, detail:str) -> dict
    loc: 1342-1414
    does: "Build nested hierarchical data structure."
  YAMLGenerator._constants_for_module_verbose:
    kind: method
    sig: (module:ModuleInfo, limit:int=12) -> list
    loc: 1416-1443
    does: "constants for module verbose"
  YAMLGenerator._build_row:
    kind: method
    sig: (path:str, elem_type:str, name:str, signature:str, language:str, detail:str, project:ProjectInfo) -> dict
    loc: 1445-1455
    does: "Build a single row for flat output."
  YAMLGenerator._build_function_row:
    kind: method
    sig: (path:str, f:FunctionInfo, language:str, detail:str, project:ProjectInfo, imports:list) -> dict
    loc: 1457-1483
    does: "Build row for standalone function."
  YAMLGenerator._build_method_row:
    kind: method
    sig: (path:str, class_name:str, f:FunctionInfo, language:str, detail:str, project:ProjectInfo, imports:list) -> dict
    loc: 1485-1512
    does: "Build row for class method."
  YAMLGenerator._function_to_dict:
    kind: method
    sig: (f:FunctionInfo, detail:str) -> dict
    loc: 1514-1530
    does: "Convert function to dict for nested output."
  YAMLGenerator._method_to_dict:
    kind: method
    sig: (f:FunctionInfo, detail:str) -> dict
    loc: 1532-1571
    does: "Convert method to dictionary for YAML output."
  YAMLGenerator._build_signature:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 1573-1590
    does: "Build compact signature string."
  YAMLGenerator._categorize:
    kind: method
    sig: (name:str) -> str
    loc: 1592-1594
    does: "Categorize function by name pattern."
  YAMLGenerator._extract_domain:
    kind: method
    sig: (path:str) -> str
    loc: 1596-1598
    does: "Extract domain from file path."
  YAMLGenerator._compute_hash:
    kind: method
    sig: (name:str, signature:str) -> str
    loc: 1600-1602
    does: "Compute short hash for quick comparison."
  YAMLGenerator._generate_simple_yaml:
    kind: method
    sig: (project:ProjectInfo, flat:bool, detail:str) -> str
    loc: 1604-1640
    does: "Fallback YAML generation without pyyaml."
  YAMLGenerator._build_compact_data:
    kind: method
    sig: (project:ProjectInfo, detail:str) -> dict
    loc: 1642-1709
    does: "Build compact data structure with short keys."
  YAMLGenerator._compact_imports:
    kind: method
    sig: (imports:list) -> list
    loc: 1711-1715
    does: "Deduplicate and compact imports (typing.Dict, typing.List -> typing.{Dict,List})..."
  YAMLGenerator._compact_class:
    kind: method
    sig: (cls:ClassInfo, detail:str, module_types:Optional[list]=None) -> dict
    loc: 1717-1791
    does: "Generate compact class representation."
  YAMLGenerator._compact_function:
    kind: method
    sig: (f:FunctionInfo, detail:str) -> dict
    loc: 1793-1823
    does: "Generate compact function representation."
  YAMLGenerator._compact_method:
    kind: method
    sig: (f:FunctionInfo, detail:str) -> dict
    loc: 1825-1827
    does: "Generate compact method representation (same as function)."
  YAMLGenerator._build_compact_signature:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 1829-1844
    does: "Build compact signature without 'self' and with clean formatting."
  YAMLGenerator._constants_for_module_verbose:
    kind: method
    sig: (module:ModuleInfo, limit:int=10) -> list
    loc: 1846-1869
    does: "Convert module constants into verbose dictionaries."
  YAMLGenerator._constants_for_module:
    kind: method
    sig: (module:ModuleInfo, limit:int=10) -> list
    loc: 1871-1884
    does: "Convert module constants into compact dictionaries."
  YAMLGenerator._constant_to_dict:
    kind: method
    sig: (constant:ConstantInfo) -> dict
    loc: 1886-1898
    does: "Serialize ConstantInfo into a compact dictionary."
  YAMLGenerator._field_to_dict:
    kind: method
    sig: (field:FieldInfo) -> dict
    loc: 1900-1909
    does: "Serialize dataclass FieldInfo to dictionary."
  CSVGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='standard') -> str
    loc: 1943-1994
    does: "Generate CSV output."
  CSVGenerator._build_row:
    kind: method
    sig: (m:ModuleInfo, elem_type:str, name:str, signature:str, calls:list, deps:str, detail:str) -> dict
    loc: 1996-2023
    does: "Build a single CSV row."
  CSVGenerator._build_function_row:
    kind: method
    sig: (m:ModuleInfo, elem_type:str, name:str, f:FunctionInfo, deps:str, detail:str, project:ProjectInfo) -> dict
    loc: 2025-2054
    does: "Build CSV row for function/method."
  CSVGenerator._build_signature:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 2056-2068
    does: "Build compact signature."
  CSVGenerator._categorize:
    kind: method
    sig: (name:str) -> str
    loc: 2070-2072
    does: "Categorize function by name pattern."
  CSVGenerator._extract_domain:
    kind: method
    sig: (path:str) -> str
    loc: 2074-2076
    does: "Extract domain from file path."
  CSVGenerator._compute_hash:
    kind: method
    sig: (name:str, signature:str) -> str
    loc: 2078-2082
    does: "Compute short hash for quick comparison."
  CSVGenerator._escape_csv:
    kind: method
    sig: (text:str) -> str
    loc: 2084-2088
    does: "Escape text for CSV (remove newlines, limit commas)."

# markdown_format.py | python | 10 functions
functions:
  generate_markdown_hybrid:
    kind: function
    sig: (project:ProjectInfo, detail:str='full') -> str
    loc: 344-348
    does: "Convenience function to generate Markdown hybrid format."
  generate_file_markdown:
    kind: function
    sig: (file_path:str) -> str
    loc: 351-365
    does: "Generate Markdown hybrid for a single file."
  MarkdownHybridGenerator.__init__:
    kind: method
    sig: (verbose:bool=False) -> None
    loc: 45-48
    does: "creates"
  MarkdownHybridGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='full') -> MarkdownSpec
    loc: 50-92
    does: "Generate Markdown hybrid specification."
  MarkdownHybridGenerator._generate_header:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 94-101
    does: "Generate header section."
  MarkdownHybridGenerator._generate_tree:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 103-124
    does: "Generate file tree section."
  MarkdownHybridGenerator._generate_imports:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 126-165
    does: "Generate imports as YAML for precise reproduction."
  MarkdownHybridGenerator._generate_classes_yaml:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 167-241
    does: "Generate classes as detailed YAML codeblock."
  MarkdownHybridGenerator._generate_functions_gherkin:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 243-313
    does: "Generate functions as detailed Gherkin codeblock."
  MarkdownHybridGenerator._generate_dependencies:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 315-341
    does: "Generate module dependencies section."

# similarity.py | python | 6 functions
functions:
  is_rapidfuzz_available:
    kind: function
    sig: () -> bool
    loc: 163-165
    does: "Check if Rapidfuzz is available."
  get_refactoring_suggestions:
    kind: function
    sig: (similar_functions:Dict[str,List[str]]) -> List[Dict[str,any]]
    loc: 168-238
    does: "Generate refactoring suggestions based on similar functions."
  SimilarityDetector.__init__:
    kind: method
    sig: (threshold:float=80.0) -> None
    loc: 38-45
    does: "Initialize the similarity detector."
  SimilarityDetector.find_similar_functions:
    kind: method
    sig: (modules:List[ModuleInfo]) -> Dict[str,List[str]]
    loc: 47-107
    does: "Find similar functions across all modules."
  SimilarityDetector.find_duplicate_signatures:
    kind: method
    sig: (modules:List[ModuleInfo]) -> Dict[str,List[str]]
    loc: 109-142
    does: "Find functions with identical signatures."
  SimilarityDetector._build_signature:
    kind: method
    sig: (name:str, params:List[str], return_type:str=None) -> str
    loc: 144-160
    does: "Build a normalized signature string."

# universal.py | python | 25 functions
functions:
  reproduce_file:
    kind: function
    sig: (source_path:str, target_lang:str=None, output_dir:str=None, use_llm:bool=True) -> Dict[str, Any]
    loc: 1056-1074
    does: "Convenience function for single file reproduction."
  CodeLogic.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 108-118
    does: "Convert to dictionary."
  CodeLogic._element_to_dict:
    kind: method
    sig: (elem:CodeElement) -> Dict[str, Any]
    loc: 120-135
    does: "Convert element to dictionary."
  CodeLogic.to_compact:
    kind: method
    sig: () -> str
    loc: 137-159
    does: "Convert to compact string representation."
  CodeLogic._element_to_compact:
    kind: method
    sig: (elem:CodeElement, indent:int) -> List[str]
    loc: 161-222
    does: "Convert element to compact lines."
  UniversalParser.detect_language:
    kind: method
    sig: (content:str, file_ext:str) -> Language
    loc: 239-262
    does: "Detect programming language from content and extension."
  UniversalParser.parse:
    kind: method
    sig: (file_path:Union[str,Path]) -> CodeLogic
    loc: 264-282
    does: "Parse source file into CodeLogic."
  UniversalParser._parse_python:
    kind: method
    sig: (path:Path, content:str, hash_:str) -> CodeLogic
    loc: 284-406
    does: "Parse Python file."
  UniversalParser._parse_js_ts:
    kind: method
    sig: (path:Path, content:str, hash_:str, lang:Language) -> CodeLogic
    loc: 408-577
    does: "Parse JavaScript/TypeScript file."
  UniversalParser._parse_go:
    kind: method
    sig: (path:Path, content:str, hash_:str) -> CodeLogic
    loc: 579-639
    does: "Parse Go file."
  UniversalParser._parse_sql:
    kind: method
    sig: (path:Path, content:str, hash_:str) -> CodeLogic
    loc: 641-683
    does: "Parse SQL file."
  UniversalParser._parse_generic:
    kind: method
    sig: (path:Path, content:str, hash_:str, lang:Language) -> CodeLogic
    loc: 685-706
    does: "Generic parser for unknown languages."
  CodeGenerator.generate:
    kind: method
    sig: (logic:CodeLogic, target_lang:Language) -> str
    loc: 712-723
    does: "Generate code in target language."
  CodeGenerator._generate_python:
    kind: method
    sig: (logic:CodeLogic) -> str
    loc: 725-756
    does: "Generate Python code."
  CodeGenerator._generate_python_element:
    kind: method
    sig: (elem:CodeElement, indent:int=0) -> List[str]
    loc: 758-814
    does: "Generate Python code for element."
  CodeGenerator._generate_typescript:
    kind: method
    sig: (logic:CodeLogic) -> str
    loc: 816-855
    does: "Generate TypeScript code."
  CodeGenerator._generate_go:
    kind: method
    sig: (logic:CodeLogic) -> str
    loc: 857-878
    does: "Generate Go code."
  CodeGenerator._generate_sql:
    kind: method
    sig: (logic:CodeLogic) -> str
    loc: 880-894
    does: "Generate SQL code."
  CodeGenerator._generate_generic:
    kind: method
    sig: (logic:CodeLogic, target:Language) -> str
    loc: 896-898
    does: "Generate generic code."
  UniversalReproducer.__init__:
    kind: method
    sig: (client:BaseLLMClient=None) -> None
    loc: 904-908
    does: "Initialize reproducer."
  UniversalReproducer._get_client:
    kind: method
    sig: () -> BaseLLMClient
    loc: 910-914
    does: "Get or create LLM client."
  UniversalReproducer.extract_logic:
    kind: method
    sig: (file_path:str) -> CodeLogic
    loc: 916-918
    does: "Extract code logic from file."
  UniversalReproducer.reproduce:
    kind: method
    sig: (source_path:str, target_lang:str=None, output_dir:str=None, use_llm:bool=True) -> Dict[str, Any]
    loc: 920-983
    does: "Reproduce code from source file."
  UniversalReproducer._generate_with_llm:
    kind: method
    sig: (logic:CodeLogic, target:Language) -> str
    loc: 985-1018
    does: "Generate code using LLM."
  UniversalReproducer._save_result:
    kind: method
    sig: (output_dir:Path, original:str, logic:CodeLogic, generated:str, result:Dict[str,Any]) -> None
    loc: 1020-1053
    does: "Save reproduction results."

# benchmark.py | python | 9 functions
functions:
  run_benchmark:
    kind: function
    sig: (files:List[str], output_dir:str='benchmark_results', provider:str=None, model:str=None) -> Dict[str,Any]
    loc: 430-449
    does: "Run reproduction benchmark."
  ReproductionBenchmark.__init__:
    kind: method
    sig: (client:BaseLLMClient=None) -> None
    loc: 140-153
    does: "Initialize benchmark."
  ReproductionBenchmark.generate_spec:
    kind: method
    sig: (file_path:Path, format_name:str, detail:str='full') -> str
    loc: 155-179
    does: "Generate specification in given format."
  ReproductionBenchmark.reproduce_with_format:
    kind: method
    sig: (file_path:Path, format_name:str, original_code:str) -> FormatResult
    loc: 181-252
    does: "Test reproduction with a specific format."
  ReproductionBenchmark.run_single:
    kind: method
    sig: (file_path:str, formats:List[str]=None) -> BenchmarkResult
    loc: 254-304
    does: "Run benchmark on a single file."
  ReproductionBenchmark.run_all:
    kind: method
    sig: (files:List[str], output_dir:str=None) -> Dict[str,Any]
    loc: 306-337
    does: "Run benchmark on multiple files."
  ReproductionBenchmark._generate_summary:
    kind: method
    sig: (results:List[BenchmarkResult]) -> Dict[str,Any]
    loc: 339-362
    does: "Generate summary from benchmark results."
  ReproductionBenchmark._save_results:
    kind: method
    sig: (output_dir:Path, results:List[BenchmarkResult], summary:Dict) -> None
    loc: 364-379
    does: "Save benchmark results."
  ReproductionBenchmark._generate_report:
    kind: method
    sig: (results:List[BenchmarkResult], summary:Dict) -> str
    loc: 381-427
    does: "Generate markdown benchmark report."

# terminal.py | python | 52 functions
functions:
  get_renderer:
    kind: function
    sig: (use_colors:bool=True, verbose:bool=True) -> ShellRenderer
    loc: 578-583
    does: "Get or create the global renderer instance."
  set_renderer:
    kind: function
    sig: (renderer:ShellRenderer) -> None
    loc: 586-589
    does: "Set the global renderer instance."
  ShellRenderer.__init__:
    kind: method
    sig: (use_colors:bool=True, verbose:bool=True) -> None
    loc: 99-104
    does: "creates"
  ShellRenderer._supports_colors:
    kind: method
    sig: () -> bool
    loc: 106-117
    does: "Check if terminal supports ANSI colors."
  ShellRenderer.enable_log:
    kind: method
    sig: () -> None
    loc: 119-122
    does: "Enable log buffering for markdown export."
  ShellRenderer.get_log:
    kind: method
    sig: () -> str
    loc: 124-126
    does: "Get buffered log as clean markdown (no ANSI codes)."
  ShellRenderer.clear_log:
    kind: method
    sig: () -> None
    loc: 128-130
    does: "Clear log buffer."
  ShellRenderer._log:
    kind: method
    sig: (text:str) -> None
    loc: 132-140
    does: "Log a line (strips ANSI codes for markdown)."
  ShellRenderer._c:
    kind: method
    sig: (color:str, text:str) -> str
    loc: 142-147
    does: "Apply color to text."
  ShellRenderer.heading:
    kind: method
    sig: (level:int, text:str) -> None
    loc: 153-156
    does: "Print a markdown heading."
  ShellRenderer.codeblock:
    kind: method
    sig: (language:Language, content:str) -> None
    loc: 158-171
    does: "Print a syntax-highlighted code block."
  ShellRenderer.render_markdown:
    kind: method
    sig: (text:str) -> None
    loc: 173-209
    does: "Render full markdown text with syntax highlighting."
  ShellRenderer.success:
    kind: method
    sig: (message:str) -> None
    loc: 215-217
    does: "Print success message."
  ShellRenderer.error:
    kind: method
    sig: (message:str) -> None
    loc: 219-221
    does: "Print error message."
  ShellRenderer.warning:
    kind: method
    sig: (message:str) -> None
    loc: 223-225
    does: "Print warning message."
  ShellRenderer.info:
    kind: method
    sig: (message:str) -> None
    loc: 227-229
    does: "Print info message."
  ShellRenderer.status:
    kind: method
    sig: (icon:str, message:str, type:Literal[info,success,warning,error]='info') -> None
    loc: 231-240
    does: "Print status message with icon."
  ShellRenderer.kv:
    kind: method
    sig: (key:str, value:Any) -> None
    loc: 246-248
    does: "Print key-value pair."
  ShellRenderer.progress:
    kind: method
    sig: (done:int, total:int, label:str='') -> None
    loc: 250-259
    does: "Print progress bar."
  ShellRenderer.separator:
    kind: method
    sig: (char:str='', width:int=60) -> None
    loc: 261-263
    does: "Print separator line."
  ShellRenderer.table:
    kind: method
    sig: (headers:List[str], rows:List[List[Any]], widths:Optional[List[int]]=None) -> None
    loc: 265-284
    does: "Print a simple table."
  ShellRenderer.task:
    kind: method
    sig: (name:str, status:Literal[pending,running,done,failed], duration:Optional[float]=None) -> None
    loc: 286-307
    does: "Print task status."
  ShellRenderer.inline:
    kind: method
    sig: (text:str) -> str
    loc: 309-311
    does: "Return inline code styled text."
  ShellRenderer.print:
    kind: method
    sig: (text:str, color:Optional[str]=None) -> None
    loc: 313-315
    does: "Print raw text with optional color."
  ShellRenderer.newline:
    kind: method
    sig: () -> None
    loc: 317-319
    does: "Print empty line."
  ShellRenderer._highlight_line:
    kind: method
    sig: (line:str, language:str) -> str
    loc: 325-346
    does: "Apply syntax highlighting to a line."
  ShellRenderer._highlight_yaml:
    kind: method
    sig: (line:str) -> str
    loc: 348-381
    does: "Highlight YAML syntax."
  ShellRenderer._highlight_json:
    kind: method
    sig: (line:str) -> str
    loc: 383-409
    does: "Highlight JSON syntax."
  ShellRenderer._highlight_python:
    kind: method
    sig: (line:str) -> str
    loc: 411-443
    does: "Highlight Python syntax."
  ShellRenderer._highlight_bash:
    kind: method
    sig: (line:str) -> str
    loc: 445-463
    does: "Highlight Bash syntax."
  ShellRenderer._highlight_js:
    kind: method
    sig: (line:str) -> str
    loc: 465-493
    does: "Highlight JavaScript/TypeScript syntax."
  ShellRenderer._highlight_gherkin:
    kind: method
    sig: (line:str) -> str
    loc: 495-519
    does: "Highlight Gherkin/BDD syntax."
  ShellRenderer._highlight_log:
    kind: method
    sig: (line:str) -> str
    loc: 521-540
    does: "Highlight log messages."
  ShellRenderer._highlight_markdown:
    kind: method
    sig: (line:str) -> str
    loc: 542-561
    does: "Highlight Markdown syntax."
  ShellRenderer.save_log:
    kind: method
    sig: (filepath:str) -> None
    loc: 563-568
    does: "Save log buffer to file as markdown."
  RenderAPI.heading:
    kind: method
    sig: (level:int, text:str) -> None
    loc: 596-597
    does: "heading"
  RenderAPI.code:
    kind: method
    sig: (lang:Language, content:str) -> None
    loc: 600-601
    does: "code"
  RenderAPI.codeblock:
    kind: method
    sig: (lang:Language, content:str) -> None
    loc: 604-605
    does: "codeblock"
  RenderAPI.markdown:
    kind: method
    sig: (text:str) -> None
    loc: 608-609
    does: "markdown"
  RenderAPI.success:
    kind: method
    sig: (message:str) -> None
    loc: 612-613
    does: "success"
  RenderAPI.error:
    kind: method
    sig: (message:str) -> None
    loc: 616-617
    does: "error"
  RenderAPI.warning:
    kind: method
    sig: (message:str) -> None
    loc: 620-621
    does: "warning"
  RenderAPI.info:
    kind: method
    sig: (message:str) -> None
    loc: 624-625
    does: "info"
  RenderAPI.status:
    kind: method
    sig: (icon:str, message:str, type:Literal[info,success,warning,error]='info') -> None
    loc: 628-630
    does: "status"
  RenderAPI.kv:
    kind: method
    sig: (key:str, value:Any) -> None
    loc: 633-634
    does: "kv"
  RenderAPI.progress:
    kind: method
    sig: (done:int, total:int, label:str='') -> None
    loc: 637-638
    does: "progress"
  RenderAPI.separator:
    kind: method
    sig: (char:str='', width:int=60) -> None
    loc: 641-642
    does: "separator"
  RenderAPI.table:
    kind: method
    sig: (headers:List[str], rows:List[List[Any]], widths:Optional[List[int]]=None) -> None
    loc: 645-647
    does: "table"
  RenderAPI.task:
    kind: method
    sig: (name:str, status:Literal[pending,running,done,failed], duration:Optional[float]=None) -> None
    loc: 650-653
    does: "task"
  RenderAPI.inline:
    kind: method
    sig: (text:str) -> str
    loc: 656-657
    does: "inline"
  RenderAPI.print:
    kind: method
    sig: (text:str, color:Optional[str]=None) -> None
    loc: 660-661
    does: "logs"
  RenderAPI.newline:
    kind: method
    sig: () -> None
    loc: 664-665
    does: "newline"

# toon_format.py | python | 18 functions
functions:
  generate_toon:
    kind: function
    sig: (project:ProjectInfo, detail:str='standard', use_tabs:bool=False) -> str
    loc: 692-705
    does: "Convenience function to generate TOON format."
  parse_toon:
    kind: function
    sig: (content:str) -> Dict[str, Any]
    loc: 708-710
    does: "Convenience function to parse TOON content."
  TOONGenerator.__init__:
    kind: method
    sig: (delimiter:str=',', use_tabs:bool=False) -> None
    loc: 35-46
    does: "Initialize TOON generator."
  TOONGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='standard') -> str
    loc: 48-81
    does: "Generate TOON format from ProjectInfo."
  TOONGenerator._generate_modules:
    kind: method
    sig: (modules:List[ModuleInfo], detail:str) -> List[str]
    loc: 83-156
    does: "Generate modules section."
  TOONGenerator._generate_types:
    kind: method
    sig: (types:List[TypeInfo], indent:int=0) -> List[str]
    loc: 158-189
    does: "Generate module-level types in TOON format (with enum values where available)."
  TOONGenerator._generate_classes:
    kind: method
    sig: (classes:List[ClassInfo], detail:str, indent:int=0) -> List[str]
    loc: 191-243
    does: "Generate classes in TOON format."
  TOONGenerator._generate_methods:
    kind: method
    sig: (methods:List[FunctionInfo], detail:str='standard', indent:int=0) -> List[str]
    loc: 245-271
    does: "Generate methods in tabular TOON format."
  TOONGenerator._generate_functions:
    kind: method
    sig: (functions:List[FunctionInfo], detail:str, indent:int=0) -> List[str]
    loc: 273-302
    does: "Generate functions in tabular TOON format."
  TOONGenerator._build_signature:
    kind: method
    sig: (f:FunctionInfo) -> str
    loc: 304-327
    does: "Build compact signature string without self/cls."
  TOONGenerator._quote:
    kind: method
    sig: (value:Any) -> str
    loc: 329-354
    does: "Quote a value if necessary for TOON format."
  TOONGenerator.generate_compact:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 356-358
    does: "Generate minimal TOON output."
  TOONGenerator.generate_full:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 360-362
    does: "Generate detailed TOON output."
  TOONGenerator.generate_schema:
    kind: method
    sig: (format_type:str='standard') -> str
    loc: 364-515
    does: "Generate JSON Schema for the TOON format."
  TOONGenerator.generate_ultra_compact:
    kind: method
    sig: (project:ProjectInfo) -> str
    loc: 517-573
    does: "Generate minimal TOON with abbreviated keys."
  TOONParser.__init__:
    kind: method
    sig: () -> None
    loc: 584-585
    does: "creates"
  TOONParser.parse:
    kind: method
    sig: (content:str) -> Dict[str, Any]
    loc: 587-659
    does: "Parse TOON content to dict."
  TOONParser._parse_value:
    kind: method
    sig: (value:str) -> Any
    loc: 661-689
    does: "Parse a TOON value to Python type."

# dependency.py | python | 11 functions
functions:
  is_networkx_available:
    kind: function
    sig: () -> bool
    loc: 244-246
    does: "Check if NetworkX is available."
  DependencyAnalyzer.__init__:
    kind: method
    sig: () -> None
    loc: 39-43
    does: "Initialize the dependency analyzer."
  DependencyAnalyzer.build_graph:
    kind: method
    sig: (modules:List[ModuleInfo]) -> Dict[str,List[str]]
    loc: 45-88
    does: "Build dependency graph from modules."
  DependencyAnalyzer.analyze_metrics:
    kind: method
    sig: () -> Dict[str,DependencyNode]
    loc: 90-128
    does: "Compute metrics for each node in the graph."
  DependencyAnalyzer.get_entrypoints:
    kind: method
    sig: () -> List[str]
    loc: 130-139
    does: "Get entry points (nodes with no incoming edges)."
  DependencyAnalyzer.get_hubs:
    kind: method
    sig: () -> List[str]
    loc: 141-149
    does: "Get hub modules (high centrality)."
  DependencyAnalyzer.detect_cycles:
    kind: method
    sig: () -> List[List[str]]
    loc: 151-165
    does: "Detect dependency cycles."
  DependencyAnalyzer.get_strongly_connected_components:
    kind: method
    sig: () -> List[List[str]]
    loc: 167-181
    does: "Get strongly connected components."
  DependencyAnalyzer._detect_clusters:
    kind: method
    sig: () -> Dict[str,int]
    loc: 183-199
    does: "Detect clusters using connected components."
  DependencyAnalyzer._module_name:
    kind: method
    sig: (path:str) -> str
    loc: 201-207
    does: "Convert file path to module name."
  DependencyAnalyzer.get_dependency_depth:
    kind: method
    sig: (module_path:str) -> int
    loc: 209-241
    does: "Get the maximum depth of dependencies for a module."

# mcp_server.py | python | 3 functions
functions:
  handle_request:
    kind: function
    sig: (request:dict) -> dict
    loc: 36-175
    does: "Handle incoming MCP request."
  call_tool:
    kind: function
    sig: (tool_name:str, arguments:dict) -> str
    loc: 178-330
    does: "Execute a tool and return result."
  run_server:
    kind: function
    sig: () -> None
    loc: 333-352
    does: "Run the MCP server."

# reproduction.py | python | 8 functions
functions:
  generate_file_gherkin:
    kind: function
    sig: (file_path:Path) -> str
    loc: 26-222
    does: "Generate detailed Gherkin specification for a single file with types."
  compare_code:
    kind: function
    sig: (original:str, generated:str) -> Dict[str, Any]
    loc: 225-278
    does: "Compare original and generated code."
  extract_code_block:
    kind: function
    sig: (text:str, language:str='python') -> str
    loc: 281-311
    does: "Extract code block from LLM response."
  CodeReproducer.__init__:
    kind: method
    sig: (client:BaseLLMClient=None, provider:str=None) -> None
    loc: 317-324
    does: "Initialize reproducer."
  CodeReproducer.reproduce_file:
    kind: method
    sig: (source_path:str, output_dir:str=None) -> Dict[str, Any]
    loc: 326-363
    does: "Reproduce code from a source file."
  CodeReproducer.generate_from_gherkin:
    kind: method
    sig: (gherkin:str, language:str='python') -> str
    loc: 365-396
    does: "Generate code from Gherkin specification."
  CodeReproducer._save_results:
    kind: method
    sig: (output_dir:Path, results:Dict[str,Any]) -> None
    loc: 398-408
    does: "Save reproduction results to files."
  CodeReproducer._generate_report:
    kind: method
    sig: (results:Dict[str,Any]) -> str
    loc: 410-440
    does: "Generate markdown comparison report."

# gherkin.py | python | 29 functions
functions:
  csv_to_gherkin:
    kind: function
    sig: (csv_content:str, language:str='en') -> str
    loc: 875-940
    does: "Convert CSV analysis directly to Gherkin."
  gherkin_to_test_data:
    kind: function
    sig: (gherkin_content:str) -> Dict[str, Any]
    loc: 943-979
    does: "Extract structured test data from Gherkin for LLM processing."
  GherkinGenerator.__init__:
    kind: method
    sig: (language:str='en') -> None
    loc: 164-173
    does: "Initialize GherkinGenerator."
  GherkinGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='standard', group_by:str='domain') -> str
    loc: 175-189
    does: "Generate Gherkin feature files from project analysis."
  GherkinGenerator.generate_test_scenarios:
    kind: method
    sig: (project:ProjectInfo, group_by:str='domain') -> List[GherkinFeature]
    loc: 191-203
    does: "Generate structured test scenarios for programmatic use."
  GherkinGenerator.get_step_definitions:
    kind: method
    sig: () -> List[StepDefinition]
    loc: 205-207
    does: "Get all unique step definitions from generated features."
  GherkinGenerator._extract_features:
    kind: method
    sig: (project:ProjectInfo, group_by:str) -> List[GherkinFeature]
    loc: 209-259
    does: "Extract Gherkin features from project."
  GherkinGenerator._create_feature:
    kind: method
    sig: (group_name:str, items:List[dict], project:ProjectInfo, group_by:str) -> GherkinFeature
    loc: 261-306
    does: "Create a Gherkin feature from grouped items."
  GherkinGenerator._create_scenario:
    kind: method
    sig: (category:str, items:List[dict], domain:str) -> GherkinScenario
    loc: 308-358
    does: "Create a scenario from category items."
  GherkinGenerator._create_edge_case_scenarios:
    kind: method
    sig: (category:str, items:List[dict]) -> List[GherkinScenario]
    loc: 360-386
    does: "Create edge case scenarios for thorough testing."
  GherkinGenerator._create_when_step:
    kind: method
    sig: (func:FunctionInfo, verb:str) -> str
    loc: 388-403
    does: "Create a When step from function info."
  GherkinGenerator._create_background:
    kind: method
    sig: (domain:str, items:List[dict]) -> Optional[List[str]]
    loc: 405-421
    does: "Create background steps for common setup."
  GherkinGenerator._create_examples_table:
    kind: method
    sig: (items:List[dict]) -> List[Dict[str, str]]
    loc: 423-442
    does: "Create Examples table for Scenario Outline."
  GherkinGenerator._extract_param_placeholders:
    kind: method
    sig: (func:FunctionInfo) -> str
    loc: 444-451
    does: "Extract parameter placeholders for Gherkin steps."
  GherkinGenerator._register_step:
    kind: method
    sig: (step_type:str, pattern:str, func:FunctionInfo) -> None
    loc: 453-466
    does: "Register a step definition for later generation."
  GherkinGenerator._render_features:
    kind: method
    sig: (features:List[GherkinFeature], detail:str) -> str
    loc: 468-482
    does: "Render features to Gherkin text."
  GherkinGenerator._render_feature:
    kind: method
    sig: (feature:GherkinFeature, detail:str) -> str
    loc: 484-511
    does: "Render a single feature."
  GherkinGenerator._render_scenario:
    kind: method
    sig: (scenario:GherkinScenario, detail:str) -> str
    loc: 513-556
    does: "Render a single scenario."
  GherkinGenerator._categorize:
    kind: method
    sig: (name:str) -> str
    loc: 558-577
    does: "Categorize function by name pattern."
  GherkinGenerator._extract_domain:
    kind: method
    sig: (path:str) -> str
    loc: 579-588
    does: "Extract domain from file path."
  GherkinGenerator._name_to_readable:
    kind: method
    sig: (name:str) -> str
    loc: 590-596
    does: "Convert function name to readable text."
  GherkinGenerator._step_to_func_name:
    kind: method
    sig: (step:str) -> str
    loc: 598-602
    does: "Convert step text to valid function name."
  StepDefinitionGenerator.generate_pytest_bdd:
    kind: method
    sig: (features:List[GherkinFeature]) -> str
    loc: 616-677
    does: "Generate pytest-bdd step definitions."
  StepDefinitionGenerator.generate_behave:
    kind: method
    sig: (features:List[GherkinFeature]) -> str
    loc: 679-717
    does: "Generate behave step definitions."
  StepDefinitionGenerator.generate_cucumber_js:
    kind: method
    sig: (features:List[GherkinFeature]) -> str
    loc: 719-761
    does: "Generate Cucumber.js step definitions."
  StepDefinitionGenerator._step_to_func_name:
    kind: method
    sig: (step:str) -> str
    loc: 763-767
    does: "Convert step text to valid function name."
  CucumberYAMLGenerator.generate:
    kind: method
    sig: (project:ProjectInfo, detail:str='standard') -> str
    loc: 777-842
    does: "Generate Cucumber YAML configuration."
  CucumberYAMLGenerator._extract_domain:
    kind: method
    sig: (path:str) -> str
    loc: 844-855
    does: "Extract domain from path."
  CucumberYAMLGenerator._categorize:
    kind: method
    sig: (name:str) -> str
    loc: 857-872
    does: "Categorize by name pattern."

# schemas/logicml_schema.py | python | 3 functions
functions:
  validate_logicml:
    kind: function
    sig: (spec:str) -> Tuple[bool, List[str]]
    loc: 111-206
    does: "Validate LogicML specification."
  parse_logicml_header:
    kind: function
    sig: (line:str) -> Optional[Dict[str, Any]]
    loc: 209-219
    does: "Parse LogicML header comment."
  extract_logicml_signature:
    kind: function
    sig: (sig_line:str) -> Dict[str, Any]
    loc: 222-250
    does: "Extract signature components from LogicML sig: line."

# schemas/yaml_schema.py | python | 3 functions
functions:
  validate_yaml:
    kind: function
    sig: (spec:str) -> Tuple[bool, List[str]]
    loc: 94-148
    does: "Validate YAML specification."
  _validate_module:
    kind: function
    sig: (module:Dict, index:int) -> List[str]
    loc: 151-183
    does: "Validate a module definition."
  _validate_class:
    kind: function
    sig: (cls:Dict, prefix:str) -> List[str]
    loc: 186-214
    does: "Validate a class definition."

# schemas/json_schema.py | python | 4 functions
functions:
  validate_json:
    kind: function
    sig: (spec:str) -> Tuple[bool, List[str]]
    loc: 110-143
    does: "Validate JSON specification."
  _validate_json_module:
    kind: function
    sig: (module:Dict, index:int) -> List[str]
    loc: 146-171
    does: "Validate a JSON module definition."
  _validate_json_class:
    kind: function
    sig: (cls:Dict, prefix:str) -> List[str]
    loc: 174-195
    does: "Validate a JSON class definition."
  parse_json_spec:
    kind: function
    sig: (spec:str) -> Optional[JSONSchema]
    loc: 198-257
    does: "Parse JSON specification into schema."

# schemas/markdown_schema.py | python | 2 functions
functions:
  validate_markdown:
    kind: function
    sig: (spec:str) -> Tuple[bool, List[str]]
    loc: 89-150
    does: "Validate Markdown specification."
  extract_markdown_sections:
    kind: function
    sig: (spec:str) -> Dict[str, Any]
    loc: 153-174
    does: "Extract sections from Markdown specification."

# benchmarks/common.py | python | 8 functions
functions:
  create_single_project:
    kind: function
    sig: (module_info, file_path:Path) -> ProjectInfo
    loc: 15-28
    does: "creates single project"
  generate_spec:
    kind: function
    sig: (project:ProjectInfo, fmt:str) -> str
    loc: 31-52
    does: "creates spec"
  _generate_token_json:
    kind: function
    sig: (project:ProjectInfo) -> str
    loc: 55-108
    does: "Generate compact, token-friendly JSON spec (used by examples/11_token_benchmark...."
  _generate_token_json_compact:
    kind: function
    sig: (project:ProjectInfo) -> str
    loc: 111-113
    does: "creates token json compact"
  generate_spec_token:
    kind: function
    sig: (project:ProjectInfo, fmt:str) -> str
    loc: 116-127
    does: "Generate spec optimized for token benchmark (keeps historical behavior)."
  get_async_reproduction_prompt:
    kind: function
    sig: (spec:str, fmt:str, file_name:str, with_tests:bool=False) -> str
    loc: 130-174
    does: "retrieves async reproduction prompt"
  get_token_reproduction_prompt:
    kind: function
    sig: (spec:str, fmt:str, file_name:str) -> str
    loc: 177-226
    does: "retrieves token reproduction prompt"
  get_simple_reproduction_prompt:
    kind: function
    sig: (spec:str, fmt:str, file_name:str) -> str
    loc: 229-258
    does: "retrieves simple reproduction prompt"

# benchmarks/runner.py | python | 15 functions
functions:
  _test_python_syntax:
    kind: function
    sig: (code:str) -> bool
    loc: 43-49
    does: "Test if Python code has valid syntax."
  _test_python_runs:
    kind: function
    sig: (code:str, timeout:int=5) -> bool
    loc: 52-67
    does: "Test if Python code runs without errors."
  _extract_code:
    kind: function
    sig: (response:str) -> str
    loc: 70-86
    does: "Extract code from LLM response."
  run_benchmark:
    kind: function
    sig: (source:str, benchmark_type:str='format', formats:List[str]=None, limit:Optional[int]=None, output:Optional[str]=None, verbose:bool=False) -> BenchmarkResult
    loc: 782-824
    does: "Convenience function to run benchmarks."
  BenchmarkRunner.__init__:
    kind: method
    sig: (client:Optional[BaseLLMClient]=None, config:Optional[BenchmarkConfig]=None) -> None
    loc: 97-111
    does: "Initialize benchmark runner."
  BenchmarkRunner._should_use_llm:
    kind: method
    sig: () -> bool
    loc: 113-115
    does: "Return whether this runner should call an LLM."
  BenchmarkRunner._get_client:
    kind: method
    sig: () -> BaseLLMClient
    loc: 117-123
    does: "Get or create LLM client."
  BenchmarkRunner._template_generate_code:
    kind: method
    sig: (spec:str, fmt:str, file_name:str) -> str
    loc: 125-182
    does: "Generate minimal Python code without an LLM (fallback mode)."
  BenchmarkRunner.run_format_benchmark:
    kind: method
    sig: (folder:str, formats:List[str]=None, limit:Optional[int]=None, verbose:bool=False) -> BenchmarkResult
    loc: 184-292
    does: "Run format comparison benchmark."
  BenchmarkRunner._test_format:
    kind: method
    sig: (project, original:str, fmt:str, file_name:str, client:Optional[BaseLLMClient], verbose:bool=False) -> FormatResult
    loc: 294-354
    does: "Test a single format."
  BenchmarkRunner.run_file_benchmark:
    kind: method
    sig: (file_path:str, formats:List[str]=None, verbose:bool=False) -> BenchmarkResult
    loc: 356-454
    does: "Run benchmark on a single file."
  BenchmarkRunner.run_function_benchmark:
    kind: method
    sig: (file_path:str, function_names:List[str]=None, limit:Optional[int]=None, verbose:bool=False) -> BenchmarkResult
    loc: 456-527
    does: "Run function-level reproduction benchmark."
  BenchmarkRunner._test_function:
    kind: method
    sig: (func, content:str, language:str, file_path:Path, client:Optional[BaseLLMClient], verbose:bool=False) -> FunctionResult
    loc: 529-617
    does: "Test reproduction of a single function."
  BenchmarkRunner.run_project_benchmark:
    kind: method
    sig: (project_path:str, formats:List[str]=None, limit:Optional[int]=None, verbose:bool=False) -> BenchmarkResult
    loc: 619-716
    does: "Run benchmark on entire project."
  BenchmarkRunner._reproduce_module:
    kind: method
    sig: (module_info, fmt:str, project_root:str, client:Optional[BaseLLMClient], verbose:bool=False) -> FileResult
    loc: 718-779
    does: "Reproduce a single module."

# benchmarks/results.py | python | 10 functions
functions:
  FormatResult.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 48-49
    does: "converts dict"
  FileResult.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 76-79
    does: "converts dict"
  FunctionResult.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 101-102
    does: "converts dict"
  BenchmarkResult.__post_init__:
    kind: method
    sig: () -> None
    loc: 141-143
    does: "creates init"
  BenchmarkResult.calculate_aggregates:
    kind: method
    sig: () -> None
    loc: 145-168
    does: "Calculate aggregate metrics from detailed results."
  BenchmarkResult.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 170-175
    does: "converts dict"
  BenchmarkResult.to_json:
    kind: method
    sig: (indent:int=2) -> str
    loc: 177-178
    does: "converts json"
  BenchmarkResult.save:
    kind: method
    sig: (path:str) -> None
    loc: 180-183
    does: "Save result to JSON file."
  BenchmarkResult.load:
    kind: method
    sig: (path:str) -> 'BenchmarkResult'
    loc: 186-198
    does: "Load result from JSON file."
  BenchmarkConfig.to_dict:
    kind: method
    sig: () -> Dict[str, Any]
    loc: 228-229
    does: "converts dict"
