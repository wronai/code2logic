# multilang_reproduction_tester.py | Language, ElementType, Severity +10 | 1751 lines

imports:
  stdlib: [json, re, abc.{ABC,abstractmethod}, collections.defaultdict, dataclasses.{dataclass,field}, enum.{Enum,auto}, pathlib.Path, typing.{Any,Dict,List,Optional,Set}]
  third_party: [yaml]

Language:
  doc: "Obsługiwane języki programowania."
  bases: [Enum]

ElementType:
  doc: "Typy elementów kodu."
  bases: [Enum]

Severity:
  doc: "Poziom ważności brakującej informacji."
  bases: [Enum]

ValidationIssue:
  doc: "Problem znaleziony podczas walidacji."

LanguageFeature:
  doc: "Cecha języka programowania."

ValidationResult:
  doc: "Wynik walidacji formatu."
  methods:
    validity_percent:
      sig: @property () -> float
      does: "validity percent"
      decorators: [property]

LanguageRequirements:
  doc: "Wymagania dla danego języka."

FormatValidator:
  doc: "Bazowa klasa walidatora formatu."
  bases: [ABC]
  abstract: true
  attrs:
    content: str
    language: Language
  methods:
    __init__:
      sig: (content:str, language:Language) -> None
      does: "creates"
    parse:
      sig: () -> Dict[str, Any]
      does: "Parsuj zawartość formatu."
      decorators: [abstractmethod]
    validate:
      sig: () -> ValidationResult
      does: "Waliduj format i zwróć wynik."
      decorators: [abstractmethod]
    _check_signature:
      sig: (sig:str, func_name:str) -> List[ValidationIssue]
      does: "Sprawdź czy sygnatura jest kompletna."
      side: "Modifies list"
    _check_constant:
      sig: (const:Dict[str,Any]) -> List[ValidationIssue]
      does: "Sprawdź czy stała ma wymagane informacje."
      side: "Modifies list"
    _check_enum:
      sig: (enum_data:Dict[str,Any]) -> List[ValidationIssue]
      does: "Sprawdź czy enum ma wartości."
      side: "Modifies list"
    _check_class:
      sig: (cls_data:Dict[str,Any]) -> List[ValidationIssue]
      does: "Sprawdź klasę pod kątem kompletności."
      side: "Modifies list"

YAMLValidator:
  doc: "Walidator dla formatu YAML."
  bases: [FormatValidator]
  attrs:
    content: str
    language: Language
  methods:
    __init__:
      sig: (content:str, language:Language) -> None
      does: "creates"
    parse:
      sig: () -> Dict[str, Any]
      does: "Parsuj YAML."
      side: "Modifies list"
    validate:
      sig: () -> ValidationResult
      does: "Waliduj format YAML."

HybridYAMLValidator:
  doc: "Walidator dla formatu Hybrid YAML."
  bases: [YAMLValidator]
  methods:
    validate:
      sig: () -> ValidationResult
      does: "Waliduj format Hybrid YAML."
      side: "Modifies list"

TOONValidator:
  doc: "Walidator dla formatu TOON."
  bases: [FormatValidator]
  methods:
    parse:
      sig: () -> Dict[str, Any]
      does: "Parsuj TOON (ultra-compact M/D or standard TOON)."
    _detect_delimiter:
      sig: () -> str
      does: "detect delimiter"
    _strip_quotes:
      sig: (s:str) -> str
      does: "strip quotes"
    _parse_ultra_compact:
      sig: () -> Dict[str, Any]
      does: "Parsuj ultra-compact TOON (M/D)."
      side: "Modifies list"
    _parse_standard:
      sig: () -> Dict[str, Any]
      does: "Parsuj standard TOON w wersji generowanej przez code2logi..."
      side: "Modifies list"
    _parse_detail_line:
      sig: (line:str, module_data:Dict) -> None
      does: "Parsuj linię szczegółów modułu."
      side: "Modifies list"
    validate:
      sig: () -> ValidationResult
      does: "Waliduj format TOON."
      side: "Modifies list"

MultiLanguageReproductionTester:
  doc: "Tester reprodukowalności dla wielu języków."
  methods:
    __init__:
      sig: () -> None
      does: "creates"
    test_format:
      sig: (content:str, format_type:str, language:Language) -> ValidationResult
      does: "Testuj pojedynczy format dla danego języka."
      edge: "error → raise ValueError"
    test_all_formats:
      sig: (yaml_content:str, hybrid_content:str, toon_content:str, language:Language) -> Dict[str, ValidationResult]
      does: "Testuj wszystkie formaty dla danego języka."
    generate_report:
      sig: () -> str
      does: "Generuj raport porównawczy."
      side: "Modifies list"
    generate_language_specific_recommendations:
      sig: (language:Language) -> List[str]
      does: "Generuj rekomendacje specyficzne dla języka."
      side: "Modifies list"

ReproductionScorer:
  doc: "System oceny reprodukowalności."
  methods:
    calculate_score:
      sig: (result:ValidationResult, language:Language) -> float
      does: "Oblicz szczegółowy score reprodukcji."
      decorators: [classmethod]
    get_improvement_priorities:
      sig: (result:ValidationResult) -> List[Tuple[str, float, str]]
      does: "Zwróć priorytety ulepszeń (nazwa, potencjalny zysk, opis)."
      side: "Modifies list"
      decorators: [classmethod]

functions:
  run_tests:
    sig: (yaml_path:str=None, hybrid_path:str=None, toon_path:str=None) -> None
    does: "Uruchom testy reprodukowalności."
  main:
    sig: () -> None
    does: "Główna funkcja CLI."
    side: "Adds element"

# universal_validator.py | LanguageConfig, LanguagePatterns, ValidationIssue +3 | 1287 lines

imports:
  stdlib: [argparse, json, re, sys, abc.{ABC,abstractmethod}, collections.defaultdict, dataclasses.{dataclass,field}, enum.{Enum,auto}, pathlib.Path, typing.{Any,Callable,Dict}]
  third_party: [yaml]

LanguageConfig:
  doc: "Konfiguracja wymagań dla każdego języka."
  methods:
    get:
      sig: (language:str) -> dict
      does: "Pobierz konfigurację dla języka."
      decorators: [classmethod]
    supported_languages:
      sig: () -> List[str]
      does: "Lista obsługiwanych języków."
      decorators: [classmethod]

LanguagePatterns:
  doc: "Wzorce regex i walidatory dla każdego języka."
  methods:
    get:
      sig: (language:str) -> dict
      does: "Pobierz wzorce dla języka."
      decorators: [classmethod]

ValidationIssue:
  doc: "Problem znaleziony podczas walidacji."

ValidationReport:
  doc: "Raport z walidacji."

UniversalValidator:
  doc: "Uniwersalny walidator formatów Code2Logic."
  attrs:
    content: str
    format_type: str
    language: str
  methods:
    __init__:
      sig: (content:str, format_type:str, language:str) -> None
      does: "creates"
    parse:
      sig: () -> Dict[str, Any]
      does: "Parsuj zawartość formatu."
      side: "Modifies list"
    _parse_toon:
      sig: () -> Dict[str, Any]
      does: "Parsuj format TOON."
    validate:
      sig: () -> ValidationReport
      does: "Przeprowadź pełną walidację."
    _validate_module:
      sig: (module:Dict) -> List[ValidationIssue]
      does: "Waliduj pojedynczy moduł."
    _validate_constant:
      sig: (const:Dict) -> List[ValidationIssue]
      does: "Waliduj stałą."
      side: "Modifies list"
    _validate_class:
      sig: (cls:Dict) -> List[ValidationIssue]
      does: "Waliduj klasę."
      side: "Modifies list"
    _validate_function:
      sig: (func:Dict) -> List[ValidationIssue]
      does: "Waliduj funkcję."
    _validate_signature:
      sig: (sig:str, name:str) -> List[ValidationIssue]
      does: "Waliduj sygnaturę funkcji/metody."
      side: "Modifies list"
    _validate_interface:
      sig: (iface:Dict) -> List[ValidationIssue]
      does: "Waliduj interfejs (TS, Java, C#, Go)."
      side: "Modifies list"
    _validate_trait:
      sig: (trait:Dict) -> List[ValidationIssue]
      does: "Waliduj trait (Rust, PHP)."
      side: "Modifies list"
    _validate_struct:
      sig: (struct:Dict) -> List[ValidationIssue]
      does: "Waliduj struct (Go, Rust, Swift, C#)."
      side: "Modifies list"
    _validate_language_specific:
      sig: () -> List[ValidationIssue]
      does: "Waliduj elementy specyficzne dla języka."
      side: "Modifies list"
    _calculate_language_coverage:
      sig: () -> Dict[str, float]
      does: "Oblicz pokrycie elementów specyficznych dla języka."
    _generate_recommendations:
      sig: () -> List[str]
      does: "Generuj rekomendacje ulepszeń."
      side: "Modifies list"

FormatComparator:
  doc: "Porównuje wyniki walidacji między formatami."
  methods:
    __init__:
      sig: () -> None
      does: "creates"
    add_result:
      sig: (language:str, format_type:str, report:ValidationReport) -> None
      does: "Dodaj wynik walidacji."
      side: "Adds element"
    compare:
      sig: () -> str
      does: "Generuj porównanie formatów."
      side: "Modifies list"
    get_best_format:
      sig: (language:str) -> Optional[str]
      does: "Zwróć najlepszy format dla danego języka."

functions:
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# reproduction_test_code.py | QualityResult, FormatStats, ReproducedFromTOON +3 | 902 lines

imports:
  stdlib: [hashlib, re, dataclasses.dataclass, pathlib.Path, typing.{Any,Dict,List,Optional,Tuple}]
  third_party: [csv, gzip]

QualityResult:

FormatStats:
  methods:
    gzip_ratio:
      sig: @property () -> float
      does: "gzip ratio"
      decorators: [property]

ReproducedFromTOON:
  doc: "Reprodukcja z TOON - ~55% poprawności (PO NAPRAWIE)"

ReproducedFromYAML:
  doc: "Reprodukcja z YAML - ~75% poprawności (PO NAPRAWIE)"

ReproducedFromHybrid:
  doc: "Reprodukcja z Hybrid YAML - ~85% poprawności (PO NAPRAWIE)"

IdealReproduction:
  doc: "Jak powinien wyglądać format dla ~90% reprodukcji"

functions:
  detect_signature_quality:
    sig: (signature_block:str) -> Tuple[dict, List[str]]
    does: "Check if signature block contains parameters with defaults."
    side: "Modifies list"
  detect_constant_quality:
    sig: (constants_block:str) -> Tuple[dict, List[str]]
    does: "Check if constant block contains values or only names."
    side: "Modifies list"
  compute_quality_score:
    sig: (name:str, sig_block:str, const_block:str) -> QualityResult
    does: "processes quality score"
  format_quality_summary:
    sig: (result:QualityResult) -> str
    does: "formats quality summary"
  evaluate_formats:
    sig: () -> List[QualityResult]
    does: "Run heuristic quality detection for each reproduction sec..."
  print_quality_report:
    sig: () -> None
    does: "logs quality report"
  _read_text:
    sig: (path:Path) -> str
    does: "retrieves text"
  _basic_text_stats:
    sig: (format_name:str, content:str) -> FormatStats
    does: "basic text stats"
  _extract_yaml_modules:
    sig: (data:Any) -> List[Dict[str, Any]]
    does: "parses yaml modules"
  _extract_yaml_signatures_from_module:
    sig: (module:Dict[str,Any]) -> List[str]
    does: "parses yaml signatures from module"
    side: "Modifies list"
  _extract_yaml_constants_from_module:
    sig: (module:Dict[str,Any]) -> List[Dict[str, Any]]
    does: "parses yaml constants from module"
  _count_yaml_dataclass_fields:
    sig: (module:Dict[str,Any]) -> int
    does: "count yaml dataclass fields"
  analyze_yaml_like:
    sig: (format_name:str, content:str) -> FormatStats
    does: "processes yaml like"
  analyze_toon:
    sig: (format_name:str, content:str) -> FormatStats
    does: "processes toon"
  _pct:
    sig: (part:int, whole:int) -> float
    does: "pct"
  print_detailed_format_comparison:
    sig: () -> None
    does: "logs detailed format comparison"
    side: "Modifies list"

# unify_generators.py | 28 lines
# Re-export module
type: re-export
exports:
  - re
  - pathlib.Path

# analyzer.py | ProjectAnalyzer | 57 lines

imports:
  stdlib: [typing.{Any,Dict,List,Optional}]

ProjectAnalyzer:
  doc: "Main class for analyzing software projects."
  attrs:
    root_path: Any
    verbose: Any
    include_private: Any
    modules: List
    languages: Any
    ts_parser: Any
    fallback_parser: Any
    dep_analyzer: Any
    sim_detector: Any
  methods:
    __init__:
      sig: (root_path:str, use_treesitter:bool=True, verbose:bool=False, include_private:bool=False) -> None
      does: "creates"
      edge: "error → raise NotImplementedError"
    _print_status:
      sig: () -> None
      does: "logs status"
      edge: "error → raise NotImplementedError"
    analyze:
      sig: () -> ProjectInfo
      does: "processes"
      edge: "error → raise NotImplementedError"
    _scan_files:
      sig: () -> None
      does: "scan files"
      edge: "error → raise NotImplementedError"
    _detect_entrypoints:
      sig: () -> List[str]
      does: "detect entrypoints"
      edge: "error → raise NotImplementedError"
    get_statistics:
      sig: () -> Dict
      does: "retrieves statistics"
      edge: "error → raise NotImplementedError"

functions:
  analyze_project:
    sig: (path:str, use_treesitter:bool=True, verbose:bool=False) -> ProjectInfo
    does: "processes project"
    edge: "error → raise NotImplementedError"
  get_library_status:
    sig: () -> Dict[str, bool]
    does: "retrieves library status"
    edge: "error → raise NotImplementedError"

# __init__.py | 11 lines
# Re-export module
type: re-export
exports:
  - analyzer.ProjectAnalyzer
  - analyzer.analyze_project
  - analyzer.get_library_status

# llm_profiler.py | LLMProfile, ProfileTestResult, LLMProfiler +1 | 649 lines

imports:
  stdlib: [datetime, hashlib, json, time, dataclasses.{asdict,dataclass,field}, pathlib.Path, typing.{Any,Optional}]
  third_party: [difflib.SequenceMatcher, utils.estimate_tokens]

LLMProfile:
  doc: "Profile of LLM capabilities for code reproduction."
  methods:
    __post_init__:
      sig: () -> None
      does: "creates init"

ProfileTestResult:
  doc: "Result of a single profile test."

LLMProfiler:
  doc: "Profile LLM capabilities for code reproduction."
  attrs:
    client: Any
    verbose: bool=True
  methods:
    __init__:
      sig: (client, verbose:bool=True) -> None
      does: "Initialize profiler."
    run_profile:
      sig: (quick:bool=False) -> LLMProfile
      does: "Run full profiling suite."
      side: "Modifies list"
    _test_reproduction:
      sig: (name:str, code:str) -> ProfileTestResult
      does: "Test reproduction of a code snippet."
    _code_to_spec:
      sig: (code:str) -> str
      does: "Convert code to simple YAML spec."
      side: "Modifies list"
    _extract_code:
      sig: (response:str) -> str
      does: "Extract code from LLM response."
    _check_syntax:
      sig: (code:str) -> bool
      does: "Check if code has valid Python syntax."
    _calculate_similarity:
      sig: (original:str, reproduced:str) -> float
      does: "Calculate code similarity."
    _calculate_metrics:
      sig: (profile:LLMProfile, results:list[ProfileTestResult]) -> LLMProfile
      does: "Calculate aggregate metrics from test results."
    _test_consistency:
      sig: (profile:LLMProfile) -> LLMProfile
      does: "Test output consistency by running same prompt twice."

AdaptiveChunker:
  doc: "Adaptive chunking based on LLM profile."
  attrs:
    profile: Optional[LLMProfile]=None
  methods:
    __init__:
      sig: (profile:Optional[LLMProfile]=None) -> None
      does: "Initialize chunker."
    get_optimal_settings:
      sig: () -> dict[str, Any]
      does: "Get optimal settings for the profiled model."
      side: "Sets value"
    chunk_spec:
      sig: (spec:str, format:str='yaml') -> list[dict[str, Any]]
      does: "Chunk specification based on profile."
      side: "Modifies list"
    recommend_format:
      sig: (spec_size_tokens:int) -> str
      does: "Recommend best format based on spec size and model."
    estimate_chunks_needed:
      sig: (spec_size_tokens:int) -> int
      does: "Estimate number of chunks needed."

functions:
  _get_profiles_path:
    sig: () -> Path
    does: "Get path to profiles storage."
  load_profiles:
    sig: () -> dict[str, LLMProfile]
    does: "Load all saved profiles."
  save_profile:
    sig: (profile:LLMProfile) -> None
    does: "Save a profile to storage."
    side: "Saves data"
  get_profile:
    sig: (provider:str, model:str) -> Optional[LLMProfile]
    does: "Get profile for a specific model."
  get_or_create_profile:
    sig: (provider:str, model:str) -> LLMProfile
    does: "Get existing profile or create default one."
  _create_default_profile:
    sig: (provider:str, model:str) -> LLMProfile
    does: "Create default profile based on model characteristics."
  profile_llm:
    sig: (client, quick:bool=False) -> LLMProfile
    does: "Profile an LLM client."
  get_adaptive_chunker:
    sig: (provider:str, model:str) -> AdaptiveChunker
    does: "Get adaptive chunker for a model."

# config.py | Config | 249 lines

imports:
  stdlib: [json, os, pathlib.Path, typing.{Any,Dict,Optional}]

Config:
  doc: "Configuration manager for Code2Logic."
  attrs:
    env_file: str=None
  methods:
    __init__:
      sig: (env_file:str=None) -> None
      does: "Initialize configuration."
    _load_env_file:
      sig: (env_file:str=None) -> None
      does: "Load environment variables from .env file."
    _parse_env_file:
      sig: (path:Path) -> None
      does: "Parse .env file and set environment variables."
    _load_config_file:
      sig: () -> None
      does: "Load configuration from JSON file."
    get_api_key:
      sig: (provider:str) -> Optional[str]
      does: "Get API key for a provider."
    get_model:
      sig: (provider:str) -> str
      does: "Get model for a provider."
    get_ollama_host:
      sig: () -> str
      does: "Get Ollama host URL."
    get_default_provider:
      sig: () -> str
      does: "Get default LLM provider."
    is_verbose:
      sig: () -> bool
      does: "Check if verbose mode is enabled."
    get_project_name:
      sig: () -> str
      does: "Get default project name for output files."
    get_cache_dir:
      sig: () -> Path
      does: "Get cache directory path."
    list_configured_providers:
      sig: () -> Dict[str, bool]
      does: "List all providers and their configuration status."
    to_dict:
      sig: () -> Dict[str, Any]
      does: "Export configuration as dictionary."

functions:
  load_env:
    sig: () -> None
    does: "Load environment variables from .env file."
  get_api_key:
    sig: (provider:str) -> Optional[str]
    does: "Convenience function to get API key."
  get_model:
    sig: (provider:str) -> str
    does: "Convenience function to get model."

# file_formats.py | 352 lines

imports:
  stdlib: [json, pathlib.Path, typing.{Any,Dict}]

functions:
  generate_file_csv:
    sig: (file_path:Path) -> str
    does: "Generate detailed CSV specification for a single file."
    side: "Modifies list"
  generate_file_json:
    sig: (file_path:Path) -> str
    does: "Generate detailed JSON specification for a single file."
    side: "Modifies list"
  generate_file_yaml:
    sig: (file_path:Path) -> str
    does: "Generate detailed YAML specification for a single file."
    side: "Modifies list"
  _parse_file_elements:
    sig: (content:str) -> Dict[str, Any]
    does: "Parse file content to extract code elements."
    side: "Modifies list"

# project_reproducer.py | FileResult, ProjectResult, ProjectReproducer | 397 lines

imports:
  stdlib: [datetime, json, dataclasses.{asdict,dataclass,field}, pathlib.Path, typing.{Dict,List,Optional,Set}]
  third_party: [concurrent.futures.{ThreadPoolExecutor,as_completed}, dotenv.load_dotenv, llm_clients.{BaseLLMClient,get_client}, universal.{Language,UniversalParser,UniversalReproducer}]

FileResult:
  doc: "Result for a single file reproduction."

ProjectResult:
  doc: "Result for project reproduction."

ProjectReproducer:
  doc: "Multi-file project reproduction system."
  attrs:
    client: BaseLLMClient=None
    max_workers: int=4
    target_lang: str=None
    use_llm: bool=True
  methods:
    __init__:
      sig: (client:BaseLLMClient=None, max_workers:int=4, target_lang:str=None, use_llm:bool=True) -> None
      does: "Initialize project reproducer."
    _get_client:
      sig: () -> BaseLLMClient
      does: "Get or create LLM client."
    find_source_files:
      sig: (project_path:str, extensions:Set[str]=None, exclude_patterns:List[str]=None) -> List[Path]
      does: "Find all source files in project."
      side: "Sets value"
    reproduce_file:
      sig: (file_path:Path, output_dir:Path) -> FileResult
      does: "Reproduce a single file."
    reproduce_project:
      sig: (project_path:str, output_dir:str=None, parallel:bool=False) -> ProjectResult
      does: "Reproduce entire project."
      side: "Modifies list"
    _aggregate_results:
      sig: (project_path:str, results:List[FileResult]) -> ProjectResult
      does: "Aggregate file results into project result."
    _save_report:
      sig: (output_dir:Path, result:ProjectResult) -> None
      does: "Save project reproduction report."
      side: "Saves data"

functions:
  reproduce_project:
    sig: (project_path:str, output_dir:str=None, target_lang:str=None, parallel:bool=False, use_llm:bool=True) -> ProjectResult
    does: "Convenience function for project reproduction."

# base.py | VerboseMixin, BaseParser, BaseGenerator | 69 lines

imports:
  stdlib: [logging]

VerboseMixin:
  doc: "Mixin providing verbose logging functionality."
  attrs:
    verbose: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
      side: "Sets value"
    log:
      sig: (msg:str, level:str='info') -> None
      does: "Log message if verbose mode enabled."
    debug:
      sig: (msg:str) -> None
      does: "Log debug message."
    info:
      sig: (msg:str) -> None
      does: "Log info message."
    warn:
      sig: (msg:str) -> None
      does: "Log warning message."
    error:
      sig: (msg:str) -> None
      does: "Log error message."

BaseParser:
  doc: "Base class for code parsers."
  bases: [VerboseMixin]
  attrs:
    verbose: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    parse:
      sig: (content:str, language:str=None) -> None
      does: "Parse source code content."
      edge: "error → raise NotImplementedError"
    parse_file:
      sig: (path:str) -> None
      does: "Parse source file."
      edge: "error → raise NotImplementedError"

BaseGenerator:
  doc: "Base class for output generators."
  bases: [VerboseMixin]
  attrs:
    verbose: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    generate:
      sig: (project, detail:str='full') -> str
      does: "Generate output from project analysis."
      edge: "error → raise NotImplementedError"

# cli.py | Colors, Logger | 1116 lines

imports:
  stdlib: [argparse, datetime, json, os, subprocess, sys, time]
  third_party: [__version__, signal]

Colors:

Logger:
  doc: "Enhanced logger for CLI output."
  attrs:
    verbose: bool=False
    debug: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False, debug:bool=False) -> None
      does: "creates"
    _elapsed:
      sig: () -> str
      does: "Get elapsed time string."
    info:
      sig: (msg:str) -> None
      does: "Print info message."
    success:
      sig: (msg:str) -> None
      does: "Print success message."
    warning:
      sig: (msg:str) -> None
      does: "Print warning message."
    error:
      sig: (msg:str) -> None
      does: "Print error message."
    step:
      sig: (msg:str) -> None
      does: "Print step message with counter."
    detail:
      sig: (msg:str) -> None
      does: "Print detail message (only in verbose mode)."
    debug_msg:
      sig: (msg:str) -> None
      does: "Print debug message (only in debug mode)."
    stats:
      sig: (label:str, value) -> None
      does: "Print statistics."
    separator:
      sig: () -> None
      does: "Print separator line."
    header:
      sig: (msg:str) -> None
      does: "Print header."

functions:
  ensure_dependencies:
    sig: () -> None
    does: "Auto-install optional dependencies for best results."
    side: "Modifies list"
  _get_env_file_path:
    sig: () -> str
    does: "retrieves env file path"
  _read_text_file:
    sig: (path:str) -> str
    does: "retrieves text file"
  _write_text_file:
    sig: (path:str, content:str) -> None
    does: "logs text file"
    side: "Writes data"
  _set_env_var:
    sig: (var_name:str, value:str) -> str
    does: "updates env var"
    side: "Sets value"
  _unset_env_var:
    sig: (var_name:str) -> str
    does: "unset env var"
    side: "Sets value"
  _get_litellm_config_path:
    sig: () -> str
    does: "retrieves litellm config path"
  _get_user_llm_config_path:
    sig: () -> str
    does: "retrieves user llm config path"
  _load_user_llm_config:
    sig: () -> dict
    does: "retrieves user llm config"
  _save_user_llm_config:
    sig: (data:dict) -> str
    does: "caches user llm config"
    side: "Saves data"
  _load_litellm_yaml:
    sig: () -> dict
    does: "retrieves litellm yaml"
    edge: "error → raise RuntimeError"
    edge: "error → raise FileNotFoundError"
  _save_litellm_yaml:
    sig: (data:dict) -> str
    does: "caches litellm yaml"
    edge: "error → raise RuntimeError"
    side: "Saves data"
  _infer_provider_from_litellm_model:
    sig: (litellm_model:str) -> str
    does: "infer provider from litellm model"
  _code2logic_llm_cli:
    sig: (argv:list[str]) -> None
    does: "code2logic llm cli"
    side: "Adds element"
  main:
    sig: () -> None
    does: "Main CLI entry point."
    side: "Adds element"

# llm.py | LLMConfig, CodeAnalyzer | 374 lines

imports:
  stdlib: [json, os, dataclasses.dataclass, typing.{Any,Optional}]
  third_party: [importlib.util.find_spec, llm_clients.{LiteLLMClient,OllamaLocalClient,OpenRouterClient,get_client}]

LLMConfig:
  doc: "Configuration for LLM backend."

CodeAnalyzer:
  doc: "LLM-powered code analysis for Code2Logic."
  attrs:
    model: str=None
    provider: str=None
    base_url: str=None
    api_key: str=None
  methods:
    __init__:
      sig: (model:str=None, provider:str=None, base_url:str=None, api_key:str=None) -> None
      does: "Initialize CodeAnalyzer."
    is_available:
      sig: () -> bool
      does: "Check if LLM backend is available."
    suggest_refactoring:
      sig: (project) -> list[dict[str, Any]]
      does: "Analyze project and suggest refactoring improvements."
    find_semantic_duplicates:
      sig: (project) -> list[dict[str, Any]]
      does: "Find semantically similar functions using LLM."
      side: "Modifies list"
    generate_code:
      sig: (project, target_lang:str, module_filter:Optional[str]=None) -> dict[str, str]
      does: "Generate code in target language from project analysis."
      side: "Modifies list"
    translate_function:
      sig: (name:str, signature:str, intent:str, source_lang:str, target_lang:str) -> str
      does: "Translate a single function to another language."
    _build_signature:
      sig: (f) -> str
      does: "Build compact signature."

functions:
  get_available_backends:
    sig: () -> dict[str, bool]
    does: "Get availability status of LLM backends."

# errors.py | ErrorSeverity, ErrorType, AnalysisError +2 | 437 lines

imports:
  stdlib: [logging, dataclasses.{dataclass,field}, enum.Enum, pathlib.Path, typing.{Any,Callable,Dict,List,Optional}]

ErrorSeverity:
  doc: "Error severity levels."
  bases: [Enum]

ErrorType:
  doc: "Types of errors that can occur during analysis."
  bases: [Enum]

AnalysisError:
  doc: "Represents an error during analysis."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"

AnalysisResult:
  doc: "Result of analysis with errors tracked."
  methods:
    add_error:
      sig: (error:AnalysisError) -> None
      does: "Add an error to the result."
      side: "Adds element"
    has_errors:
      sig: () -> bool
      does: "has errors"
    summary:
      sig: () -> str
      does: "Generate error summary."
      side: "Modifies list"

ErrorHandler:
  doc: "Handles errors during analysis with configurable behavior."
  attrs:
    mode: str='lenient'
    max_file_size_mb: float=10.0
    timeout_seconds: float=30.0
    logger: Optional[Any]=None
  methods:
    __init__:
      sig: (mode:str='lenient', max_file_size_mb:float=10.0, timeout_seconds:float=30.0, logger:Optional[Any]=None) -> None
      does: "creates"
    reset:
      sig: () -> None
      does: "Reset error state for new analysis."
      side: "Sets value"
    handle_error:
      sig: (error_type:ErrorType, path:str, message:str, exception:Optional[Exception]=None, severity:Optional[ErrorSeverity]=None) -> bool
      does: "Handle an error."
      side: "Adds element"
    _default_severity:
      sig: (error_type:ErrorType) -> ErrorSeverity
      does: "Get default severity for error type."
    _log_error:
      sig: (error:AnalysisError) -> None
      does: "Log an error."
    safe_read_file:
      sig: (path:Path) -> Optional[str]
      does: "Safely read a file with error handling."
    safe_write_file:
      sig: (path:Path, content:str) -> bool
      does: "Safely write a file with error handling."
      side: "Writes data"
    safe_parse:
      sig: (path:str, content:str, parser_func:Callable) -> Any
      does: "Safely parse content with error handling."

functions:
  create_error_handler:
    sig: (mode:str='lenient', max_file_size_mb:float=10.0) -> ErrorHandler
    does: "Create an error handler with default settings."

# code_review.py | CodeReviewer | 272 lines

imports:
  stdlib: [collections.defaultdict, typing.{Any,Dict,List}]

CodeReviewer:
  doc: "Automated code review with optional LLM enhancement."
  attrs:
    client=None: Any
  methods:
    __init__:
      sig: (client=None) -> None
      does: "Initialize reviewer."
    review:
      sig: (project, focus:str='all') -> Dict[str, Any]
      does: "Perform code review."
    generate_report:
      sig: (results:Dict[str,Any], project_name:str='Project') -> str
      does: "Generate markdown review report."
      side: "Modifies list"

functions:
  analyze_code_quality:
    sig: (project) -> Dict[str, List[Dict]]
    does: "Analyze code quality issues."
    side: "Modifies list"
  check_security_issues:
    sig: (project) -> Dict[str, List[Dict]]
    does: "Check for security vulnerabilities."
    side: "Modifies list"
  check_performance_issues:
    sig: (project) -> Dict[str, List[Dict]]
    does: "Check for performance anti-patterns."
    side: "Modifies list"

# analyzer.py | ProjectAnalyzer | 324 lines

imports:
  stdlib: [datetime, sys, collections.defaultdict, pathlib.Path, typing.{Dict,List,Optional}]
  third_party: [dependency.{DependencyAnalyzer,NETWORKX_AVAILABLE}, intent.{NLTK_AVAILABLE,SPACY_AVAILABLE}, models.{ModuleInfo,ProjectInfo}, parsers.{TREE_SITTER_AVAILABLE,TreeSitterParser,UniversalParser}, similarity.RAPIDFUZZ_AVAILABLE]

ProjectAnalyzer:
  doc: "Main class for analyzing software projects."
  attrs:
    root_path: str
    use_treesitter: bool=True
    verbose: bool=False
    include_private: bool=False
  methods:
    _language_from_shebang:
      sig: (first_line:str) -> Optional[str]
      does: "language from shebang"
      decorators: [staticmethod]
    __init__:
      sig: (root_path:str, use_treesitter:bool=True, verbose:bool=False, include_private:bool=False) -> None
      does: "Initialize the project analyzer."
    _print_status:
      sig: () -> None
      does: "Print library availability status."
      side: "Modifies list"
    analyze:
      sig: () -> ProjectInfo
      does: "Analyze the project."
    _scan_files:
      sig: () -> None
      does: "Scan and parse all source files."
      side: "Modifies list"
    _detect_entrypoints:
      sig: () -> List[str]
      does: "Detect project entry points."
      side: "Modifies list"
    get_statistics:
      sig: () -> Dict
      does: "Get analysis statistics."

functions:
  analyze_project:
    sig: (path:str, use_treesitter:bool=True, verbose:bool=False) -> ProjectInfo
    does: "Convenience function to analyze a project."
  get_library_status:
    sig: () -> Dict[str, bool]
    does: "Get availability status of optional libraries."

# quality.py | QualityIssue, QualityReport, QualityAnalyzer | 266 lines

imports:
  stdlib: [dataclasses.{dataclass,field}, typing.{Any,Dict,List}]
  third_party: [models.{ModuleInfo,ProjectInfo}]

QualityIssue:
  doc: "Represents a code quality issue."

QualityReport:
  doc: "Complete quality analysis report."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "Convert to dictionary."

QualityAnalyzer:
  doc: "Analyzes code quality and generates recommendations."
  attrs:
    thresholds: Dict[str,int]=None
  methods:
    __init__:
      sig: (thresholds:Dict[str,int]=None) -> None
      does: "Initialize with custom thresholds."
      side: "Updates state"
    analyze:
      sig: (project:ProjectInfo) -> QualityReport
      does: "Analyze project quality."
    analyze_modules:
      sig: (modules:List[ModuleInfo]) -> QualityReport
      does: "Analyze a list of modules."
    _analyze_module:
      sig: (module:ModuleInfo, report:QualityReport) -> None
      does: "Analyze a single module."
      side: "Modifies list"
    _check_function:
      sig: (func, file_path:str, report:QualityReport) -> None
      does: "Check function quality."
      side: "Modifies list"
    _check_class:
      sig: (file_path:str, report:QualityReport) -> None
      does: "Check class quality."
      side: "Modifies list"
    _get_file_recommendation:
      sig: (module:ModuleInfo) -> str
      does: "Generate recommendation for long file."

functions:
  analyze_quality:
    sig: (project:ProjectInfo, thresholds:Dict[str,int]=None) -> QualityReport
    does: "Convenience function to analyze project quality."
  get_quality_summary:
    sig: (report:QualityReport) -> str
    does: "Generate human-readable quality summary."
    side: "Modifies list"

# shared_utils.py | 414 lines

imports:
  stdlib: [hashlib, re, typing.{Dict,List,Optional,Set}]

functions:
  compact_imports:
    sig: (imports:List[str], max_items:int=10) -> List[str]
    does: "Compact imports by grouping submodules."
    side: "Sets value"
  deduplicate_imports:
    sig: (imports:List[str]) -> List[str]
    does: "Remove redundant imports."
    side: "Sets value"
  abbreviate_type:
    sig: (type_str:str) -> str
    does: "Abbreviate type annotations for compactness."
  expand_type:
    sig: (abbrev:str) -> str
    does: "Expand abbreviated type back to full form."
  build_signature:
    sig: (params:List[str], return_type:Optional[str]=None, include_self:bool=False, abbreviate:bool=False, max_params:int=6) -> str
    does: "Build compact function signature."
    side: "Modifies list"
  remove_self_from_params:
    sig: (params:List[str]) -> List[str]
    does: "Remove 'self' and 'cls' from parameter list."
    side: "Removes element"
  categorize_function:
    sig: (name:str) -> str
    does: "Categorize function by name pattern."
  extract_domain:
    sig: (path:str) -> str
    does: "Extract domain from file path."
  compute_hash:
    sig: (name:str, signature:str, length:int=8) -> str
    does: "Compute short hash for quick comparison."
  truncate_docstring:
    sig: (docstring:Optional[str], max_length:int=60) -> str
    does: "Truncate docstring to first sentence or max_length."
  escape_for_yaml:
    sig: (text:str) -> str
    does: "Escape text for safe YAML inclusion."
  clean_identifier:
    sig: (name:str) -> str
    does: "Clean identifier by removing whitespace and special chara..."

# parsers.py | _PyFunctionBodyAnalyzer, TreeSitterParser, UniversalParser | 2417 lines

imports:
  stdlib: [ast, re, textwrap, typing.{List,Optional}]
  third_party: [intent.EnhancedIntentGenerator, models, tree_sitter.{Language,Parser}]

_PyFunctionBodyAnalyzer:
  bases: [ast.NodeVisitor]
  methods:
    __init__:
      sig: () -> None
      does: "creates"
      side: "Sets value"
    _add_call:
      sig: (name:str) -> None
      does: "creates call"
      side: "Adds element"
    _add_raise:
      sig: (name:str) -> None
      does: "creates raise"
      side: "Adds element"
    visit_Call:
      sig: (node) -> None
      does: "visit call"
      side: "Adds element"
    visit_Raise:
      sig: (node) -> None
      does: "visit raise"
      side: "Adds element"
    visit_If:
      sig: (node) -> None
      does: "visit if"
    visit_For:
      sig: (node) -> None
      does: "visit for"
    visit_AsyncFor:
      sig: (node) -> None
      does: "visit asyncfor"
    visit_While:
      sig: (node) -> None
      does: "visit while"
    visit_IfExp:
      sig: (node) -> None
      does: "visit ifexp"
    visit_BoolOp:
      sig: (node) -> None
      does: "visit boolop"
    visit_Try:
      sig: (node) -> None
      does: "visit try"
    visit_comprehension:
      sig: (node) -> None
      does: "visit comprehension"
    visit_Match:
      sig: (node) -> None
      does: "visit match"
    visit_FunctionDef:
      sig: (node) -> None
      does: "visit functiondef"
    visit_AsyncFunctionDef:
      sig: (node) -> None
      does: "visit asyncfunctiondef"
    visit_ClassDef:
      sig: (node) -> None
      does: "visit classdef"
    visit_Lambda:
      sig: (node) -> None
      does: "visit lambda"

TreeSitterParser:
  doc: "Parser using Tree-sitter for high-accuracy AST parsing."
  methods:
    __init__:
      sig: () -> None
      does: "Initialize Tree-sitter parsers for available languages."
    _init_parsers:
      sig: () -> None
      does: "Initialize parsers for each supported language."
    is_available:
      sig: (language:str) -> bool
      does: "Check if Tree-sitter parser is available for a language."
    get_supported_languages:
      sig: () -> List[str]
      does: "Get list of potentially supported languages."
      decorators: [classmethod]
    parse:
      sig: (filepath:str, content:str, language:str) -> Optional[ModuleInfo]
      does: "Parse a source file using Tree-sitter."
    _parse_python:
      sig: (filepath:str, content:str, tree) -> ModuleInfo
      does: "Parse Python source using Tree-sitter AST."
      side: "Modifies list"
    _extract_constants:
      sig: (tree, content:str) -> List[ConstantInfo]
      does: "Extract module-level UPPERCASE constants."
      side: "Modifies list"
    _extract_type_checking_imports:
      sig: (tree, content:str) -> List[str]
      does: "Extract TYPE_CHECKING block imports."
    _extract_conditional_imports:
      sig: (node, content:str) -> List[str]
      does: "Extract imports from try/except blocks."
    _extract_aliases:
      sig: (tree, content:str) -> dict
      does: "Extract module aliases (import X as Y)."
    _extract_py_function:
      sig: (node, content:str, decorated_node=None, filepath:Optional[str]=None) -> Optional[FunctionInfo]
      does: "Extract Python function from AST node."
      side: "Modifies list"
    _extract_py_enum:
      sig: (node, content:str) -> Optional[TypeInfo]
      does: "Extract Python Enum (values) as TypeInfo(kind='enum')."
      side: "Modifies list"
    _extract_py_class:
      sig: (node, content:str, decorated_node=None, filepath:Optional[str]=None) -> Optional[ClassInfo]
      does: "Extract Python class from AST node."
      side: "Modifies list"
    _extract_dataclass_field:
      sig: (node, content:str) -> Optional[FieldInfo]
      does: "Extract dataclass field from assignment."
    _extract_class_attribute:
      sig: (node, content:str) -> Optional[AttributeInfo]
      does: "Extract class attribute from self.x = ..."
    _extract_init_attributes:
      sig: (func_node, content:str) -> List[AttributeInfo]
      does: "Extract self.x = ..."
      side: "Sets value"
    _extract_class_property:
      sig: (node, content:str) -> Optional[str]
      does: "Extract class-level property from annotated assignment."
    _extract_py_import:
      sig: (node, content:str) -> List[str]
      does: "Extract import statement."
      side: "Modifies list"
    _extract_py_from_import:
      sig: (node, content:str) -> List[str]
      does: "Extract from ..."
      side: "Modifies list"
    _extract_py_constant:
      sig: (node, content:str) -> Optional[ConstantInfo]
      does: "Extract constant (UPPERCASE assignment) with value."

UniversalParser:
  doc: "Fallback parser using Python AST and regex."
  methods:
    __init__:
      sig: () -> None
      does: "Initialize the universal parser."
    parse:
      sig: (filepath:str, content:str, language:str) -> Optional[ModuleInfo]
      does: "Parse a source file using AST or regex."
    _parse_python:
      sig: (filepath:str, content:str) -> Optional[ModuleInfo]
      does: "Parse Python using built-in AST."
      side: "Modifies list"
    _extract_ast_enum:
      sig: (node:Any) -> Optional[TypeInfo]
      does: "Extract Enum values from Python AST class."
      side: "Modifies list"
    _extract_ast_function:
      sig: (node) -> FunctionInfo
      does: "Extract function from Python AST node."
      side: "Modifies list"
    _extract_ast_class:
      sig: (node:Any) -> ClassInfo
      does: "Extract class from Python AST node."
      side: "Modifies list"
    _extract_ast_constant:
      sig: (node:Any, content:str) -> Optional[ConstantInfo]
      does: "Extract ConstantInfo from an AST assignment node if appli..."
      side: "Modifies list"
    _format_ast_value:
      sig: (value_node:Any, content:str) -> str
      does: "Best-effort string representation of an AST value node."
    _ann_str:
      sig: (node) -> str
      does: "Convert AST annotation to string."
    _parse_js_ts:
      sig: (filepath:str, content:str, language:str) -> ModuleInfo
      does: "Parse JS/TS using regex patterns."
      side: "Modifies list"
    _parse_go:
      sig: (filepath:str, content:str) -> ModuleInfo
      does: "Parse Go using regex patterns."
      side: "Modifies list"
    _parse_rust:
      sig: (filepath:str, content:str) -> ModuleInfo
      does: "Parse Rust using regex patterns."
      side: "Modifies list"
    _parse_java:
      sig: (filepath:str, content:str) -> ModuleInfo
      does: "Parse Java using regex patterns."
      side: "Modifies list"
    _parse_csharp:
      sig: (filepath:str, content:str) -> ModuleInfo
      does: "Parse C# using regex patterns."
      side: "Modifies list"
    _parse_sql:
      sig: (filepath:str, content:str) -> ModuleInfo
      does: "Parse SQL using regex patterns."
      side: "Modifies list"

functions:
  _normalize_import_path:
    sig: (import_path:str) -> str
    does: "Normalize import path by removing duplicate suffix segments."
  _clean_imports:
    sig: (imports:List[str]) -> List[str]
    does: "Deduplicate and normalize import paths while preserving o..."
    side: "Sets value"
  _combine_import_name:
    sig: (module_name:str, identifier:str) -> str
    does: "Combine module and identifier while avoiding duplicate su..."
  _truncate_constant_value:
    sig: (value_text:str, limit:int=400) -> str
    does: "Return a trimmed single-line snippet for constant values."
  _py_expr_to_dotted_name:
    sig: (expr) -> str
    does: "py expr to dotted name"
  _analyze_python_function_node:
    sig: (func_node) -> None
    does: "processes python function node"
  is_tree_sitter_available:
    sig: () -> bool
    does: "Check if Tree-sitter is available."

# intent.py | IntentType, Intent, EnhancedIntentGenerator +1 | 562 lines

imports:
  stdlib: [re, dataclasses.{dataclass,field}, enum.{Enum,auto}, typing.{Any,List,Optional,TYPE_CHECKING}]
  third_party: [nltk, spacy, nltk.stem.WordNetLemmatizer]

IntentType:
  doc: "Types of user intents for code analysis."
  bases: [Enum]

Intent:
  doc: "Represents a detected user intent."

EnhancedIntentGenerator:
  doc: "Generator intencji z NLP - lemmatyzacja, ekstrakcja z doc..."
  attrs:
    lang: str='en'
  methods:
    __init__:
      sig: (lang:str='en') -> None
      does: "Initialize the intent generator."
    generate:
      sig: (name:str, docstring:Optional[str]=None) -> str
      does: "Generate intent from function name and optional docstring."
    _extract_from_docstring:
      sig: (docstring:str) -> Optional[str]
      does: "Extract intent from docstring's first line."
    _split_name:
      sig: (name:str) -> List[str]
      does: "Split function name into words."
    get_available_features:
      sig: () -> dict[str, bool]
      does: "Get dictionary of available NLP features."
      decorators: [classmethod]

IntentAnalyzer:
  doc: "Analyzes user queries to detect intent and provide sugges..."
  methods:
    __init__:
      sig: () -> None
      does: "Initialize the intent analyzer with patterns."
    _extract_keywords:
      sig: (query:str) -> List[str]
      does: "Extract keywords from a query string."
    _calculate_intent_confidence:
      sig: (keywords:List[str], patterns:List[str]) -> float
      does: "Calculate confidence score based on keyword matches."
    _identify_target:
      sig: (query:str, project:Any) -> str
      does: "Identify the target of the query (module, function, class..."
    _generate_description:
      sig: (intent_type:IntentType, target:str) -> str
      does: "Generate a description for the detected intent."
    _generate_suggestions:
      sig: (intent_type:IntentType, target:str, project:Any) -> List[str]
      does: "Generate suggestions based on intent type."
    analyze_intent:
      sig: (query:str, project:Any) -> List[Intent]
      does: "Analyze a query and return detected intents sorted by con..."
      side: "Modifies list"
    detect_code_smells:
      sig: (project:Any) -> List[dict]
      does: "Detect code smells in the project."
      side: "Modifies list"
    suggest_refactoring:
      sig: (target:str, project:Any) -> List[str]
      does: "Generate refactoring suggestions for a target."
    _find_target_object:
      sig: (target:str, project:Any) -> Any
      does: "Find the object referenced by target string."
    _suggest_module_refactoring:
      sig: (module:Any) -> List[str]
      does: "Generate refactoring suggestions for a module."
      side: "Modifies list"
    _suggest_class_refactoring:
      sig: (cls:Any) -> List[str]
      does: "Generate refactoring suggestions for a class."
      side: "Modifies list"
    _suggest_function_refactoring:
      sig: (func:Any) -> List[str]
      does: "Generate refactoring suggestions for a function."
      side: "Modifies list"

# adaptive.py | ChunkInfo, AdaptiveResult, AdaptiveReproducer | 614 lines

imports:
  stdlib: [dataclasses.dataclass, pathlib.Path, typing.{Any,Dict,List}]
  third_party: [dotenv.load_dotenv, file_formats.{generate_file_csv,generate_file_json,generate_file_yaml}, llm_clients.{BaseLLMClient,get_client}, reproduction.{compare_code,extract_code_block,generate_file_gherkin}]

ChunkInfo:
  doc: "Information about a code chunk."

AdaptiveResult:
  doc: "Result of adaptive reproduction."

AdaptiveReproducer:
  doc: "Adaptive code reproduction with LLM capability detection."
  attrs:
    client: BaseLLMClient=None
    model: str=None
  methods:
    __init__:
      sig: (client:BaseLLMClient=None, model:str=None) -> None
      does: "Initialize adaptive reproducer."
    _get_capabilities:
      sig: () -> Dict[str, Any]
      does: "Get LLM capabilities for current model."
    select_format:
      sig: (file_path:Path, content:str) -> str
      does: "Select optimal format based on file and LLM capabilities."
    should_chunk:
      sig: (content:str) -> bool
      does: "Determine if content should be chunked."
    chunk_content:
      sig: (content:str, file_path:Path) -> List[ChunkInfo]
      does: "Split content into logical chunks."
      side: "Modifies list"
    generate_chunk_spec:
      sig: (chunk:ChunkInfo, format_name:str) -> str
      does: "Generate specification for a single chunk."
    _gherkin_for_chunk:
      sig: (chunk:ChunkInfo) -> str
      does: "Generate Gherkin for a chunk."
      side: "Modifies list"
    _yaml_for_chunk:
      sig: (chunk:ChunkInfo) -> str
      does: "Generate YAML for a chunk."
      side: "Modifies list"
    _json_for_chunk:
      sig: (chunk:ChunkInfo) -> str
      does: "Generate JSON for a chunk."
    reproduce:
      sig: (file_path:str, output_dir:str=None) -> AdaptiveResult
      does: "Reproduce code with adaptive format selection."
    _reproduce_single:
      sig: (path:Path, content:str, format_name:str, output_dir:str=None) -> AdaptiveResult
      does: "Reproduce without chunking."
      side: "Saves data"
    _reproduce_chunked:
      sig: (path:Path, content:str, format_name:str, output_dir:str=None) -> AdaptiveResult
      does: "Reproduce with chunking."
      side: "Modifies list"
    _generate_from_spec:
      sig: (spec:str, format_name:str, file_ext:str) -> str
      does: "Generate code from specification."
    _save_result:
      sig: (output_dir:Path, original:str, spec:str, generated:str, result:AdaptiveResult) -> None
      does: "Save reproduction results."
      side: "Saves data"

functions:
  get_llm_capabilities:
    sig: (model:str) -> Dict[str, Any]
    does: "Get capabilities for a specific model."

# reproducer.py | ReproductionStatus, FileValidation, ReproductionResult +2 | 711 lines

imports:
  stdlib: [json, re, dataclasses.{dataclass,field}, enum.Enum, pathlib.Path, typing.{Any,Dict,List,Optional}]

ReproductionStatus:
  doc: "Status of file reproduction."
  bases: [Enum]

FileValidation:
  doc: "Validation result for a single file."
  methods:
    score:
      sig: @property () -> float
      does: "Calculate match score 0-100."
      decorators: [property]
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"

ReproductionResult:
  doc: "Result of reproduction process."
  methods:
    success_rate:
      sig: @property () -> float
      does: "success rate"
      decorators: [property]
    average_score:
      sig: @property () -> float
      does: "average score"
      decorators: [property]
    summary:
      sig: () -> str
      does: "summary"
      side: "Modifies list"

SpecReproducer:
  doc: "Reproduces code structure from logic specifications."
  attrs:
    verbose: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    reproduce_from_yaml:
      sig: (spec_path:str, output_dir:str, filter_paths:Optional[List[str]]=None) -> ReproductionResult
      does: "Reproduce files from YAML specification."
    reproduce_from_json:
      sig: (spec_path:str, output_dir:str, filter_paths:Optional[List[str]]=None) -> ReproductionResult
      does: "Reproduce files from JSON specification."
    _reproduce:
      sig: (spec:Dict[str,Any], output_dir:str, filter_paths:Optional[List[str]]=None) -> ReproductionResult
      does: "Internal reproduction logic."
      side: "Modifies list"
    _generate_file:
      sig: (module:Dict[str,Any], output_path:Path) -> bool
      does: "Generate a single file from module spec."
      side: "Writes data"
    _generate_python:
      sig: (module:Dict[str,Any]) -> str
      does: "Generate Python file content."
      side: "Modifies list"
    _render_docstring:
      sig: (text:str, indent:str) -> List[str]
      does: "Render a safe Python docstring or fall back to comments."
      side: "Modifies list"
    _sanitize_python_property:
      sig: (prop:str) -> str
      does: "Sanitize a Python class property declaration for valid sy..."
    _generate_python_class:
      sig: (cls:Dict[str,Any]) -> List[str]
      does: "Generate Python class."
      side: "Modifies list"
    _generate_python_method:
      sig: (method:Dict[str,Any]) -> List[str]
      does: "Generate Python method."
      side: "Modifies list"
    _generate_python_function:
      sig: (func:Dict[str,Any]) -> List[str]
      does: "Generate Python function."
      side: "Modifies list"
    _generate_typescript:
      sig: (module:Dict[str,Any]) -> str
      does: "Generate TypeScript file content."
      side: "Modifies list"
    _generate_ts_class:
      sig: (cls:Dict[str,Any]) -> List[str]
      does: "Generate TypeScript class."
      side: "Modifies list"
    _generate_ts_method:
      sig: (method:Dict[str,Any]) -> List[str]
      does: "Generate TypeScript method."
      side: "Modifies list"
    _generate_ts_function:
      sig: (func:Dict[str,Any]) -> List[str]
      does: "Generate TypeScript function."
      side: "Modifies list"
    _parse_signature:
      sig: (sig:str) -> str
      does: "Parse and clean signature."

SpecValidator:
  doc: "Validates generated files against logic specification."
  methods:
    __init__:
      sig: () -> None
      does: "creates"
    validate:
      sig: (spec_path:str, generated_dir:str, filter_paths:Optional[List[str]]=None) -> List[FileValidation]
      does: "Validate generated files against spec."
      side: "Modifies list"
    _validate_file:
      sig: (module:Dict[str,Any], base_path:Path) -> FileValidation
      does: "Validate a single file."
      side: "Modifies list"
    _check_python_syntax:
      sig: (content:str, validation:FileValidation) -> bool
      does: "Check Python syntax."
      side: "Modifies list"

functions:
  _safe_load_yaml_file:
    sig: (path:str) -> Any
    does: "safe load yaml file"
    edge: "error → raise RuntimeError"
  reproduce_project:
    sig: (spec_path:str, output_dir:str, filter_paths:Optional[List[str]]=None, validate:bool=True, verbose:bool=True) -> ReproductionResult
    does: "Convenience function to reproduce and validate a project."
  validate_files:
    sig: (spec_path:str, generated_dir:str, filter_paths:Optional[List[str]]=None) -> List[FileValidation]
    does: "Validate specific files against spec."

# llm_clients.py | 274 lines

imports:
  stdlib: [json, os, typing.{Any,Optional}]
  third_party: [lolm]

functions:
  _get_user_llm_config_path:
    sig: () -> str
    does: "Get path to legacy code2logic LLM config."
  _load_user_llm_config:
    sig: () -> dict[str, Any]
    does: "Load legacy code2logic LLM config."
  _get_priority_mode:
    sig: () -> str
    does: "Get priority mode from legacy config."
  get_priority_mode:
    sig: () -> str
    does: "Get priority mode (legacy wrapper)."
  _get_provider_priority_overrides:
    sig: () -> dict[str, int]
    does: "Get provider priority overrides from legacy config."
  _get_model_priority_rules:
    sig: () -> dict[str, dict[str, int]]
    does: "Get model priority rules from legacy config."
  _get_model_priority:
    sig: (model_string:str) -> Optional[int]
    does: "Get model priority from legacy config."
  _get_provider_model_string:
    sig: (provider:str) -> str
    does: "Get model string for provider from environment."
  _get_priority_order:
    sig: () -> list[str]
    does: "Get providers ordered by priority."
  _get_effective_provider_order:
    sig: () -> list[tuple[str, int]]
    does: "Get effective provider order with priorities."
    side: "Sets value"
  get_effective_provider_priorities:
    sig: () -> dict[str, int]
    does: "Get effective provider priorities (legacy wrapper)."
  _candidate_litellm_yaml_paths:
    sig: () -> list[str]
    does: "Get candidate paths for litellm_config.yaml."

# prompts.py | 157 lines

imports:
  stdlib: [typing.Dict]

functions:
  get_reproduction_prompt:
    sig: (spec:str, fmt:str, file_name:str, language:str='python', max_spec_length:int=5000) -> str
    does: "Generate optimized reproduction prompt."
  get_review_prompt:
    sig: (code:str, spec:str, fmt:str) -> str
    does: "Generate code review prompt."
  get_fix_prompt:
    sig: (code:str, issues:list, spec:str) -> str
    does: "Generate code fix prompt."

# chunked_reproduction.py | Chunk, ChunkedSpec, ChunkedResult +1 | 480 lines

imports:
  stdlib: [re, dataclasses.dataclass, typing.{List,Optional}]
  third_party: [utils.estimate_tokens]

Chunk:
  doc: "A chunk of specification for reproduction."

ChunkedSpec:
  doc: "Chunked specification."

ChunkedResult:
  doc: "Result of chunked reproduction."

ChunkedReproducer:
  doc: "Reproduce code from chunked specifications."
  attrs:
    client: Any
    model_name: str='default'
    max_tokens: Optional[int]=None
  methods:
    __init__:
      sig: (client, model_name:str='default', max_tokens:Optional[int]=None) -> None
      does: "creates"
    reproduce:
      sig: (spec:str, fmt:str, file_name:str) -> ChunkedResult
      does: "Reproduce code from specification, chunking if needed."
      side: "Modifies list"
    _extract_code:
      sig: (response:str) -> str
      does: "Extract code from LLM response."

functions:
  get_llm_limit:
    sig: (model_name:str) -> int
    does: "Get context limit for LLM model."
  chunk_yaml_spec:
    sig: (spec:str, max_tokens:int=2000) -> List[Chunk]
    does: "Chunk YAML specification by modules/classes/functions."
    side: "Modifies list"
  chunk_gherkin_spec:
    sig: (spec:str, max_tokens:int=2000) -> List[Chunk]
    does: "Chunk Gherkin specification by Features/Scenarios."
    side: "Modifies list"
  chunk_markdown_spec:
    sig: (spec:str, max_tokens:int=2000) -> List[Chunk]
    does: "Chunk Markdown specification by sections."
    side: "Modifies list"
  chunk_spec:
    sig: (spec:str, fmt:str, max_tokens:int=2000) -> ChunkedSpec
    does: "Chunk specification based on format."
  get_chunk_prompt:
    sig: (chunk:Chunk, fmt:str, file_name:str, chunk_num:int, total_chunks:int) -> str
    does: "Generate prompt for a single chunk."
  merge_chunk_codes:
    sig: (codes:List[str], file_name:str) -> str
    does: "Merge code from multiple chunks."
    side: "Sets value"
  auto_chunk_reproduce:
    sig: (spec:str, fmt:str, file_name:str, client, model_name:str='default') -> ChunkedResult
    does: "Auto-chunking reproduction with LLM adaptation."
  adaptive_chunk_reproduce:
    sig: (spec:str, fmt:str, file_name:str, client, provider:str='unknown', model:str='unknown') -> ChunkedResult
    does: "Adaptive chunking reproduction using LLM profile."
    side: "Sets value"

# __init__.py | 440 lines
# Re-export module
type: re-export
exports:
  - analyze_quality
  - reproduce_project

# metrics.py | TextMetrics, StructuralMetrics, SemanticMetrics +3 | 599 lines

imports:
  stdlib: [logging, re, collections.Counter, dataclasses.{asdict,dataclass,field}, typing.{Any,Dict,List,Tuple}]
  third_party: [difflib]

TextMetrics:
  doc: "Text-level similarity metrics."

StructuralMetrics:
  doc: "Structural code metrics."

SemanticMetrics:
  doc: "Semantic preservation metrics."

FormatMetrics:
  doc: "Format-specific efficiency metrics."

ReproductionResult:
  doc: "Complete reproduction analysis result."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"
    to_report:
      sig: () -> str
      does: "Generate detailed markdown report."
      side: "Modifies list"

ReproductionMetrics:
  doc: "Analyze reproduction quality with multiple metrics."
  attrs:
    verbose: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    analyze:
      sig: (original:str, generated:str, spec:str='', format_name:str='', source_file:str='') -> ReproductionResult
      does: "Analyze reproduction quality."
    _compute_text_metrics:
      sig: (original:str, generated:str) -> TextMetrics
      does: "Compute text-level metrics."
      side: "Sets value"
    _cosine_similarity:
      sig: (words1:List[str], words2:List[str]) -> float
      does: "Compute cosine similarity between word lists."
      side: "Sets value"
    _compute_structural_metrics:
      sig: (original:str, generated:str) -> StructuralMetrics
      does: "Compute structural metrics."
    _compute_semantic_metrics:
      sig: (original:str, generated:str) -> SemanticMetrics
      does: "Compute semantic preservation metrics."
      side: "Sets value"
    _compute_format_metrics:
      sig: (original:str, generated:str, spec:str, format_name:str) -> FormatMetrics
      does: "Compute format efficiency metrics."
    _compute_overall_score:
      sig: (result:ReproductionResult) -> float
      does: "Compute weighted overall score."
    _get_grade:
      sig: (score:float) -> str
      does: "Get letter grade from score."
    _generate_recommendations:
      sig: (result:ReproductionResult) -> List[str]
      does: "Generate improvement recommendations."
      side: "Modifies list"

functions:
  analyze_reproduction:
    sig: (original:str, generated:str, spec:str='', format_name:str='', verbose:bool=False) -> ReproductionResult
    does: "Convenience function for reproduction analysis."
  compare_formats:
    sig: (original:str, results:Dict[str,Tuple[str,str]], verbose:bool=False) -> Dict[str, Any]
    does: "Compare reproduction quality across formats."

# __main__.py | 16 lines
# Re-export module
type: re-export
exports:
  - cli.main

# refactor.py | DuplicateGroup, RefactoringSuggestion, RefactoringReport | 384 lines

imports:
  stdlib: [dataclasses.{asdict,dataclass,field}, typing.{Any,Dict,List}]
  third_party: [analyzer.analyze_project, code_review.{analyze_code_quality,check_security_issues}, llm_clients.{BaseLLMClient,get_client}]

DuplicateGroup:
  doc: "Group of duplicate functions."

RefactoringSuggestion:
  doc: "Single refactoring suggestion."

RefactoringReport:
  doc: "Complete refactoring analysis report."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"
    to_markdown:
      sig: () -> str
      does: "Generate markdown report."
      side: "Modifies list"

functions:
  find_duplicates:
    sig: (project_path:str, threshold:float=0.8) -> List[DuplicateGroup]
    does: "Find duplicate functions in a project."
    side: "Modifies list"
  analyze_quality:
    sig: (project_path:str, include_security:bool=True, include_performance:bool=True) -> RefactoringReport
    does: "Analyze code quality and generate refactoring report."
    side: "Modifies list"
  suggest_refactoring:
    sig: (project_path:str, use_llm:bool=False, client:BaseLLMClient=None) -> RefactoringReport
    does: "Generate refactoring suggestions for a project."
    side: "Modifies list"
  compare_codebases:
    sig: (project1:str, project2:str) -> Dict[str, Any]
    does: "Compare two codebases for similarities and differences."
  quick_analyze:
    sig: (project_path:str) -> Dict[str, Any]
    does: "Quick analysis for a project."
    side: "Modifies list"

# logicml.py | LogicMLSpec, LogicMLGenerator | 375 lines

imports:
  stdlib: [dataclasses.dataclass, pathlib.Path, typing.{Dict,List,Optional,Set}]
  third_party: [models.{ClassInfo,FunctionInfo,ModuleInfo,ProjectInfo}, shared_utils.{compact_imports,remove_self_from_params,truncate_docstring}]

LogicMLSpec:
  doc: "LogicML specification output."

LogicMLGenerator:
  doc: "Generates LogicML format - optimized for LLM code reprodu..."
  attrs:
    FORMAT_NAME: str
    FILE_EXTENSION: str
    TOKEN_EFFICIENCY: float
    REPRODUCTION_FIDELITY: float
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    generate:
      sig: (project:ProjectInfo, detail:str='standard') -> LogicMLSpec
      does: "Generate LogicML specification for a project."
      side: "Modifies list"
    _generate_module:
      sig: (module:ModuleInfo, detail:str) -> str
      does: "Generate LogicML for a single module."
      side: "Modifies list"
    _generate_imports:
      sig: (imports:List[str]) -> str
      does: "Generate compact imports section."
      side: "Sets value"
    _generate_class:
      sig: (cls:ClassInfo, detail:str) -> str
      does: "Generate LogicML for a class."
      side: "Modifies list"
    _generate_method:
      sig: (method:FunctionInfo, detail:str, indent:int=2) -> str
      does: "Generate LogicML for a method."
      side: "Removes element"
    _generate_functions:
      sig: (functions:List[FunctionInfo], detail:str) -> str
      does: "Generate LogicML for top-level functions."
      side: "Modifies list"
    _detect_side_effects:
      sig: (method:FunctionInfo) -> Optional[str]
      does: "Detect side effects from method calls and name patterns."

functions:
  generate_logicml:
    sig: (project:ProjectInfo, detail:str='standard') -> str
    does: "Convenience function to generate LogicML format."

# function_logic.py | FunctionLogicGenerator | 370 lines

imports:
  stdlib: [typing.{List,Tuple}]
  third_party: [models.{FunctionInfo,ProjectInfo}, shared_utils.{remove_self_from_params,truncate_docstring}, toon_format.TOONGenerator]

FunctionLogicGenerator:
  attrs:
    FILE_EXTENSION: str
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    generate:
      sig: (project:ProjectInfo, detail:str='full') -> str
      does: "creates"
      side: "Modifies list"
    generate_json:
      sig: (project:ProjectInfo, detail:str='full') -> str
      does: "creates json"
    generate_yaml:
      sig: (project:ProjectInfo, detail:str='full') -> str
      does: "creates yaml"
    generate_toon:
      sig: (project:ProjectInfo, detail:str='full', no_repeat_name:bool=False, no_repeat_details:bool=False, include_does:bool=False) -> str
      does: "creates toon"
      side: "Modifies list"
    generate_toon_schema:
      sig: () -> str
      does: "Generate JSON Schema describing the function-logic TOON f..."
    _build_data:
      sig: (project:ProjectInfo, detail:str) -> dict
      does: "creates data"
      side: "Modifies list"
    _module_items:
      sig: (module) -> List[Tuple[str, str, FunctionInfo]]
      does: "module items"
      side: "Modifies list"
    _build_sig:
      sig: (func:FunctionInfo, include_async_prefix:bool=True, language:str='') -> str
      does: "creates sig"
      side: "Removes element"
    _build_loc:
      sig: (func:FunctionInfo) -> str
      does: "creates loc"
    _build_does:
      sig: (func:FunctionInfo) -> str
      does: "creates does"
    _item_to_dict:
      sig: (kind:str, qualified_name:str, func:FunctionInfo, detail:str, module_language:str='') -> dict
      does: "item to dict"
    _format_function:
      sig: (kind:str, qualified_name:str, func:FunctionInfo, detail:str, indent:int, module_language:str='') -> List[str]
      does: "formats function"
      side: "Modifies list"

# utils.py | 25 lines

imports:
  stdlib: [shutil, pathlib.Path]

functions:
  estimate_tokens:
    sig: (text:str) -> int
    does: "estimate tokens"
  write_text_atomic:
    sig: (path:Path, content:str) -> None
    does: "logs text atomic"
    side: "Writes data"
  cleanup_generated_root:
    sig: (generated_root:Path, allowed_dirs:set[str]) -> None
    does: "cleanup generated root"

# generators.py | MarkdownGenerator, CompactGenerator, JSONGenerator +2 | 2179 lines

imports:
  stdlib: [json, collections.defaultdict, pathlib.Path, typing.{List,Optional}]
  third_party: [models, shared_utils.{categorize_function,compact_imports,compute_hash,deduplicate_imports}]

MarkdownGenerator:
  doc: "Generates Markdown output for project analysis."
  methods:
    generate:
      sig: (project:ProjectInfo, detail_level:str='standard') -> str
      does: "Generate Markdown output."
      side: "Modifies list"
    _gen_tree:
      sig: (lines:List[str], project:ProjectInfo) -> None
      does: "Generate project structure tree."
      side: "Modifies list"
    _print_tree:
      sig: (lines:List[str], tree:dict, prefix:str, depth:int=0) -> None
      does: "Recursively print tree structure."
      side: "Modifies list"
    _gen_module:
      sig: (lines:List[str], m:ModuleInfo, detail:str, proj:ProjectInfo) -> None
      does: "Generate module documentation."
      side: "Modifies list"
    _gen_class:
      sig: (lines:List[str], cls:ClassInfo, detail:str) -> None
      does: "Generate class documentation."
      side: "Modifies list"
    _sig:
      sig: (f:FunctionInfo) -> str
      does: "Generate function signature."
      side: "Removes element"

CompactGenerator:
  doc: "Generates ultra-compact output for token efficiency."
  methods:
    generate:
      sig: (project:ProjectInfo) -> str
      does: "Generate compact output."
      side: "Modifies list"

JSONGenerator:
  doc: "Generates JSON output for machine processing."
  methods:
    generate:
      sig: (project:ProjectInfo, flat:bool=False, detail:str='standard') -> str
      does: "Generate JSON output."
    generate_from_module:
      sig: (module:ModuleInfo, detail:str='full') -> str
      does: "creates from module"
    _generate_nested:
      sig: (project:ProjectInfo, detail:str) -> str
      does: "Generate nested JSON structure."
    _field_to_dict:
      sig: (field:FieldInfo) -> dict
      does: "Serialize dataclass FieldInfo to dictionary."
    _generate_flat:
      sig: (project:ProjectInfo, detail:str) -> str
      does: "Generate flat JSON list for comparisons."
      side: "Modifies list"
    _build_element_row:
      sig: (m:ModuleInfo, elem_type:str, name:str, signature:str, f:FunctionInfo, deps:list) -> dict
      does: "Build a single element row for flat output."
    _build_signature:
      sig: (f:FunctionInfo) -> str
      does: "Build compact signature."
      side: "Removes element"
    _categorize:
      sig: (name:str) -> str
      does: "Categorize by name pattern."
    _extract_domain:
      sig: (path:str) -> str
      does: "Extract domain from path."
    _compute_hash:
      sig: (name:str, signature:str) -> str
      does: "Compute short hash."

YAMLGenerator:
  doc: "Generates YAML output for human-readable representation."
  methods:
    generate:
      sig: (project:ProjectInfo, flat:bool=False, detail:str='standard', compact:bool=True) -> str
      does: "Generate YAML output."
    generate_schema:
      sig: (format_type:str='compact') -> str
      does: "Generate JSON Schema for the YAML format."
    _generate_compact_schema:
      sig: () -> str
      does: "Generate JSON Schema for compact YAML format with meta.le..."
    _generate_full_schema:
      sig: () -> str
      does: "Generate JSON Schema for full YAML format."
    _generate_hybrid_schema:
      sig: () -> str
      does: "Generate JSON Schema for hybrid format."
    generate_hybrid:
      sig: (project:ProjectInfo, detail:str='standard') -> str
      does: "Generate hybrid format combining TOON compactness with YA..."
      side: "Modifies list"
    _build_enhanced_signature:
      sig: (f:FunctionInfo) -> str
      does: "Build enhanced signature with better parameter handling."
      side: "Modifies list"
    _extract_constants:
      sig: (module:ModuleInfo) -> list
      does: "Extract constants and type definitions from module."
      side: "Modifies list"
    _extract_dataclasses:
      sig: (module:ModuleInfo) -> list
      does: "Extract dataclass information from classes."
      side: "Modifies list"
    _extract_conditional_imports:
      sig: (module:ModuleInfo) -> list
      does: "Extract conditional imports from constants."
      side: "Modifies list"
    generate_from_module:
      sig: (module:ModuleInfo, detail:str='full') -> str
      does: "creates from module"
    _build_flat_data:
      sig: (project:ProjectInfo, detail:str) -> dict
      does: "Build flat data structure optimized for comparisons."
      side: "Modifies list"
    _build_nested_data:
      sig: (project:ProjectInfo, detail:str) -> dict
      does: "Build nested hierarchical data structure."
      side: "Modifies list"
    _constants_for_module_verbose:
      sig: (module:ModuleInfo, limit:int=12) -> list
      does: "constants for module verbose"
      side: "Modifies list"
    _build_row:
      sig: (path:str, elem_type:str, name:str, signature:str, language:str, detail:str) -> dict
      does: "Build a single row for flat output."
    _build_function_row:
      sig: (path:str, f:FunctionInfo, language:str, detail:str, project:ProjectInfo, imports:list) -> dict
      does: "Build row for standalone function."
    _build_method_row:
      sig: (path:str, class_name:str, f:FunctionInfo, language:str, detail:str, project:ProjectInfo) -> dict
      does: "Build row for class method."
    _function_to_dict:
      sig: (f:FunctionInfo, detail:str) -> dict
      does: "Convert function to dict for nested output."
    _method_to_dict:
      sig: (f:FunctionInfo, detail:str) -> dict
      does: "Convert method to dictionary for YAML output."
    _build_signature:
      sig: (f:FunctionInfo) -> str
      does: "Build compact signature string."
      side: "Removes element"

CSVGenerator:
  doc: "Generates CSV output optimized for LLM processing."
  methods:
    generate:
      sig: (project:ProjectInfo, detail:str='standard') -> str
      does: "Generate CSV output."
      side: "Writes data"
    _build_row:
      sig: (m:ModuleInfo, elem_type:str, name:str, signature:str, calls:list, deps:str) -> dict
      does: "Build a single CSV row."
    _build_function_row:
      sig: (m:ModuleInfo, elem_type:str, name:str, f:FunctionInfo, deps:str, detail:str) -> dict
      does: "Build CSV row for function/method."
    _build_signature:
      sig: (f:FunctionInfo) -> str
      does: "Build compact signature."
      side: "Removes element"
    _categorize:
      sig: (name:str) -> str
      does: "Categorize function by name pattern."
    _extract_domain:
      sig: (path:str) -> str
      does: "Extract domain from file path."
    _compute_hash:
      sig: (name:str, signature:str) -> str
      does: "Compute short hash for quick comparison."
    _escape_csv:
      sig: (text:str) -> str
      does: "Escape text for CSV (remove newlines, limit commas)."

functions:
  bytes_to_kb:
    sig: (bytes_value:int) -> float
    does: "Convert bytes to kilobytes with single decimal precision."

# markdown_format.py | MarkdownSpec, MarkdownHybridGenerator | 365 lines

imports:
  stdlib: [dataclasses.dataclass, pathlib.Path, typing.{Dict,List}]
  third_party: [generators.YAMLGenerator, gherkin.GherkinGenerator, models.ProjectInfo]

MarkdownSpec:
  doc: "Markdown specification for a project."

MarkdownHybridGenerator:
  doc: "Generates optimized Markdown hybrid format."
  attrs:
    verbose: bool=False
  methods:
    __init__:
      sig: (verbose:bool=False) -> None
      does: "creates"
    generate:
      sig: (project:ProjectInfo, detail:str='full') -> MarkdownSpec
      does: "Generate Markdown hybrid specification."
      side: "Modifies list"
    _generate_header:
      sig: (project:ProjectInfo) -> str
      does: "Generate header section."
    _generate_tree:
      sig: (project:ProjectInfo) -> str
      does: "Generate file tree section."
      side: "Modifies list"
    _generate_imports:
      sig: (project:ProjectInfo) -> str
      does: "Generate imports as YAML for precise reproduction."
      side: "Modifies list"
    _generate_classes_yaml:
      sig: (project:ProjectInfo) -> str
      does: "Generate classes as detailed YAML codeblock."
      side: "Modifies list"
    _generate_functions_gherkin:
      sig: (project:ProjectInfo) -> str
      does: "Generate functions as detailed Gherkin codeblock."
      side: "Modifies list"
    _generate_dependencies:
      sig: (project:ProjectInfo) -> str
      does: "Generate module dependencies section."
      side: "Modifies list"

functions:
  generate_markdown_hybrid:
    sig: (project:ProjectInfo, detail:str='full') -> str
    does: "Convenience function to generate Markdown hybrid format."
  generate_file_markdown:
    sig: (file_path:str) -> str
    does: "Generate Markdown hybrid for a single file."

# models.py | FunctionInfo, ClassInfo, TypeInfo +11 | 339 lines

imports:
  stdlib: [dataclasses.{dataclass,field}, typing.{Dict,List,Optional}]

FunctionInfo:
  doc: "Information about a function or method."

ClassInfo:
  doc: "Information about a class or interface."

TypeInfo:
  doc: "Information about a type alias, interface, or enum."

ModuleInfo:
  doc: "Information about a source file/module."

DependencyNode:
  doc: "Node in the dependency graph with metrics."

ProjectInfo:
  doc: "Complete project analysis results."

ConstantInfo:
  doc: "Module-level constant information."

FieldInfo:
  doc: "Dataclass field information."

AttributeInfo:
  doc: "Instance attribute information (self.x = ...)."

PropertyInfo:
  doc: "Property information (@property, @x.setter)."

OptionalImport:
  doc: "Try/except import block information."

ClassInfo:
  doc: "Information about a class or interface."

FunctionInfo:
  doc: "Information about a function or method."

ModuleInfo:
  doc: "Information about a source file/module."

# similarity.py | SimilarityDetector | 239 lines

imports:
  stdlib: [typing.{Dict,List}]
  third_party: [models.ModuleInfo, rapidfuzz.{fuzz,process}]

SimilarityDetector:
  doc: "Detects similar functions using fuzzy string matching."
  attrs:
    threshold: float=80.0
  methods:
    __init__:
      sig: (threshold:float=80.0) -> None
      does: "Initialize the similarity detector."
    find_similar_functions:
      sig: (modules:List[ModuleInfo]) -> Dict[str, List[str]]
      does: "Find similar functions across all modules."
      side: "Modifies list"
    find_duplicate_signatures:
      sig: (modules:List[ModuleInfo]) -> Dict[str, List[str]]
      does: "Find functions with identical signatures."
      side: "Modifies list"
    _build_signature:
      sig: (name:str, params:List[str], return_type:str=None) -> str
      does: "Build a normalized signature string."
      side: "Modifies list"

functions:
  is_rapidfuzz_available:
    sig: () -> bool
    does: "Check if Rapidfuzz is available."
  get_refactoring_suggestions:
    sig: (similar_functions:Dict[str,List[str]]) -> List[Dict[str, any]]
    does: "Generate refactoring suggestions based on similar functions."
    side: "Modifies list"

# universal.py | ElementType, Language, Parameter +5 | 1234 lines

imports:
  stdlib: [hashlib, json, re, dataclasses.{asdict,dataclass,field}, enum.Enum, pathlib.Path, typing.{Any,Dict,List,Union}]
  third_party: [dotenv.load_dotenv, llm_clients.{BaseLLMClient,get_client}, reproduction.{compare_code,extract_code_block}]

ElementType:
  doc: "Types of code elements."
  bases: [Enum]

Language:
  doc: "Supported languages."
  bases: [Enum]

Parameter:
  doc: "Function/method parameter."

CodeElement:
  doc: "Universal representation of a code element."

CodeLogic:
  doc: "Universal code logic representation for a single file."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "Convert to dictionary."
    _element_to_dict:
      sig: (elem:CodeElement) -> Dict[str, Any]
      does: "Convert element to dictionary."
    to_compact:
      sig: () -> str
      does: "Convert to compact string representation."
      side: "Modifies list"
    _element_to_compact:
      sig: (elem:CodeElement, indent:int) -> List[str]
      does: "Convert element to compact lines."
      side: "Modifies list"

UniversalParser:
  doc: "Parse source code into universal CodeLogic format."
  methods:
    detect_language:
      sig: (content:str, file_ext:str) -> Language
      does: "Detect programming language from content and extension."
    parse:
      sig: (file_path:Union[str,Path]) -> CodeLogic
      does: "Parse source file into CodeLogic."
    _parse_rust:
      sig: (path:Path, content:str, hash_:str) -> CodeLogic
      does: "Parse Rust file."
      side: "Modifies list"
    _parse_java:
      sig: (path:Path, content:str, hash_:str) -> CodeLogic
      does: "Parse Java file."
      side: "Modifies list"
    _parse_csharp:
      sig: (path:Path, content:str, hash_:str) -> CodeLogic
      does: "Parse C# file."
      side: "Modifies list"
    _parse_python:
      sig: (path:Path, content:str, hash_:str) -> CodeLogic
      does: "Parse Python file."
      side: "Modifies list"
    _parse_js_ts:
      sig: (path:Path, content:str, hash_:str, lang:Language) -> CodeLogic
      does: "Parse JavaScript/TypeScript file."
      side: "Modifies list"
    _parse_go:
      sig: (path:Path, content:str, hash_:str) -> CodeLogic
      does: "Parse Go file."
      side: "Modifies list"
    _parse_sql:
      sig: (path:Path, content:str, hash_:str) -> CodeLogic
      does: "Parse SQL file."
      side: "Modifies list"
    _parse_generic:
      sig: (path:Path, content:str, hash_:str, lang:Language) -> CodeLogic
      does: "Generic parser for unknown languages."
      side: "Modifies list"

CodeGenerator:
  doc: "Generate code from CodeLogic in target language."
  methods:
    generate:
      sig: (logic:CodeLogic, target_lang:Language) -> str
      does: "Generate code in target language."
    _generate_python:
      sig: (logic:CodeLogic) -> str
      does: "Generate Python code."
      side: "Modifies list"
    _generate_python_element:
      sig: (elem:CodeElement, indent:int=0) -> List[str]
      does: "Generate Python code for element."
      side: "Modifies list"
    _generate_typescript:
      sig: (logic:CodeLogic) -> str
      does: "Generate TypeScript code."
      side: "Modifies list"
    _generate_go:
      sig: (logic:CodeLogic) -> str
      does: "Generate Go code."
      side: "Modifies list"
    _generate_sql:
      sig: (logic:CodeLogic) -> str
      does: "Generate SQL code."
      side: "Modifies list"
    _generate_rust:
      sig: (logic:CodeLogic) -> str
      does: "Generate Rust code."
      side: "Modifies list"
    _generate_java:
      sig: (logic:CodeLogic) -> str
      does: "Generate Java code."
      side: "Modifies list"
    _generate_csharp:
      sig: (logic:CodeLogic) -> str
      does: "Generate C# code."
      side: "Modifies list"
    _generate_generic:
      sig: (logic:CodeLogic, target:Language) -> str
      does: "Generate generic code."

UniversalReproducer:
  doc: "Universal code reproduction system."
  attrs:
    client: BaseLLMClient=None
  methods:
    __init__:
      sig: (client:BaseLLMClient=None) -> None
      does: "Initialize reproducer."
    _get_client:
      sig: () -> BaseLLMClient
      does: "Get or create LLM client."
    extract_logic:
      sig: (file_path:str) -> CodeLogic
      does: "Extract code logic from file."
    reproduce:
      sig: (source_path:str, target_lang:str=None, output_dir:str=None, use_llm:bool=True) -> Dict[str, Any]
      does: "Reproduce code from source file."
      side: "Saves data"
    _generate_with_llm:
      sig: (logic:CodeLogic, target:Language) -> str
      does: "Generate code using LLM."
    _save_result:
      sig: (output_dir:Path, original:str, logic:CodeLogic, generated:str, result:Dict[str,Any]) -> None
      does: "Save reproduction results."
      side: "Saves data"

functions:
  reproduce_file:
    sig: (source_path:str, target_lang:str=None, output_dir:str=None, use_llm:bool=True) -> Dict[str, Any]
    does: "Convenience function for single file reproduction."

# benchmark.py | FormatResult, BenchmarkResult, ReproductionBenchmark | 448 lines

imports:
  stdlib: [datetime, json, time, dataclasses.{asdict,dataclass}, pathlib.Path, typing.{Any,Dict,List,Optional}]
  third_party: [analyzer.analyze_project, dotenv.load_dotenv, file_formats.{generate_file_csv,generate_file_json,generate_file_yaml}, generators.{CSVGenerator,JSONGenerator,MarkdownGenerator,YAMLGenerator}, gherkin.GherkinGenerator]

FormatResult:
  doc: "Result for a single format test."

BenchmarkResult:
  doc: "Complete benchmark result."

ReproductionBenchmark:
  doc: "Benchmark reproduction quality across formats."
  attrs:
    client: BaseLLMClient=None
  methods:
    __init__:
      sig: (client:BaseLLMClient=None) -> None
      does: "Initialize benchmark."
    generate_spec:
      sig: (file_path:Path, format_name:str, detail:str='full') -> str
      does: "Generate specification in given format."
    reproduce_with_format:
      sig: (file_path:Path, format_name:str, original_code:str) -> FormatResult
      does: "Test reproduction with a specific format."
    run_single:
      sig: (file_path:str, formats:List[str]=None) -> BenchmarkResult
      does: "Run benchmark on a single file."
      side: "Modifies list"
    run_all:
      sig: (files:List[str], output_dir:str=None) -> Dict[str, Any]
      does: "Run benchmark on multiple files."
      side: "Modifies list"
    _generate_summary:
      sig: (results:List[BenchmarkResult]) -> Dict[str, Any]
      does: "Generate summary from benchmark results."
      side: "Modifies list"
    _save_results:
      sig: (output_dir:Path, results:List[BenchmarkResult], summary:Dict) -> None
      does: "Save benchmark results."
      side: "Saves data"
    _generate_report:
      sig: (results:List[BenchmarkResult], summary:Dict) -> str
      does: "Generate markdown benchmark report."
      side: "Modifies list"

functions:
  run_benchmark:
    sig: (files:List[str], output_dir:str='benchmark_results', provider:str=None, model:str=None) -> Dict[str, Any]
    does: "Run reproduction benchmark."

# base_generator.py | ProjectGenerator | 7 lines

imports:
  stdlib: [typing.{Any,Protocol}]
  third_party: [models.ProjectInfo]

ProjectGenerator:
  bases: [Protocol]
  methods:
    generate:
      sig: (project:ProjectInfo) -> Any
      does: "creates"

# terminal.py | ShellRenderer, RenderAPI | 665 lines

imports:
  stdlib: [os, re, sys, typing.{Any,List,Literal,Optional}]

ShellRenderer:
  doc: "Renders colorized markdown output in terminal."
  attrs:
    use_colors: bool=True
    verbose: bool=True
  methods:
    __init__:
      sig: (use_colors:bool=True, verbose:bool=True) -> None
      does: "creates"
    _supports_colors:
      sig: () -> bool
      does: "Check if terminal supports ANSI colors."
    enable_log:
      sig: () -> None
      does: "Enable log buffering for markdown export."
    get_log:
      sig: () -> str
      does: "Get buffered log as clean markdown (no ANSI codes)."
    clear_log:
      sig: () -> None
      does: "Clear log buffer."
      side: "Clears collection"
    _log:
      sig: (text:str) -> None
      does: "Log a line (strips ANSI codes for markdown)."
      side: "Modifies list"
    _c:
      sig: (color:str, text:str) -> str
      does: "Apply color to text."
    heading:
      sig: (level:int, text:str) -> None
      does: "Print a markdown heading."
    codeblock:
      sig: (language:Language, content:str) -> None
      does: "Print a syntax-highlighted code block."
    render_markdown:
      sig: (text:str) -> None
      does: "Render full markdown text with syntax highlighting."
      side: "Modifies list"
    success:
      sig: (message:str) -> None
      does: "Print success message."
    error:
      sig: (message:str) -> None
      does: "Print error message."
    warning:
      sig: (message:str) -> None
      does: "Print warning message."
    info:
      sig: (message:str) -> None
      does: "Print info message."
    status:
      sig: (icon:str, message:str, type:Literal[info,success,warning,error]='info') -> None
      does: "Print status message with icon."
    kv:
      sig: (key:str, value:Any) -> None
      does: "Print key-value pair."
    progress:
      sig: (done:int, total:int, label:str='') -> None
      does: "Print progress bar."
    separator:
      sig: (char:str='─', width:int=60) -> None
      does: "Print separator line."
    table:
      sig: (headers:List[str], rows:List[List[Any]], widths:Optional[List[int]]=None) -> None
      does: "Print a simple table."
    task:
      sig: (name:str, status:Literal[pending,running,done,failed], duration:Optional[float]=None) -> None
      does: "Print task status."

RenderAPI:
  doc: "Convenience API for terminal rendering."
  methods:
    heading:
      sig: (level:int, text:str) -> None
      does: "heading"
      decorators: [staticmethod]
    code:
      sig: (lang:Language, content:str) -> None
      does: "code"
      decorators: [staticmethod]
    codeblock:
      sig: (lang:Language, content:str) -> None
      does: "codeblock"
      decorators: [staticmethod]
    markdown:
      sig: (text:str) -> None
      does: "markdown"
      decorators: [staticmethod]
    success:
      sig: (message:str) -> None
      does: "success"
      decorators: [staticmethod]
    error:
      sig: (message:str) -> None
      does: "error"
      decorators: [staticmethod]
    warning:
      sig: (message:str) -> None
      does: "warning"
      decorators: [staticmethod]
    info:
      sig: (message:str) -> None
      does: "info"
      decorators: [staticmethod]
    status:
      sig: (icon:str, message:str, type:Literal[info,success,warning,error]='info') -> None
      does: "status"
      decorators: [staticmethod]
    kv:
      sig: (key:str, value:Any) -> None
      does: "kv"
      decorators: [staticmethod]
    progress:
      sig: (done:int, total:int, label:str='') -> None
      does: "progress"
      decorators: [staticmethod]
    separator:
      sig: (char:str='─', width:int=60) -> None
      does: "separator"
      decorators: [staticmethod]
    table:
      sig: (headers:List[str], rows:List[List[Any]], widths:Optional[List[int]]=None) -> None
      does: "table"
      decorators: [staticmethod]
    task:
      sig: (name:str, status:Literal[pending,running,done,failed], duration:Optional[float]=None) -> None
      does: "task"
      decorators: [staticmethod]
    inline:
      sig: (text:str) -> str
      does: "inline"
      decorators: [staticmethod]
    print:
      sig: (text:str, color:Optional[str]=None) -> None
      does: "logs"
      decorators: [staticmethod]
    newline:
      sig: () -> None
      does: "newline"
      decorators: [staticmethod]

functions:
  get_renderer:
    sig: (use_colors:bool=True, verbose:bool=True) -> ShellRenderer
    does: "Get or create the global renderer instance."
  set_renderer:
    sig: (renderer:ShellRenderer) -> None
    does: "Set the global renderer instance."
    side: "Sets value"

# toon_format.py | TOONGenerator, TOONParser | 773 lines

imports:
  stdlib: [re, typing.{Any,Dict,List}]
  third_party: [models.{ClassInfo,FunctionInfo,ModuleInfo,ProjectInfo,TypeInfo}, shared_utils.{compact_imports,truncate_docstring}]

TOONGenerator:
  doc: "Generates TOON format output from ProjectInfo."
  attrs:
    delimiter: str=','
    use_tabs: bool=False
  methods:
    __init__:
      sig: (delimiter:str=',', use_tabs:bool=False) -> None
      does: "Initialize TOON generator."
    _short_lang:
      sig: (lang:str) -> str
      does: "short lang"
    _compress_module_path:
      sig: (path:str, prev_dir:Any) -> tuple[str, str]
      does: "Compress repeated directory prefixes for module summary t..."
    generate:
      sig: (project:ProjectInfo, detail:str='standard', no_repeat_name:bool=False) -> str
      does: "Generate TOON format from ProjectInfo."
      side: "Modifies list"
    _generate_modules:
      sig: (modules:List[ModuleInfo], detail:str, no_repeat_name:bool=False) -> List[str]
      does: "Generate modules section."
      side: "Modifies list"
    _generate_types:
      sig: (types:List[TypeInfo], indent:int=0) -> List[str]
      does: "Generate module-level types in TOON format (with enum val..."
      side: "Modifies list"
    _generate_classes:
      sig: (classes:List[ClassInfo], detail:str, indent:int=0) -> List[str]
      does: "Generate classes in TOON format."
      side: "Modifies list"
    _generate_methods:
      sig: (methods:List[FunctionInfo], detail:str='standard', indent:int=0) -> List[str]
      does: "Generate methods in tabular TOON format."
      side: "Modifies list"
    _generate_functions:
      sig: (functions:List[FunctionInfo], detail:str, indent:int=0) -> List[str]
      does: "Generate functions in tabular TOON format."
      side: "Modifies list"
    _build_signature:
      sig: (f:FunctionInfo) -> str
      does: "Build compact signature string without self/cls."
      side: "Modifies list"
    _quote:
      sig: (value:Any) -> str
      does: "Quote a value if necessary for TOON format."
    generate_compact:
      sig: (project:ProjectInfo) -> str
      does: "Generate minimal TOON output."
    generate_full:
      sig: (project:ProjectInfo) -> str
      does: "Generate detailed TOON output."
    generate_schema:
      sig: (format_type:str='standard') -> str
      does: "Generate JSON Schema for the TOON format."
      side: "Updates state"
    generate_ultra_compact:
      sig: (project:ProjectInfo) -> str
      does: "Generate minimal TOON with abbreviated keys."
      side: "Modifies list"

TOONParser:
  doc: "Parse TOON format back to Python dict."
  methods:
    __init__:
      sig: () -> None
      does: "creates"
    parse:
      sig: (content:str) -> Dict[str, Any]
      does: "Parse TOON content to dict."
      side: "Modifies list"
    _parse_value:
      sig: (value:str) -> Any
      does: "Parse a TOON value to Python type."

functions:
  generate_toon:
    sig: (project:ProjectInfo, detail:str='standard', use_tabs:bool=False) -> str
    does: "Convenience function to generate TOON format."
  parse_toon:
    sig: (content:str) -> Dict[str, Any]
    does: "Convenience function to parse TOON content."

# dependency.py | DependencyAnalyzer | 247 lines

imports:
  stdlib: [pathlib.Path, typing.{Dict,List}]
  third_party: [networkx, models.{DependencyNode,ModuleInfo}]

DependencyAnalyzer:
  doc: "Analyzes dependency graphs using NetworkX."
  methods:
    __init__:
      sig: () -> None
      does: "Initialize the dependency analyzer."
    build_graph:
      sig: (modules:List[ModuleInfo]) -> Dict[str, List[str]]
      does: "Build dependency graph from modules."
      side: "Sets value"
    analyze_metrics:
      sig: () -> Dict[str, DependencyNode]
      does: "Compute metrics for each node in the graph."
    get_entrypoints:
      sig: () -> List[str]
      does: "Get entry points (nodes with no incoming edges)."
    get_hubs:
      sig: () -> List[str]
      does: "Get hub modules (high centrality)."
    detect_cycles:
      sig: () -> List[List[str]]
      does: "Detect dependency cycles."
    get_strongly_connected_components:
      sig: () -> List[List[str]]
      does: "Get strongly connected components."
    _detect_clusters:
      sig: () -> Dict[str, int]
      does: "Detect clusters using connected components."
    _module_name:
      sig: (path:str) -> str
      does: "Convert file path to module name."
    get_dependency_depth:
      sig: (module_path:str) -> int
      does: "Get the maximum depth of dependencies for a module."
      side: "Adds element"

functions:
  is_networkx_available:
    sig: () -> bool
    does: "Check if NetworkX is available."

# mcp_server.py | 361 lines

imports:
  stdlib: [json, sys]
  third_party: [__version__]

functions:
  handle_request:
    sig: (request:dict) -> dict
    does: "Handle incoming MCP request."
  call_tool:
    sig: (tool_name:str, arguments:dict) -> str
    does: "Execute a tool and return result."
    edge: "error → raise ValueError"
    side: "Modifies list"
  run_server:
    sig: () -> None
    does: "Run the MCP server."
    side: "Writes data"

# reproduction.py | CodeReproducer | 441 lines

imports:
  stdlib: [datetime, re, pathlib.Path, typing.{Any,Dict,List}]
  third_party: [difflib, llm_clients.{BaseLLMClient,get_client}]

CodeReproducer:
  doc: "Code reproduction workflow using LLM."
  attrs:
    client: BaseLLMClient=None
    provider: str=None
  methods:
    __init__:
      sig: (client:BaseLLMClient=None, provider:str=None) -> None
      does: "Initialize reproducer."
    reproduce_file:
      sig: (source_path:str, output_dir:str=None) -> Dict[str, Any]
      does: "Reproduce code from a source file."
      side: "Saves data"
    generate_from_gherkin:
      sig: (gherkin:str, language:str='python') -> str
      does: "Generate code from Gherkin specification."
    _save_results:
      sig: (output_dir:Path, results:Dict[str,Any]) -> None
      does: "Save reproduction results to files."
      side: "Saves data"
    _generate_report:
      sig: (results:Dict[str,Any]) -> str
      does: "Generate markdown comparison report."

functions:
  generate_file_gherkin:
    sig: (file_path:Path) -> str
    does: "Generate detailed Gherkin specification for a single file..."
    side: "Modifies list"
  compare_code:
    sig: (original:str, generated:str) -> Dict[str, Any]
    does: "Compare original and generated code."
  extract_code_block:
    sig: (text:str, language:str='python') -> str
    does: "Extract code block from LLM response."

# gherkin.py | GherkinScenario, GherkinFeature, StepDefinition +3 | 979 lines

imports:
  stdlib: [re, collections.defaultdict, dataclasses.dataclass, typing.{Any,Dict,List,Optional}]
  third_party: [models.{FunctionInfo,ProjectInfo}]

GherkinScenario:
  doc: "Represents a single Gherkin scenario."

GherkinFeature:
  doc: "Represents a Gherkin feature file."

StepDefinition:
  doc: "Represents a step definition."

GherkinGenerator:
  doc: "Generates Gherkin feature files from code analysis."
  attrs:
    language: str='en'
  methods:
    __init__:
      sig: (language:str='en') -> None
      does: "Initialize GherkinGenerator."
    generate:
      sig: (project:ProjectInfo, detail:str='standard', group_by:str='domain') -> str
      does: "Generate Gherkin feature files from project analysis."
    generate_test_scenarios:
      sig: (project:ProjectInfo, group_by:str='domain') -> List[GherkinFeature]
      does: "Generate structured test scenarios for programmatic use."
    get_step_definitions:
      sig: () -> List[StepDefinition]
      does: "Get all unique step definitions from generated features."
    _extract_features:
      sig: (project:ProjectInfo, group_by:str) -> List[GherkinFeature]
      does: "Extract Gherkin features from project."
      side: "Modifies list"
    _create_feature:
      sig: (group_name:str, items:List[dict], project:ProjectInfo, group_by:str) -> GherkinFeature
      does: "Create a Gherkin feature from grouped items."
      side: "Modifies list"
    _create_scenario:
      sig: (category:str, items:List[dict], domain:str) -> GherkinScenario
      does: "Create a scenario from category items."
      side: "Modifies list"
    _create_edge_case_scenarios:
      sig: (category:str, items:List[dict]) -> List[GherkinScenario]
      does: "Create edge case scenarios for thorough testing."
      side: "Modifies list"
    _create_when_step:
      sig: (func:FunctionInfo, verb:str) -> str
      does: "Create a When step from function info."
    _create_background:
      sig: (domain:str, items:List[dict]) -> Optional[List[str]]
      does: "Create background steps for common setup."
      side: "Sets value"
    _create_examples_table:
      sig: (items:List[dict]) -> List[Dict[str, str]]
      does: "Create Examples table for Scenario Outline."
      side: "Modifies list"
    _extract_param_placeholders:
      sig: (func:FunctionInfo) -> str
      does: "Extract parameter placeholders for Gherkin steps."
      side: "Modifies list"
    _register_step:
      sig: (step_type:str, pattern:str, func:FunctionInfo) -> None
      does: "Register a step definition for later generation."
    _render_features:
      sig: (features:List[GherkinFeature], detail:str) -> str
      does: "Render features to Gherkin text."
      side: "Modifies list"
    _render_feature:
      sig: (feature:GherkinFeature, detail:str) -> str
      does: "Render a single feature."
      side: "Modifies list"
    _render_scenario:
      sig: (scenario:GherkinScenario, detail:str) -> str
      does: "Render a single scenario."
      side: "Modifies list"
    _categorize:
      sig: (name:str) -> str
      does: "Categorize function by name pattern."
    _extract_domain:
      sig: (path:str) -> str
      does: "Extract domain from file path."
    _name_to_readable:
      sig: (name:str) -> str
      does: "Convert function name to readable text."
    _step_to_func_name:
      sig: (step:str) -> str
      does: "Convert step text to valid function name."

StepDefinitionGenerator:
  doc: "Generates step definition stubs from Gherkin features."
  methods:
    generate_pytest_bdd:
      sig: (features:List[GherkinFeature]) -> str
      does: "Generate pytest-bdd step definitions."
      side: "Sets value"
    generate_behave:
      sig: (features:List[GherkinFeature]) -> str
      does: "Generate behave step definitions."
      side: "Sets value"
    generate_cucumber_js:
      sig: (features:List[GherkinFeature]) -> str
      does: "Generate Cucumber.js step definitions."
      side: "Sets value"
    _step_to_func_name:
      sig: (step:str) -> str
      does: "Convert step text to valid function name."

CucumberYAMLGenerator:
  doc: "Generates Cucumber YAML configuration and test data."
  methods:
    generate:
      sig: (project:ProjectInfo, detail:str='standard') -> str
      does: "Generate Cucumber YAML configuration."
      side: "Modifies list"
    _extract_domain:
      sig: (path:str) -> str
      does: "Extract domain from path."
    _categorize:
      sig: (name:str) -> str
      does: "Categorize by name pattern."

functions:
  csv_to_gherkin:
    sig: (csv_content:str, language:str='en') -> str
    does: "Convert CSV analysis directly to Gherkin."
    side: "Modifies list"
  gherkin_to_test_data:
    sig: (gherkin_content:str) -> Dict[str, Any]
    does: "Extract structured test data from Gherkin for LLM process..."
    side: "Modifies list"

# 05_llm_integration.py | 110 lines

imports:
  stdlib: [argparse, os, sys, pathlib.Path]
  third_party: [code2logic.{LLM_CAPABILITIES,OllamaLocalClient,OpenRouterClient,get_client,suggest_refactoring}, dotenv.load_dotenv]

functions:
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 12_comprehensive_analysis_simple.py | 1 lines

# 12_comprehensive_analysis.py | 129 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner}, dotenv.load_dotenv]

functions:
  print_comprehensive_analysis:
    sig: (result) -> None
    does: "Print comprehensive format analysis."
    side: "Modifies list"
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 01_quick_start.py | 72 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [code2logic.{CSVGenerator,GherkinGenerator,analyze_project,quick_analyze}]

functions:
  main:
    sig: () -> None
    does: "main"

# token_efficiency.py | 1 lines

# 15_unified_benchmark.py | 182 lines

imports:
  stdlib: [argparse, os, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner,run_benchmark}, code2logic.llm_clients.get_client, dotenv.load_dotenv]

functions:
  print_format_results:
    sig: (result) -> None
    does: "Print format comparison results."
  print_function_results:
    sig: (result) -> None
    does: "Print function reproduction results."
  print_project_results:
    sig: (result) -> None
    does: "Print project benchmark results."
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 09_async_benchmark.py | 80 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner}, dotenv.load_dotenv]

functions:
  print_results:
    sig: (result) -> None
    does: "Print benchmark results."
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# windsurf_mcp_integration.py | 1 lines

# 11_token_benchmark.py | 93 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner}, dotenv.load_dotenv]

functions:
  print_token_efficiency:
    sig: (result) -> None
    does: "Print token efficiency analysis."
    side: "Modifies list"
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 06_metrics.py | 118 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.{ReproductionMetrics,generate_file_gherkin,get_client}, code2logic.reproduction.extract_code_block, dotenv.load_dotenv]

functions:
  analyze_file:
    sig: (source_path:str, verbose:bool=False, no_llm:bool=False) -> None
    does: "Analyze single file with detailed metrics."
  _template_generate:
    sig: (spec:str) -> str
    does: "Simple template fallback."
    side: "Sets value"
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 10_function_reproduction.py | 72 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner}, dotenv.load_dotenv]

functions:
  print_results:
    sig: (result) -> None
    does: "Print function reproduction results."
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 08_format_benchmark.py | 120 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner}, dotenv.load_dotenv]

functions:
  print_format_comparison:
    sig: (result) -> None
    does: "Print format comparison results."
  print_per_file_results:
    sig: (result) -> None
    does: "Print per-file breakdown."
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# benchmark_report.py | Artifact | 206 lines

imports:
  stdlib: [datetime, json, os, dataclasses.dataclass, pathlib.Path, typing.{Any,Dict,List,Optional,Tuple}]
  third_party: [shlex]

Artifact:

functions:
  _load_json:
    sig: (path:Path) -> Optional[Dict[str, Any]]
    does: "retrieves json"
  _sizeof:
    sig: (path:Path) -> int
    does: "sizeof"
  _fmt_bytes:
    sig: (n:int) -> str
    does: "fmt bytes"
  _token_estimate_bytes:
    sig: (n:int) -> int
    does: "token estimate bytes"
  _calc_function_summary:
    sig: (d:Dict[str,Any]) -> Tuple[int, float, float]
    does: "Return (n_functions, avg_similarity, syntax_ok_rate)."
  _calc_file_summary:
    sig: (d:Dict[str,Any]) -> Tuple[int, float, float, float]
    does: "Return (n_files, avg_score, syntax_ok_rate, runs_ok_rate)."
  _read_commands:
    sig: (commands_path:Path) -> List[str]
    does: "retrieves commands"
  main:
    sig: () -> None
    does: "main"
    side: "Modifies list"

# benchmark_summary.py | 121 lines

imports:
  stdlib: [json, os, sys]

functions:
  _fmt_bytes:
    sig: (n:int) -> str
    does: "fmt bytes"
  _token_estimate_bytes:
    sig: (n:int) -> int
    does: "token estimate bytes"
  _artifact_row:
    sig: (label:str, path:str) -> str
    does: "artifact row"
  main:
    sig: () -> None
    does: "main"
    side: "Sets value"

# 14_repeatability_test.py | RunResult, RepeatabilityResult | 440 lines

imports:
  stdlib: [argparse, datetime, json, sys, time, dataclasses.{dataclass,field}, pathlib.Path, typing.{Dict,List,Optional,Tuple}]
  third_party: [difflib, code2logic.{ReproductionMetrics,analyze_project,get_client}, code2logic.generators.{JSONGenerator,YAMLGenerator}, code2logic.gherkin.GherkinGenerator, dotenv.load_dotenv]

RunResult:
  doc: "Result of a single generation run."

RepeatabilityResult:
  doc: "Repeatability analysis for a format."

functions:
  _template_generate:
    sig: (spec:str, fmt:str, file_name:str) -> str
    does: "Generate minimal Python code without an LLM (baseline mode)."
  generate_spec:
    sig: (project:ProjectInfo, fmt:str) -> str
    does: "Generate specification in given format."
  get_reproduction_prompt:
    sig: (spec:str, fmt:str, file_name:str) -> str
    does: "Generate reproduction prompt."
  calculate_similarity:
    sig: (code1:str, code2:str) -> float
    does: "Calculate similarity between two code strings."
  get_diff:
    sig: (code1:str, code2:str, label1:str='Run 1', label2:str='Run 2') -> List[str]
    does: "Get unified diff between two code versions."
  test_syntax:
    sig: (code:str) -> bool
    does: "Test if code has valid Python syntax."
  run_repeatability_test:
    sig: (file_path:str, formats:List[str], num_runs:int=3, verbose:bool=False, no_llm:bool=False) -> Dict[str, RepeatabilityResult]
    does: "Run repeatability test for given file and formats."
    side: "Modifies list"
  print_repeatability_summary:
    sig: (results:Dict[str,RepeatabilityResult]) -> None
    does: "Print repeatability summary."
  save_repeatability_report:
    sig: (results:Dict[str,RepeatabilityResult], output:str) -> None
    does: "Save repeatability report to JSON."
    side: "Saves data"
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 13_project_benchmark.py | 95 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.benchmarks.{BenchmarkConfig,BenchmarkRunner}, dotenv.load_dotenv]

functions:
  print_project_results:
    sig: (result) -> None
    does: "Print project benchmark results."
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 04_project.py | 75 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.{compare_codebases,reproduce_project}, dotenv.load_dotenv]

functions:
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# behavioral_benchmark.py | CaseResult, FunctionBehaviorResult | 271 lines

imports:
  stdlib: [json, os, dataclasses.{asdict,dataclass}, pathlib.Path, typing]
  third_party: [tempfile, importlib.util]

CaseResult:

FunctionBehaviorResult:

functions:
  _load_module_from_path:
    sig: (path:Path, module_name:str) -> Any
    does: "retrieves module from path"
    edge: "error → raise RuntimeError"
  _exec_function_from_code:
    sig: (code:str, function_name:str) -> Callable[..., Any]
    does: "exec function from code"
    edge: "error → raise RuntimeError"
  _values_equal:
    sig: (got:Any, expected:Any) -> bool
    does: "values equal"
  _run_case:
    sig: (label:str, fn:Callable[Any,Any], expected:Any) -> CaseResult
    does: "starts case"
  _looks_like_template_stub:
    sig: (code:str) -> bool
    does: "looks like template stub"
  _cases_for:
    sig: (function_name:str) -> List[Tuple[str, Callable[[], Tuple[Tuple[Any, ...], Dict[str, Any]]]]]
    does: "Return list of (label, args_kwargs_builder)."
  _apply_env_hook:
    sig: (kwargs:Dict[str,Any]) -> Dict[str, Any]
    does: "apply env hook"
    side: "Removes and returns"
  main:
    sig: () -> None
    does: "main"
    side: "Modifies list"

# 03_reproduction.py | 76 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.{UniversalReproducer,generate_file_gherkin,reproduce_file}, dotenv.load_dotenv]

functions:
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# 06_metrics_simple.py | 1 lines

# 16_terminal_demo.py | 244 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [code2logic.terminal.{ShellRenderer,get_renderer,render,set_renderer}]

functions:
  demo_headings:
    sig: () -> None
    does: "Demo heading styles."
  demo_codeblocks:
    sig: () -> None
    does: "Demo syntax-highlighted code blocks."
  demo_status_messages:
    sig: () -> None
    does: "Demo status messages."
  demo_progress:
    sig: () -> None
    does: "Demo progress bars."
  demo_tasks:
    sig: () -> None
    does: "Demo task status."
  demo_key_value:
    sig: () -> None
    does: "Demo key-value pairs."
  demo_tables:
    sig: () -> None
    does: "Demo table output."
  demo_markdown:
    sig: () -> None
    does: "Demo full markdown rendering."
  demo_log_highlighting:
    sig: () -> None
    does: "Demo log message highlighting."
  main:
    sig: () -> None
    does: "main"
    side: "Adds element"

# duplicate_detection.py | 1 lines

# 02_refactoring.py | 69 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [code2logic.{analyze_quality,find_duplicates,suggest_refactoring}]

functions:
  main:
    sig: () -> None
    does: "main"
    side: "Writes data"

# test_parser_integrity.py | TestFunctionNameExtraction, TestSignatureParsing, TestClassNameIntegrity +8 | 308 lines

imports:
  third_party: [pytest, code2logic.parsers.{TreeSitterParser,UniversalParser,is_tree_sitter_available}]

TestFunctionNameExtraction:
  doc: "Test 1: Verify complete function names are extracted."
  methods:
    test_function_name_not_truncated:
      sig: (parser) -> None
      does: "checks function name not truncated"
    test_multiple_function_names:
      sig: (parser) -> None
      does: "checks multiple function names"

TestSignatureParsing:
  doc: "Test 2: Verify complete signatures with types."
  methods:
    test_signature_with_types:
      sig: (parser) -> None
      does: "checks signature with types"
    test_signature_with_defaults:
      sig: (parser) -> None
      does: "checks signature with defaults"

TestClassNameIntegrity:
  doc: "Test 3: Verify class names have no embedded whitespace."
  methods:
    test_class_name_no_whitespace:
      sig: (parser) -> None
      does: "checks class name no whitespace"
    test_class_with_bases:
      sig: (parser) -> None
      does: "checks class with bases"

TestImportParsing:
  doc: "Test 4: Verify imports are correctly formatted."
  methods:
    test_import_from_statement:
      sig: (parser) -> None
      does: "checks import from statement"
    test_no_duplicate_imports:
      sig: (parser) -> None
      does: "checks no duplicate imports"

TestExportsCompleteness:
  doc: "Test 5: Verify exports contain full function names."
  methods:
    test_exports_complete:
      sig: (parser) -> None
      does: "checks exports complete"

TestDocstringTruncation:
  doc: "Test 6: Verify docstrings are properly truncated."
  methods:
    test_long_docstring_truncated:
      sig: (parser) -> None
      does: "checks long docstring truncated"

TestUnicodeHandling:
  doc: "Test 7: Verify Unicode characters don't break parsing."
  methods:
    test_unicode_in_docstring:
      sig: (parser) -> None
      does: "checks unicode in docstring"

TestNestedClassMethods:
  doc: "Test 8: Verify methods in classes are parsed correctly."
  methods:
    test_class_methods:
      sig: (parser) -> None
      does: "checks class methods"

TestDecoratorCapture:
  doc: "Test 9: Verify decorators are captured in metadata."
  methods:
    test_decorators_captured:
      sig: (parser) -> None
      does: "checks decorators captured"

TestLargeFileHandling:
  doc: "Test 10: Verify large files don't cause truncation."
  methods:
    test_many_functions:
      sig: (parser) -> None
      does: "checks many functions"
      side: "Modifies list"

TestMethodSignatureIntegrity:
  doc: "Additional tests for method signature integrity."
  methods:
    test_init_signature:
      sig: (parser) -> None
      does: "checks init signature"

functions:
  parser:
    sig: () -> None
    does: "parser"
  parse_python:
    sig: (parser, code:str) -> None
    does: "Helper to parse Python code."

# conftest.py | 368 lines

imports:
  stdlib: [pathlib.Path, typing.{Any,Dict}]
  third_party: [pytest, tempfile, code2logic.models.{ClassInfo,FunctionInfo,ModuleInfo,ProjectInfo}]

functions:
  sample_python_code:
    sig: () -> str
    does: "Sample Python code for testing."
  sample_javascript_code:
    sig: () -> str
    does: "Sample JavaScript code for testing."
  sample_java_code:
    sig: () -> str
    does: "Sample Java code for testing."
  temp_project_dir:
    sig: () -> None
    does: "Create a temporary project directory."
  sample_project:
    sig: (temp_project_dir, sample_python_code) -> None
    does: "Create a sample project with Python files."
    side: "Writes data"
  sample_module:
    sig: () -> None
    does: "Create a sample module for testing."
  sample_project_model:
    sig: () -> None
    does: "Create a sample project model for testing."
  mock_llm_config:
    sig: () -> None
    does: "Mock LLM configuration for testing."
  sample_analysis_result:
    sig: () -> None
    does: "Sample analysis result for testing."

# test_yaml_compact.py | TestYAMLShortKeys, TestSelfRemoval, TestImportDeduplication +4 | 241 lines

imports:
  third_party: [pytest, yaml, code2logic.analyze_project, code2logic.generators.YAMLGenerator, code2logic.models.{ClassInfo,FunctionInfo,ModuleInfo,ProjectInfo}]

TestYAMLShortKeys:
  doc: "Test that YAML uses short keys."
  methods:
    test_short_keys_in_module:
      sig: (sample_project) -> None
      does: "Verify modules use short keys."
    test_short_keys_in_class:
      sig: (sample_project) -> None
      does: "Verify classes use short keys."

TestSelfRemoval:
  doc: "Test that 'self' is removed from method signatures."
  methods:
    test_no_self_in_signature:
      sig: (sample_project) -> None
      does: "Verify 'self' is not in method signatures."

TestImportDeduplication:
  doc: "Test that imports are deduplicated."
  methods:
    test_typing_grouped:
      sig: (sample_project) -> None
      does: "Verify typing imports are grouped."

TestEmptyFieldsOmitted:
  doc: "Test that empty fields are omitted."
  methods:
    test_empty_bases_omitted:
      sig: (sample_project) -> None
      does: "Verify empty bases are not included."
    test_empty_decorators_omitted:
      sig: (sample_project) -> None
      does: "Verify empty decorators are not included."

TestMetaLegend:
  doc: "Test that meta.legend provides key transparency."
  methods:
    test_meta_legend_structure:
      sig: (sample_project) -> None
      does: "Verify meta.legend contains all expected key mappings."
    test_meta_legend_in_output:
      sig: (sample_project) -> None
      does: "Verify meta.legend appears in YAML output string."

TestCompactSizeReduction:
  doc: "Test that compact format reduces output size for larger p..."
  methods:
    test_compact_smaller_for_large_projects:
      sig: () -> None
      does: "Verify compact format is smaller for real projects (heade..."

TestDocstringTruncation:
  doc: "Test that docstrings are truncated."
  methods:
    test_class_docstring_truncated:
      sig: (sample_project) -> None
      does: "Verify class docstrings are truncated to 60 chars."

functions:
  sample_project:
    sig: () -> None
    does: "Create a sample project for testing."

# test_formats.py | TestAllFormatsGeneration, TestRustSupport, TestFormatValidation +10 | 559 lines

imports:
  stdlib: [json, pathlib.Path]
  third_party: [code2logic, code2logic.function_logic.FunctionLogicGenerator]

TestAllFormatsGeneration:
  doc: "Test that all formats generate valid output."
  methods:
    test_format_generates_output:
      sig: (sample_project, fmt) -> None
      does: "Test that format generates non-empty output."
    test_format_contains_class_info:
      sig: (sample_project, fmt) -> None
      does: "Test that format contains class information."
    test_format_contains_function_info:
      sig: (sample_project, fmt) -> None
      does: "Test that format contains function information."

TestRustSupport:
  methods:
    test_rust_parsing_finds_top_level_and_impl_methods:
      sig: (rust_sample_project) -> None
      does: "checks rust parsing finds top level and impl methods"
    test_rust_shows_up_in_toon_and_function_logic:
      sig: (rust_sample_project) -> None
      does: "checks rust shows up in toon and function logic"

TestFormatValidation:
  doc: "Test format validation where applicable."
  methods:
    test_yaml_validation_valid:
      sig: (sample_project) -> None
      does: "Test YAML validation passes for generated output."
    test_yaml_validation_invalid:
      sig: () -> None
      does: "Test YAML validation catches invalid input."
    test_json_validation_valid:
      sig: (sample_project) -> None
      does: "Test JSON validation passes for generated output."
    test_json_validation_invalid:
      sig: () -> None
      does: "Test JSON validation catches invalid input."
    test_logicml_validation_valid:
      sig: (sample_project) -> None
      does: "Test LogicML validation passes for generated output."
    test_markdown_validation_valid:
      sig: (sample_project) -> None
      does: "Test Markdown validation passes for generated output."

TestFormatEfficiency:
  doc: "Test format size efficiency."
  methods:
    test_format_sizes:
      sig: (sample_project) -> None
      does: "Compare output sizes across formats."
    test_logicml_compression:
      sig: (sample_project) -> None
      does: "Test LogicML is more compact than YAML."

TestDetailLevels:
  doc: "Test different detail levels."
  methods:
    test_detail_levels_ordering:
      sig: (sample_project, fmt) -> None
      does: "Test compact < standard < full for detail levels."

TestYAMLSpecifics:
  doc: "YAML-specific tests."
  methods:
    test_yaml_parseable:
      sig: (sample_project) -> None
      does: "Test YAML output is parseable."
    test_yaml_includes_imports:
      sig: (sample_project) -> None
      does: "Test YAML includes imports."

TestJSONSpecifics:
  doc: "JSON-specific tests."
  methods:
    test_json_parseable:
      sig: (sample_project) -> None
      does: "Test JSON output is parseable."
    test_json_structure:
      sig: (sample_project) -> None
      does: "Test JSON has expected structure."

TestLogicMLSpecifics:
  doc: "LogicML-specific tests."
  methods:
    test_logicml_has_signatures:
      sig: (sample_project) -> None
      does: "Test LogicML includes sig: markers."
    test_logicml_has_async_markers:
      sig: (samples_project) -> None
      does: "Test LogicML marks async functions."
    test_logicml_token_estimate:
      sig: (sample_project) -> None
      does: "Test LogicML provides token estimate."

TestGherkinSpecifics:
  doc: "Gherkin-specific tests."
  methods:
    test_gherkin_has_feature:
      sig: (sample_project) -> None
      does: "Test Gherkin has Feature keyword."
    test_gherkin_has_scenarios:
      sig: (sample_project) -> None
      does: "Test Gherkin has Scenario keywords."
    test_gherkin_has_steps:
      sig: (sample_project) -> None
      does: "Test Gherkin has Given/When/Then."

TestTOONSpecifics:
  doc: "TOON-specific tests."
  methods:
    test_toon_array_syntax:
      sig: (sample_project) -> None
      does: "Test TOON uses array[N] syntax."
    test_toon_tabular_syntax:
      sig: (sample_project) -> None
      does: "Test TOON uses tabular {fields} syntax."
    test_toon_minimal_quoting:
      sig: (sample_project) -> None
      does: "Test TOON minimizes quotes."
    test_toon_with_tabs:
      sig: (sample_project) -> None
      does: "Test TOON tab delimiter mode."

TestCSVSpecifics:
  doc: "CSV-specific tests."
  methods:
    test_csv_has_header:
      sig: (sample_project) -> None
      does: "Test CSV has header row."
    test_csv_consistent_columns:
      sig: (sample_project) -> None
      does: "Test CSV has consistent column count."

TestCompactSpecifics:
  doc: "Compact format-specific tests."
  methods:
    test_compact_is_small:
      sig: (sample_project) -> None
      does: "Test Compact is smaller than others."
    test_compact_has_summary:
      sig: (sample_project) -> None
      does: "Test Compact includes summary."

TestCrossFormatEquivalence:
  doc: "Test that all formats contain equivalent information."
  methods:
    test_all_formats_have_project_name:
      sig: (sample_project) -> None
      does: "All formats should include project name or module info."
    test_all_formats_have_module_info:
      sig: (sample_project) -> None
      does: "All formats should include module information."

functions:
  sample_code:
    sig: () -> None
    does: "Sample Python code for testing."
  sample_project:
    sig: (tmp_path, sample_code) -> None
    does: "Create a sample project for testing."
    side: "Writes data"
  samples_project:
    sig: () -> None
    does: "Use the actual test samples directory."
  rust_sample_project:
    sig: (tmp_path) -> None
    does: "rust sample project"
    side: "Writes data"
  get_generator:
    sig: (fmt:str) -> None
    does: "Get generator instance for format."
  generate_output:
    sig: (generator, project, detail='standard') -> None
    does: "Generate output handling different return types."
  test_function_logic_toon_js_does_not_default_return_type_to_none:
    sig: (tmp_path) -> None
    does: "checks function logic toon js does not default return type t"
    side: "Writes data"

# test_e2e_projects.py | 106 lines

imports:
  stdlib: [shutil, pathlib.Path]
  third_party: [code2logic.analyze_project, code2logic.generators.YAMLGenerator, logic2code.generator.{Logic2CodeGenerator,Logic2CodeGeneratorConfig}, logic2test.generator.{Logic2TestGenerator,Logic2TestGeneratorConfig}]

functions:
  _repo_root:
    sig: () -> Path
    does: "repo root"
  _copy_example_sample_project:
    sig: (tmp_path:Path) -> Path
    does: "copy example sample project"
  _write_code2logic_compact_yaml:
    sig: (project_dir:Path, out_file:Path) -> None
    does: "logs code2logic compact yaml"
    side: "Writes data"
  test_e2e_pipeline_code2logic_logic2test_logic2code:
    sig: (tmp_path:Path) -> None
    does: "checks e2e pipeline code2logic logic2test logic2code"
    side: "Writes data"
  test_e2e_logic2test_on_examples_input:
    sig: (tmp_path:Path) -> None
    does: "checks e2e logic2test on examples input"
  test_e2e_logic2code_on_examples_input:
    sig: (tmp_path:Path) -> None
    does: "checks e2e logic2code on examples input"

# test_error_handling.py | TestFilesystemErrors, TestParsingErrors, TestGenerationErrors +4 | 490 lines

imports:
  stdlib: [os, pathlib.Path, unittest.mock.{MagicMock,patch}]
  third_party: [pytest, code2logic.{JSONGenerator,YAMLGenerator,analyze_project}, code2logic.errors]

TestFilesystemErrors:
  doc: "Tests for filesystem-related errors."
  methods:
    test_file_not_found:
      sig: (error_handler) -> None
      does: "Test handling of missing files."
    test_permission_denied:
      sig: (error_handler, tmp_path) -> None
      does: "Test handling of permission denied."
      side: "Writes data"
    test_file_too_large:
      sig: (tmp_path) -> None
      does: "Test handling of files exceeding size limit."
      side: "Writes data"
    test_binary_file_detection:
      sig: (error_handler, tmp_path) -> None
      does: "Test detection of binary files."
      side: "Writes data"
    test_encoding_fallback:
      sig: (error_handler, tmp_path) -> None
      does: "Test encoding fallback for non-UTF8 files."
      side: "Writes data"
    test_empty_file:
      sig: (error_handler, tmp_path) -> None
      does: "Test handling of empty files."
      side: "Writes data"

TestParsingErrors:
  doc: "Tests for parsing-related errors."
  methods:
    test_syntax_error_in_python:
      sig: (error_handler, tmp_path) -> None
      does: "Test handling of Python syntax errors."
      side: "Writes data"
    test_deeply_nested_code:
      sig: (error_handler) -> None
      does: "Test handling of deeply nested code that may cause recurs..."
    test_unsupported_language:
      sig: (error_handler) -> None
      does: "Test handling of unsupported languages."

TestGenerationErrors:
  doc: "Tests for output generation errors."
  methods:
    test_yaml_with_special_characters:
      sig: (temp_project) -> None
      does: "Test YAML generation with special characters."
      side: "Writes data"
    test_json_with_unicode:
      sig: (temp_project) -> None
      does: "Test JSON generation with unicode."
      side: "Writes data"
    test_write_to_readonly_location:
      sig: (error_handler, tmp_path) -> None
      does: "Test writing to read-only location."
      side: "Writes data"
    test_write_creates_directories:
      sig: (error_handler, tmp_path) -> None
      does: "Test that write creates parent directories."
      side: "Writes data"

TestErrorHandlerModes:
  doc: "Tests for different error handler modes."
  methods:
    test_lenient_mode_continues:
      sig: (tmp_path) -> None
      does: "Test that lenient mode continues on errors."
    test_strict_mode_stops:
      sig: (tmp_path) -> None
      does: "Test that strict mode stops on first error."
    test_silent_mode_no_logging:
      sig: (tmp_path, caplog) -> None
      does: "Test that silent mode doesn't log."
    test_critical_error_stops_all_modes:
      sig: () -> None
      does: "Test that critical errors stop processing in all modes."

TestIntegration:
  doc: "Integration tests for error handling during full analysis."
  methods:
    test_mixed_valid_invalid_files:
      sig: (tmp_path) -> None
      does: "Test analysis with mix of valid and problematic files."
      side: "Writes data"
    test_nested_folders_with_errors:
      sig: (tmp_path) -> None
      does: "Test analysis of nested folders with various errors."
      side: "Writes data"
    test_large_project_resilience:
      sig: (tmp_path) -> None
      does: "Test resilience with many files."
      side: "Writes data"

TestAnalysisResult:
  doc: "Tests for AnalysisResult class."
  methods:
    test_result_summary:
      sig: () -> None
      does: "Test result summary generation."
      side: "Modifies list"
    test_error_to_dict:
      sig: () -> None
      does: "Test error serialization."

TestEdgeCases:
  doc: "Tests for edge cases and unusual scenarios."
  methods:
    test_very_long_lines:
      sig: (tmp_path) -> None
      does: "Test handling of files with very long lines."
      side: "Writes data"
    test_many_functions:
      sig: (tmp_path) -> None
      does: "Test handling of file with many functions."
      side: "Writes data"
    test_deeply_nested_classes:
      sig: (tmp_path) -> None
      does: "Test handling of deeply nested classes."
      side: "Writes data"
    test_circular_imports_reference:
      sig: (tmp_path) -> None
      does: "Test handling of files with circular import patterns."
      side: "Writes data"

functions:
  error_handler:
    sig: () -> None
    does: "Create a default error handler."
  strict_handler:
    sig: () -> None
    does: "Create a strict error handler."
  temp_project:
    sig: (tmp_path) -> None
    does: "Create a temporary project with various files."
    side: "Writes data"

# __init__.py | 4 lines

# test_shared_utils.py | TestCompactImports, TestDeduplicateImports, TestAbbreviateType +9 | 326 lines

imports:
  third_party: [code2logic.shared_utils]

TestCompactImports:
  doc: "Tests for compact_imports function."
  methods:
    test_groups_submodules:
      sig: () -> None
      does: "Verify submodules are grouped with curly braces."
    test_preserves_standalone:
      sig: () -> None
      does: "Verify standalone imports are preserved."
      side: "Sets value"
    test_limits_output:
      sig: () -> None
      does: "Verify output is limited to max_items."
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty list."
    test_skips_module_module_duplicates:
      sig: () -> None
      does: "Verify module.module duplicates are handled."

TestDeduplicateImports:
  doc: "Tests for deduplicate_imports function."
  methods:
    test_removes_base_when_specific_exists:
      sig: () -> None
      does: "Verify base is removed when more specific import exists."
      side: "Removes element"
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty list."

TestAbbreviateType:
  doc: "Tests for abbreviate_type function."
  methods:
    test_simple_types:
      sig: () -> None
      does: "Verify simple types are abbreviated."
    test_complex_types:
      sig: () -> None
      does: "Verify complex types are abbreviated."
    test_optional_type:
      sig: () -> None
      does: "Verify Optional is abbreviated to ?."
    test_preserves_unknown:
      sig: () -> None
      does: "Verify unknown types are preserved."
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty string."

TestExpandType:
  doc: "Tests for expand_type function."
  methods:
    test_expands_abbreviated:
      sig: () -> None
      does: "Verify abbreviated types are expanded."
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty string."

TestBuildSignature:
  doc: "Tests for build_signature function."
  methods:
    test_removes_self_by_default:
      sig: () -> None
      does: "Verify self is removed by default."
      side: "Removes element"
    test_includes_self_when_requested:
      sig: () -> None
      does: "Verify self is included when requested."
    test_removes_cls:
      sig: () -> None
      does: "Verify cls is also removed."
      side: "Removes element"
    test_abbreviates_types:
      sig: () -> None
      does: "Verify types are abbreviated when requested."
    test_truncates_params:
      sig: () -> None
      does: "Verify excess params are truncated with indicator."
    test_includes_return_type:
      sig: () -> None
      does: "Verify return type is included."
    test_no_return_type:
      sig: () -> None
      does: "Verify no arrow when no return type."

TestRemoveSelfFromParams:
  doc: "Tests for remove_self_from_params function."
  methods:
    test_removes_self:
      sig: () -> None
      does: "Verify self is removed."
      side: "Removes element"
    test_removes_cls:
      sig: () -> None
      does: "Verify cls is removed."
      side: "Removes element"
    test_removes_typed_self:
      sig: () -> None
      does: "Verify self with type annotation is removed."
      side: "Removes element"

TestCategorizeFunction:
  doc: "Tests for categorize_function function."
  methods:
    test_read_category:
      sig: () -> None
      does: "Verify read-related functions are categorized."
    test_create_category:
      sig: () -> None
      does: "Verify create-related functions are categorized."
    test_update_category:
      sig: () -> None
      does: "Verify update-related functions are categorized."
      side: "Updates state"
    test_delete_category:
      sig: () -> None
      does: "Verify delete-related functions are categorized."
      side: "Deletes data"
    test_handles_method_names:
      sig: () -> None
      does: "Verify class.method names are handled."
    test_returns_other_for_unknown:
      sig: () -> None
      does: "Verify unknown patterns return 'other'."

TestExtractDomain:
  doc: "Tests for extract_domain function."
  methods:
    test_extracts_known_domain:
      sig: () -> None
      does: "Verify known domains are extracted."
    test_handles_windows_paths:
      sig: () -> None
      does: "Verify Windows-style paths are handled."
    test_returns_parent_for_unknown:
      sig: () -> None
      does: "Verify parent folder is returned for unknown domains."

TestComputeHash:
  doc: "Tests for compute_hash function."
  methods:
    test_returns_hex_string:
      sig: () -> None
      does: "Verify hash is a hex string."
    test_respects_length:
      sig: () -> None
      does: "Verify hash length is respected."
    test_same_input_same_hash:
      sig: () -> None
      does: "Verify same input produces same hash."
    test_different_input_different_hash:
      sig: () -> None
      does: "Verify different input produces different hash."

TestTruncateDocstring:
  doc: "Tests for truncate_docstring function."
  methods:
    test_truncates_long:
      sig: () -> None
      does: "Verify long docstrings are truncated."
    test_preserves_short:
      sig: () -> None
      does: "Verify short docstrings are preserved."
    test_removes_markers:
      sig: () -> None
      does: "Verify docstring markers are removed."
      side: "Removes element"
    test_stops_at_sentence_end:
      sig: () -> None
      does: "Verify truncation stops at sentence end."
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty string."

TestEscapeForYaml:
  doc: "Tests for escape_for_yaml function."
  methods:
    test_removes_newlines:
      sig: () -> None
      does: "Verify newlines are removed."
      side: "Removes element"
    test_quotes_special_chars:
      sig: () -> None
      does: "Verify special characters cause quoting."
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty string."

TestCleanIdentifier:
  doc: "Tests for clean_identifier function."
  methods:
    test_removes_whitespace:
      sig: () -> None
      does: "Verify whitespace is removed."
      side: "Removes element"
    test_handles_empty:
      sig: () -> None
      does: "Verify empty input returns empty string."

# test_llm_priority.py | 69 lines

imports:
  stdlib: [json, os, pathlib.Path]
  third_party: [pytest, code2logic.llm_clients.{OllamaLocalClient,OpenRouterClient,get_client}]

functions:
  _write_user_llm_config:
    sig: (tmp_path:Path, data:dict) -> Path
    does: "logs user llm config"
    side: "Writes data"
  test_get_client_auto_prefers_override_provider_on_tie:
    sig: (tmp_path:Path, monkeypatch:Any) -> None
    does: "checks get client auto prefers override provider on tie"
    side: "Sets value"
  test_get_client_auto_model_first_uses_model_priority:
    sig: (tmp_path:Path, monkeypatch:Any) -> None
    does: "checks get client auto model first uses model priority"
    side: "Sets value"

# test_llm_profiler.py | TestLLMProfile, TestDefaultProfiles, TestProfileStorage +4 | 556 lines

imports:
  stdlib: [json, os, pathlib.Path, unittest.mock.{Mock,patch}]
  third_party: [code2logic.llm_profiler]

TestLLMProfile:
  doc: "Tests for LLMProfile dataclass."
  methods:
    test_profile_creation:
      sig: () -> None
      does: "Test basic profile creation."
    test_profile_id_consistency:
      sig: () -> None
      does: "Test that same provider/model gives same profile_id."
    test_profile_defaults:
      sig: () -> None
      does: "Test default values."
    test_profile_custom_values:
      sig: () -> None
      does: "Test custom values override defaults."

TestDefaultProfiles:
  doc: "Tests for default profile creation."
  methods:
    test_gpt4_profile:
      sig: () -> None
      does: "Test GPT-4 default profile."
    test_gpt4_turbo_profile:
      sig: () -> None
      does: "Test GPT-4 Turbo default profile."
    test_claude_profile:
      sig: () -> None
      does: "Test Claude default profile."
    test_qwen_coder_profile:
      sig: () -> None
      does: "Test Qwen Coder default profile."
    test_deepseek_profile:
      sig: () -> None
      does: "Test DeepSeek default profile."
    test_llama_70b_profile:
      sig: () -> None
      does: "Test Llama 70B default profile."
    test_llama_7b_profile:
      sig: () -> None
      does: "Test Llama 7B default profile (smaller)."
    test_mistral_profile:
      sig: () -> None
      does: "Test Mistral default profile."
    test_unknown_model_profile:
      sig: () -> None
      does: "Test unknown model gets safe defaults."

TestProfileStorage:
  doc: "Tests for profile storage (save/load)."
  methods:
    test_save_and_load_profile:
      sig: (tmp_path) -> None
      does: "Test saving and loading a profile."
      side: "Saves data"
    test_load_empty_profiles:
      sig: (tmp_path) -> None
      does: "Test loading when no profiles exist."
    test_get_profile:
      sig: (tmp_path) -> None
      does: "Test getting a specific profile."
      side: "Saves data"
    test_get_nonexistent_profile:
      sig: (tmp_path) -> None
      does: "Test getting a profile that doesn't exist."
    test_get_or_create_profile_existing:
      sig: (tmp_path) -> None
      does: "Test get_or_create returns existing profile."
      side: "Saves data"
    test_get_or_create_profile_new:
      sig: (tmp_path) -> None
      does: "Test get_or_create creates new default profile."

TestAdaptiveChunker:
  doc: "Tests for AdaptiveChunker."
  methods:
    test_chunker_creation:
      sig: () -> None
      does: "Test chunker creation with profile."
      side: "Sets value"
    test_chunker_default_profile:
      sig: () -> None
      does: "Test chunker with default profile."
      side: "Sets value"
    test_chunk_small_spec:
      sig: () -> None
      does: "Test chunking a small spec (single chunk)."
    test_chunk_large_spec:
      sig: () -> None
      does: "Test chunking a large spec (multiple chunks)."
    test_chunk_format_adjustment:
      sig: () -> None
      does: "Test that format affects chunk size."
    test_recommend_format_small_spec:
      sig: () -> None
      does: "Test format recommendation for small spec."
    test_recommend_format_large_spec:
      sig: () -> None
      does: "Test format recommendation for large spec."
    test_estimate_chunks_needed:
      sig: () -> None
      does: "Test chunk estimation."

TestLLMProfiler:
  doc: "Tests for LLMProfiler class."
  methods:
    test_profiler_creation:
      sig: () -> None
      does: "Test profiler creation."
    test_profiler_with_unknown_client:
      sig: () -> None
      does: "Test profiler with client missing provider/model."
    test_code_to_spec:
      sig: () -> None
      does: "Test code to spec conversion."
    test_extract_code_with_block:
      sig: () -> None
      does: "Test extracting code from response with code block."
    test_extract_code_without_block:
      sig: () -> None
      does: "Test extracting code from response without code block."
    test_check_syntax_valid:
      sig: () -> None
      does: "Test syntax check with valid code."
    test_check_syntax_invalid:
      sig: () -> None
      does: "Test syntax check with invalid code."
    test_calculate_similarity:
      sig: () -> None
      does: "Test similarity calculation."
    test_run_profile_quick:
      sig: (tmp_path) -> None
      does: "Test quick profile run."
    test_metrics_calculation:
      sig: () -> None
      does: "Test metrics calculation from results."

TestProfileTestCases:
  doc: "Tests for built-in test cases."
  methods:
    test_test_cases_exist:
      sig: () -> None
      does: "Test that test cases are defined."
    test_test_cases_valid_python:
      sig: () -> None
      does: "Test that all test cases are valid Python."
    test_test_cases_have_functions_or_classes:
      sig: () -> None
      does: "Test that test cases contain functions or classes."

TestConvenienceFunctions:
  doc: "Tests for convenience functions."
  methods:
    test_get_adaptive_chunker:
      sig: () -> None
      does: "Test get_adaptive_chunker function."
      side: "Sets value"
    test_profile_llm_function:
      sig: (tmp_path) -> None
      does: "Test profile_llm convenience function."

# test_generators.py | TestMarkdownGenerator, TestCompactGenerator, TestJSONGenerator | 260 lines

imports:
  stdlib: [json]
  third_party: [pytest, code2logic]

TestMarkdownGenerator:
  doc: "Tests for MarkdownGenerator."
  methods:
    test_generate_basic:
      sig: (sample_project) -> None
      does: "Test basic Markdown generation."
    test_generate_includes_modules:
      sig: (sample_project) -> None
      does: "Test that modules are included."
    test_generate_includes_classes:
      sig: (sample_project) -> None
      does: "Test that classes are included."
    test_generate_includes_functions:
      sig: (sample_project) -> None
      does: "Test that functions are included."
    test_generate_includes_entrypoints:
      sig: (sample_project) -> None
      does: "Test that entrypoints are included."
    test_detail_levels:
      sig: (sample_project) -> None
      does: "Test different detail levels."

TestCompactGenerator:
  doc: "Tests for CompactGenerator."
  methods:
    test_generate_basic:
      sig: (sample_project) -> None
      does: "Test basic compact generation."
    test_generate_includes_hubs:
      sig: (sample_project) -> None
      does: "Test that ENTRY is included."
    test_compact_is_smaller:
      sig: (sample_project) -> None
      does: "Test that compact output is smaller than markdown."

TestJSONGenerator:
  doc: "Tests for JSONGenerator."
  methods:
    test_generate_valid_json:
      sig: (sample_project) -> None
      does: "Test that output is valid JSON."
    test_generate_structure:
      sig: (sample_project) -> None
      does: "Test JSON structure."
    test_generate_modules:
      sig: (sample_project) -> None
      does: "Test module structure in JSON."
    test_generate_functions:
      sig: (sample_project) -> None
      does: "Test function structure in JSON."
    test_generate_classes:
      sig: (sample_project) -> None
      does: "Test class structure in JSON."

functions:
  sample_project:
    sig: () -> None
    does: "Create a sample project for testing generators."

# test_reproduction.py | TestYAMLGenerator, TestGherkinGenerator, TestMarkdownGenerator +5 | 289 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [code2logic.{ReproductionMetrics,analyze_project}, code2logic.chunked_reproduction.{chunk_spec,estimate_tokens,get_llm_limit}, code2logic.generators.YAMLGenerator, code2logic.gherkin.GherkinGenerator, code2logic.logicml.{LogicMLGenerator,generate_logicml}, code2logic.markdown_format.MarkdownHybridGenerator]

TestYAMLGenerator:
  doc: "Tests for YAML format generation."
  methods:
    test_yaml_basic:
      sig: () -> None
      does: "Test basic YAML generation."
    test_yaml_includes_classes:
      sig: () -> None
      does: "Test YAML includes class information."
    test_yaml_includes_functions:
      sig: () -> None
      does: "Test YAML includes function information."

TestGherkinGenerator:
  doc: "Tests for Gherkin format generation."
  methods:
    test_gherkin_basic:
      sig: () -> None
      does: "Test basic Gherkin generation."
    test_gherkin_has_scenarios:
      sig: () -> None
      does: "Test Gherkin has scenarios."

TestMarkdownGenerator:
  doc: "Tests for Markdown hybrid format generation."
  methods:
    test_markdown_basic:
      sig: () -> None
      does: "Test basic Markdown generation."
    test_markdown_has_yaml_section:
      sig: () -> None
      does: "Test Markdown has YAML section."

TestReproductionMetrics:
  doc: "Tests for reproduction metrics calculation."
  methods:
    test_metrics_basic:
      sig: () -> None
      does: "Test basic metrics calculation."
    test_metrics_identical_code:
      sig: () -> None
      does: "Test metrics for identical code."
    test_metrics_different_code:
      sig: () -> None
      does: "Test metrics for different code."

TestChunkedReproduction:
  doc: "Tests for chunked reproduction functionality."
  methods:
    test_estimate_tokens:
      sig: () -> None
      does: "Test token estimation."
    test_get_llm_limit:
      sig: () -> None
      does: "Test LLM limit detection."
    test_chunk_yaml_spec:
      sig: () -> None
      does: "Test YAML spec chunking."
    test_chunk_gherkin_spec:
      sig: () -> None
      does: "Test Gherkin spec chunking."

TestProjectAnalysis:
  doc: "Tests for project analysis."
  methods:
    test_analyze_samples:
      sig: () -> None
      does: "Test analyzing samples directory."
    test_analyze_detects_classes:
      sig: () -> None
      does: "Test that analysis detects classes."
    test_analyze_detects_functions:
      sig: () -> None
      does: "Test that analysis detects functions."

TestLogicMLGenerator:
  doc: "Tests for LogicML format generation."
  methods:
    test_logicml_basic:
      sig: () -> None
      does: "Test basic LogicML generation."
    test_logicml_includes_classes:
      sig: () -> None
      does: "Test LogicML includes class information."
    test_logicml_includes_signatures:
      sig: () -> None
      does: "Test LogicML includes function signatures."
    test_logicml_convenience_function:
      sig: () -> None
      does: "Test generate_logicml convenience function."

TestFormatComparison:
  doc: "Tests comparing different formats."
  methods:
    test_yaml_compact:
      sig: () -> None
      does: "Test that YAML produces compact output."
    test_all_formats_produce_output:
      sig: () -> None
      does: "Test all formats produce non-empty output."

# test_intent.py | TestIntentAnalyzer | 504 lines

imports:
  stdlib: [unittest.mock.{Mock,patch}]
  third_party: [pytest, code2logic.intent.{Intent,IntentAnalyzer,IntentType}, code2logic.models.{ClassInfo,FunctionInfo,ModuleInfo,ProjectInfo}]

TestIntentAnalyzer:
  doc: "Test cases for IntentAnalyzer."
  methods:
    test_init:
      sig: () -> None
      does: "Test IntentAnalyzer initialization."
    test_extract_keywords:
      sig: () -> None
      does: "Test keyword extraction from queries."
    test_calculate_intent_confidence:
      sig: () -> None
      does: "Test intent confidence calculation."
    test_identify_target_module:
      sig: (sample_project_model) -> None
      does: "Test target identification for modules."
    test_identify_target_function:
      sig: (sample_project_model) -> None
      does: "Test target identification for functions."
      side: "Modifies list"
    test_identify_target_class:
      sig: (sample_project_model) -> None
      does: "Test target identification for classes."
      side: "Modifies list"
    test_identify_target_project:
      sig: (sample_project_model) -> None
      does: "Test target identification for project-level queries."
    test_generate_description:
      sig: () -> None
      does: "Test description generation for intents."
    test_generate_suggestions_refactor:
      sig: () -> None
      does: "Test suggestion generation for refactor intent."
    test_generate_suggestions_analyze:
      sig: () -> None
      does: "Test suggestion generation for analyze intent."
    test_generate_suggestions_optimize:
      sig: () -> None
      does: "Test suggestion generation for optimize intent."
    test_analyze_intent_refactor:
      sig: (sample_project_model) -> None
      does: "Test intent analysis for refactoring."
    test_analyze_intent_analyze:
      sig: (sample_project_model) -> None
      does: "Test intent analysis for analysis."
    test_analyze_intent_optimize:
      sig: (sample_project_model) -> None
      does: "Test intent analysis for optimization."
    test_analyze_intent_multiple:
      sig: (sample_project_model) -> None
      does: "Test intent analysis with multiple possible intents."
    test_analyze_intent_sorting:
      sig: (sample_project_model) -> None
      does: "Test that intents are sorted by confidence."
    test_detect_code_smells_long_module:
      sig: () -> None
      does: "Test code smell detection for long modules."
    test_detect_code_smells_complex_function:
      sig: () -> None
      does: "Test code smell detection for complex functions."
    test_detect_code_smells_large_class:
      sig: () -> None
      does: "Test code smell detection for large classes."
    test_detect_code_smells_too_many_imports:
      sig: () -> None
      does: "Test code smell detection for too many imports."

functions:
  make_function:
    sig: (name, params=None, complexity=1, lines=5, docstring=None) -> None
    does: "Helper to create FunctionInfo with correct fields."
  make_class:
    sig: (name, methods=None, bases=None) -> None
    does: "Helper to create ClassInfo with correct fields."
  make_module:
    sig: (name, path, functions=None, classes=None, imports=None, lines_total=10) -> None
    does: "Helper to create ModuleInfo with correct fields."
  make_project:
    sig: (name, modules) -> None
    does: "Helper to create ProjectInfo with correct fields."

# test_analyzer.py | TestProjectAnalyzer, TestAnalyzeProjectFunction, TestGetLibraryStatus | 247 lines

imports:
  stdlib: [pathlib.Path, unittest.mock.{Mock,patch}]
  third_party: [pytest, code2logic.analyzer.{ProjectAnalyzer,analyze_project,get_library_status}, code2logic.models.{ModuleInfo,ProjectInfo}]

TestProjectAnalyzer:
  doc: "Test cases for ProjectAnalyzer."
  methods:
    test_init:
      sig: (temp_project_dir) -> None
      does: "Test ProjectAnalyzer initialization."
    test_init_with_verbose:
      sig: (temp_project_dir, capsys) -> None
      does: "Test ProjectAnalyzer initialization with verbose mode."
    test_analyze_returns_project_info:
      sig: (sample_project) -> None
      does: "Test that analyze returns ProjectInfo."
    test_analyze_finds_source_files:
      sig: (sample_project) -> None
      does: "Test that analysis finds Python files."
    test_ignores_non_source_files:
      sig: (temp_project_dir) -> None
      does: "Test that non-source files are ignored."
      side: "Writes data"
    test_ignores_common_dirs:
      sig: (temp_project_dir) -> None
      does: "Test that common directories are ignored."
      side: "Writes data"
    test_analyze_extracts_functions:
      sig: (temp_project_dir) -> None
      does: "Test that analysis extracts functions."
      side: "Writes data"
    test_analyze_extracts_classes:
      sig: (temp_project_dir) -> None
      does: "Test that analysis extracts classes."
      side: "Writes data"
    test_analyze_extracts_imports:
      sig: (temp_project_dir) -> None
      does: "Test that analysis extracts imports."
      side: "Writes data"
    test_analyze_counts_lines:
      sig: (temp_project_dir) -> None
      does: "Test that analysis counts lines."
      side: "Writes data"
    test_analyze_empty_project:
      sig: (temp_project_dir) -> None
      does: "Test analysis of empty project."
    test_detect_entrypoints:
      sig: (temp_project_dir) -> None
      does: "Test entry point detection."
      side: "Writes data"
    test_get_statistics:
      sig: (sample_project) -> None
      does: "Test get_statistics method."
    test_language_detection:
      sig: (temp_project_dir) -> None
      does: "Test language detection from file extensions."
      side: "Writes data"

TestAnalyzeProjectFunction:
  doc: "Test the analyze_project convenience function."
  methods:
    test_analyze_project:
      sig: (sample_project) -> None
      does: "Test analyze_project function."

TestGetLibraryStatus:
  doc: "Test the get_library_status function."
  methods:
    test_get_library_status:
      sig: () -> None
      does: "Test get_library_status function."

# cli.py | 180 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [generator.{GenerationResult,GeneratorConfig,TestGenerator}]

functions:
  main:
    sig: () -> None
    does: "Main CLI entry point."
    side: "Adds element"

# parsers.py | FunctionSpec, ClassSpec, ModuleSpec +2 | 333 lines

imports:
  stdlib: [re, dataclasses.{dataclass,field}, pathlib.Path, typing.{Any,Dict,List,Optional,Union}]

FunctionSpec:
  doc: "Specification of a function/method extracted from logic f..."

ClassSpec:
  doc: "Specification of a class extracted from logic file."

ModuleSpec:
  doc: "Specification of a module extracted from logic file."

ProjectSpec:
  doc: "Full project specification from logic file."

LogicParser:
  doc: "Parser for Code2Logic output formats."
  attrs:
    file_path: Union[str,Path]
  methods:
    __init__:
      sig: (file_path:Union[str,Path]) -> None
      does: "creates"
    parse:
      sig: () -> ProjectSpec
      does: "Parse the logic file and return ProjectSpec."
    _detect_and_parse_format:
      sig: () -> None
      does: "Detect format (YAML/Hybrid/TOON) and parse."
    _parse_yaml:
      sig: () -> None
      does: "Parse YAML or Hybrid YAML format."
      edge: "error → raise ValueError"
    _parse_yaml_simple:
      sig: () -> None
      does: "Simple YAML parser without pyyaml dependency."
      side: "Modifies list"
    _parse_toon:
      sig: () -> None
      does: "Parse TOON format."
      side: "Modifies list"
    _build_project_spec:
      sig: () -> ProjectSpec
      does: "Build ProjectSpec from parsed data."
      side: "Modifies list"
    _build_module_spec:
      sig: (mod_data:Dict) -> ModuleSpec
      does: "Build ModuleSpec from module data."
      side: "Modifies list"
    _build_class_spec:
      sig: (cls_data:Dict, module_path:str) -> ClassSpec
      does: "Build ClassSpec from class data."
      side: "Modifies list"
    _build_function_spec:
      sig: (func_data:Dict, module_path:str, is_method:bool=False, class_name:Optional[str]=None) -> FunctionSpec
      does: "Build FunctionSpec from function data."
    _parse_params_from_sig:
      sig: (sig:str) -> List[str]
      does: "Parse parameter names from signature string."
      side: "Modifies list"

# generator.py | GeneratorConfig, GenerationResult, TestGenerator | 431 lines

imports:
  stdlib: [re, dataclasses.{dataclass,field}, pathlib.Path, typing.{Dict,List,Optional,Union}]
  third_party: [parsers.{ClassSpec,FunctionSpec,LogicParser,ModuleSpec,ProjectSpec}, templates.TestTemplate]

GeneratorConfig:
  doc: "Configuration for test generation."

GenerationResult:
  doc: "Result of test generation."

TestGenerator:
  doc: "Main test generator class."
  attrs:
    logic_file: Union[str,Path]
    config: Optional[GeneratorConfig]=None
  methods:
    __init__:
      sig: (logic_file:Union[str,Path], config:Optional[GeneratorConfig]=None) -> None
      does: "Initialize test generator."
    project:
      sig: @property () -> ProjectSpec
      does: "Lazy-load and cache project spec."
      decorators: [property]
    generate_unit_tests:
      sig: (output_dir:Union[str,Path], modules:Optional[List[str]]=None) -> GenerationResult
      does: "Generate unit tests for the project."
      side: "Writes data"
    _generate_module_tests:
      sig: (module:ModuleSpec) -> tuple
      does: "Generate tests for a single module."
      side: "Modifies list"
    _generate_class_tests:
      sig: (cls:ClassSpec) -> str
      does: "Generate tests for a class and its methods."
      side: "Modifies list"
    _should_test_class:
      sig: (cls:ClassSpec) -> bool
      does: "Determine if a class should have tests generated."
    _should_test_function:
      sig: (func:FunctionSpec) -> bool
      does: "Determine if a function should have tests generated."
    _get_test_filename:
      sig: (module_path:str) -> str
      does: "Generate test filename from module path."
    generate_integration_tests:
      sig: (output_dir:Union[str,Path], entry_points:Optional[List[str]]=None) -> GenerationResult
      does: "Generate integration tests focusing on module interactions."
      side: "Modifies list"
    generate_property_tests:
      sig: (output_dir:Union[str,Path]) -> GenerationResult
      does: "Generate property-based tests using Hypothesis."
      side: "Modifies list"
    summary:
      sig: () -> Dict
      does: "Get summary of what can be generated."

# __init__.py | 20 lines
# Re-export module
type: re-export
exports:
  - generator.TestGenerator
  - generator.GeneratorConfig
  - generator.GenerationResult
  - parsers.LogicParser
  - templates.TestTemplate

# __main__.py | 12 lines
# Re-export module
type: re-export
exports:
  - cli.main

# templates.py | TestTemplate | 252 lines

imports:
  stdlib: [dataclasses.dataclass, typing.{List,Optional}]

TestTemplate:
  doc: "Template for generating test code."
  methods:
    render_test_file_header:
      sig: (module_path:str, imports:List[str]=None) -> str
      does: "Render the header of a test file."
      side: "Modifies list"
    render_function_test:
      sig: (func_name:str, params:List[str], return_type:Optional[str]=None, docstring:Optional[str]=None, is_async:bool=False, class_name:Optional[str]=None) -> str
      does: "Render a test for a function."
      side: "Modifies list"
    render_class_test:
      sig: (class_name:str, bases:List[str], is_dataclass:bool=False, fields:List[dict]=None, docstring:Optional[str]=None) -> str
      does: "Render tests for a class."
      side: "Modifies list"
    render_dataclass_test:
      sig: (class_name:str, fields:List[dict]) -> str
      does: "Render tests specifically for dataclasses."
      side: "Modifies list"

# configure_llm.py | 467 lines

imports:
  stdlib: [datetime, json, os, sys, time, pathlib.Path, typing.{Any,Dict,List,Optional}]
  third_party: [httpx, litellm]

functions:
  log:
    sig: (msg:str, level:str='info') -> None
    does: "Print log message with color."
  check_ollama:
    sig: () -> Dict[str, Any]
    does: "Check Ollama availability and get models."
    side: "Modifies list"
  check_litellm:
    sig: () -> Dict[str, Any]
    does: "Check LiteLLM availability."
  check_env_keys:
    sig: () -> Dict[str, bool]
    does: "Check for API keys in environment."
  categorize_models:
    sig: (models:List[Dict]) -> Dict[str, List[Dict]]
    does: "Categorize Ollama models by type."
    side: "Modifies list"
  get_recommended_models:
    sig: (models:List[Dict]) -> Dict[str, str]
    does: "Get recommended models for different tasks."
  test_model:
    sig: (model:str, timeout:int=30) -> Dict[str, Any]
    does: "Test if a model works."
  save_config:
    sig: (config:Dict[str,Any]) -> None
    does: "Save configuration to file."
    side: "Saves data"
  load_config:
    sig: () -> Dict[str, Any]
    does: "Load configuration from file."
  format_size:
    sig: (size_bytes:int) -> str
    does: "Format size in human readable form."
  main:
    sig: () -> None
    does: "Main entry point."
    side: "Saves data"

# config.py | LLMConfig | 335 lines

imports:
  stdlib: [json, os, dataclasses.{dataclass,field}, pathlib.Path, typing.{Any,Dict,List,Optional}]
  third_party: [yaml, getv.EnvStore]

LLMConfig:
  doc: "LLM configuration container."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"
    from_dict:
      sig: (data:Dict[str,Any]) -> 'LLMConfig'
      does: "from dict"
      decorators: [classmethod]

functions:
  get_config_dir:
    sig: () -> Path
    does: "Get configuration directory path."
  get_config_path:
    sig: () -> Path
    does: "Get user configuration file path."
  load_config:
    sig: () -> LLMConfig
    does: "Load configuration from file."
  save_config:
    sig: (config:LLMConfig) -> None
    does: "Save configuration to file."
    side: "Saves data"
  load_env_file:
    sig: (search_paths:Optional[List[Path]]=None) -> None
    does: "Load environment variables from .env file."
  load_litellm_config:
    sig: (search_paths:Optional[List[Path]]=None) -> Dict[str, Any]
    does: "Load litellm_config.yaml file."
  save_litellm_config:
    sig: (config:Dict[str,Any], path:Optional[Path]=None) -> None
    does: "Save litellm_config.yaml file."
    edge: "error → raise ImportError"
    side: "Saves data"
  get_provider_model:
    sig: (provider:str) -> str
    does: "Get configured model for a provider."
  set_provider_model:
    sig: (provider:str, model:str) -> None
    does: "Set model for a provider."
    side: "Sets value"
  get_api_key:
    sig: (provider:str) -> Optional[str]
    does: "Get API key for a provider."
  set_api_key:
    sig: (provider:str, key:str, env_path:Optional[Path]=None) -> None
    does: "Set API key for a provider in .env file."
    edge: "error → raise ValueError"
    side: "Sets value"
  get_provider_priorities_from_litellm:
    sig: () -> Dict[str, int]
    does: "Extract provider priorities from litellm_config.yaml."

# cli.py | 317 lines

imports:
  stdlib: [argparse, os, sys, pathlib.Path]
  third_party: [config]

functions:
  cmd_status:
    sig: (args) -> int
    does: "Show LLM providers status and configuration."
  cmd_set_provider:
    sig: (args) -> int
    does: "Set default LLM provider."
    side: "Sets value"
  cmd_set_model:
    sig: (args) -> int
    does: "Set model for a specific provider."
    side: "Sets value"
  cmd_key_set:
    sig: (args) -> int
    does: "Set API key for a provider."
    side: "Sets value"
  cmd_key_show:
    sig: (args) -> int
    does: "Show configured API keys (masked)."
  cmd_models:
    sig: (args) -> int
    does: "List recommended models for each provider."
  cmd_test:
    sig: (args) -> int
    does: "Test LLM generation with a simple prompt."
  cmd_config_show:
    sig: (args) -> int
    does: "Show current configuration."
  cmd_priority_set_provider:
    sig: (args) -> int
    does: "Set priority for a provider."
    side: "Sets value"
  cmd_priority_set_mode:
    sig: (args) -> int
    does: "Set priority mode."
    side: "Sets value"
  main:
    sig: () -> None
    does: "Main CLI entry point."
    side: "Adds element"

# rotation.py | ProviderState, RateLimitType, RateLimitInfo +3 | 718 lines

imports:
  stdlib: [datetime, time, collections.deque, dataclasses.{dataclass,field}, datetime.timedelta, enum.Enum, typing]
  third_party: [heapq, threading]

ProviderState:
  doc: "Provider availability state."
  bases: [str, Enum]

RateLimitType:
  doc: "Type of rate limit encountered."
  bases: [str, Enum]

RateLimitInfo:
  doc: "Information about a rate limit event."
  methods:
    get_wait_seconds:
      sig: () -> float
      does: "Calculate how long to wait before retrying."

ProviderHealth:
  doc: "Health metrics for a provider."
  methods:
    success_rate:
      sig: () -> float
      does: "Calculate success rate (0.0 - 1.0)."
    is_available:
      sig: () -> bool
      does: "Check if provider is currently available."
    record_success:
      sig: (latency_ms:float=0) -> None
      does: "Record a successful request."
    record_failure:
      sig: (error:str, is_rate_limit:bool=False, rate_limit_info:Optional[RateLimitInfo]=None) -> None
      does: "Record a failed request."
    _adjust_priority:
      sig: () -> None
      does: "Adjust current priority based on health."
    check_cooldown:
      sig: () -> bool
      does: "Check if cooldown has expired and update state."
    to_dict:
      sig: () -> Dict[str, Any]
      does: "Serialize to dictionary."

RotationQueue:
  doc: "Priority queue for LLM provider rotation with automatic f..."
  attrs:
    max_consecutive_failures: int=3
    default_cooldown_seconds: float=60
    enable_health_recovery: bool=True
  methods:
    __init__:
      sig: (max_consecutive_failures:int=3, default_cooldown_seconds:float=60, enable_health_recovery:bool=True) -> None
      does: "creates"
    add_provider:
      sig: (name:str, priority:int=100) -> None
      does: "Add a provider to the rotation queue."
      side: "Adds element"
    remove_provider:
      sig: (name:str) -> bool
      does: "Remove a provider from the queue."
      side: "Removes element"
    set_priority:
      sig: (name:str, priority:int) -> bool
      does: "Set base priority for a provider (lower = higher priority)."
      side: "Sets value"
    get_priority_order:
      sig: () -> List[str]
      does: "Get providers ordered by current priority."
    get_next:
      sig: () -> Optional[str]
      does: "Get the next available provider with highest priority."
    get_available:
      sig: () -> List[str]
      does: "Get all available providers in priority order."
    record_success:
      sig: (name:str, latency_ms:float=0) -> None
      does: "Record a successful request for a provider."
    record_failure:
      sig: (name:str, error:str, is_rate_limit:bool=False, rate_limit_info:Optional[RateLimitInfo]=None) -> None
      does: "Record a failed request for a provider."
    mark_rate_limited:
      sig: (name:str, rate_limit_info:Optional[RateLimitInfo]=None, cooldown_seconds:Optional[float]=None) -> None
      does: "Manually mark a provider as rate limited."
    reset_provider:
      sig: (name:str) -> bool
      does: "Reset a provider's health metrics."
      side: "Sets value"
    reset_all:
      sig: () -> None
      does: "Reset all providers' health metrics."
      side: "Sets value"
    get_health:
      sig: (name:str) -> Optional[ProviderHealth]
      does: "Get health info for a specific provider."
    get_all_health:
      sig: () -> Dict[str, Dict[str, Any]]
      does: "Get health info for all providers."
    get_status:
      sig: () -> Dict[str, Any]
      does: "Get overall queue status."
    on_provider_unavailable:
      sig: (callback:Callable[Any,None]) -> None
      does: "Set callback for when a provider becomes unavailable."
    on_rate_limit:
      sig: (callback:Callable[Any,None]) -> None
      does: "Set callback for rate limit events."
    on_rotation:
      sig: (callback:Callable[Any,None]) -> None
      does: "Set callback for provider rotation events."

LLMRotationManager:
  doc: "High-level manager for LLM rotation with generation capab..."
  attrs:
    max_retries: int=3
    default_cooldown: float=60.0
    verbose: bool=False
  methods:
    __init__:
      sig: (max_retries:int=3, default_cooldown:float=60.0, verbose:bool=False) -> None
      does: "creates"
    register:
      sig: (name:str, client:Any, priority:int=100) -> None
      does: "Register an LLM client with the rotation manager."
      side: "Adds element"
    unregister:
      sig: (name:str) -> bool
      does: "Unregister a client."
      side: "Removes element"
    set_priority:
      sig: (name:str, priority:int) -> bool
      does: "Set priority for a provider."
      side: "Sets value"
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000, preferred_provider:str=None) -> str
      does: "Generate completion with automatic rotation on failure."
      edge: "error → raise RuntimeError"
      side: "Removes element"
    get_queue:
      sig: () -> RotationQueue
      does: "Get the underlying rotation queue for advanced control."
    get_status:
      sig: () -> Dict[str, Any]
      does: "Get rotation manager status."
    reset:
      sig: () -> None
      does: "Reset all provider health metrics."
      side: "Sets value"

functions:
  parse_rate_limit_headers:
    sig: (headers:Dict[str,str]) -> Optional[RateLimitInfo]
    does: "Parse rate limit information from HTTP response headers."
    side: "Sets value"
  is_rate_limit_error:
    sig: (status_code:int=None, error_message:str=None) -> bool
    does: "Check if an error indicates a rate limit."
  create_rotation_manager:
    sig: (providers:Dict[str,Tuple[Any,int]]=None, verbose:bool=False) -> LLMRotationManager
    does: "Create a rotation manager with providers."

# manager.py | ProviderInfo, LLMManager | 516 lines

imports:
  stdlib: [os, typing.{Dict,List,Optional}]
  third_party: [clients, config.{DEFAULT_MODELS,DEFAULT_PROVIDER_PRIORITIES,LLMConfig,get_provider_model}]

ProviderInfo:
  doc: "Information about a configured provider."
  attrs:
    name: str
    status: LLMProviderStatus
    client: Optional[BaseLLMClient]=None
    model: str=''
    priority: int=100
  methods:
    __init__:
      sig: (name:str, status:LLMProviderStatus, client:Optional[BaseLLMClient]=None, model:str='', priority:int=100) -> None
      does: "creates"

LLMManager:
  doc: "LLM Manager with multi-provider support."
  attrs:
    verbose: bool=False
    enable_rotation: bool=True
  methods:
    __init__:
      sig: (verbose:bool=False, enable_rotation:bool=True) -> None
      does: "creates"
    is_available:
      sig: @property () -> bool
      does: "Check if any provider is available."
      decorators: [property]
    is_ready:
      sig: () -> bool
      does: "Check if manager is initialized and has available provider."
    primary_provider:
      sig: @property () -> Optional[BaseLLMClient]
      does: "Get the primary (first available) provider."
      decorators: [property]
    providers:
      sig: @property () -> Dict[str, ProviderInfo]
      does: "Get all provider info."
      decorators: [property]
    initialize:
      sig: () -> None
      does: "Initialize all configured providers."
      side: "Adds element"
    _init_openrouter:
      sig: () -> None
      does: "Initialize OpenRouter provider."
    _init_ollama:
      sig: () -> None
      does: "Initialize Ollama provider."
    _init_groq:
      sig: () -> None
      does: "Initialize Groq provider."
    _init_together:
      sig: () -> None
      does: "Initialize Together provider."
    _init_litellm:
      sig: () -> None
      does: "Initialize LiteLLM provider."
    _get_effective_priority:
      sig: (provider:str) -> int
      does: "Get effective priority for a provider."
    _get_priority_order:
      sig: () -> List[str]
      does: "Get providers ordered by priority."
    get_client:
      sig: (provider:str=None) -> Optional[BaseLLMClient]
      does: "Get a specific or primary client."
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000, provider:str=None) -> str
      does: "Generate completion using available provider."
      edge: "error → raise RuntimeError"
    generate_with_fallback:
      sig: (prompt:str, system:str=None, max_tokens:int=4000, providers:Optional[List[str]]=None) -> str
      does: "Generate with fallback to other providers on failure."
      edge: "error → raise RuntimeError"
    generate_with_rotation:
      sig: (prompt:str, system:str=None, max_tokens:int=4000, max_retries:int=3) -> str
      does: "Generate with intelligent rotation based on provider health."
    get_rotation_queue:
      sig: () -> Optional[RotationQueue]
      does: "Get the rotation queue for advanced control."
    get_provider_health:
      sig: (name:str=None) -> Dict
      does: "Get health info for providers."
    reset_provider:
      sig: (name:str) -> bool
      does: "Reset a provider's health metrics."
      side: "Sets value"

functions:
  get_client:
    sig: (provider:str=None, model:str=None) -> BaseLLMClient
    does: "Get appropriate LLM client based on provider."
    edge: "error → raise RuntimeError"
    edge: "error → raise ValueError"
  list_available_providers:
    sig: () -> List[str]
    does: "List all available (configured and reachable) providers."

# __init__.py | 119 lines
# Re-export module
type: re-export
exports:
  - config.LLMConfig
  - config.load_config
  - config.save_config
  - config.get_config_path
  - config.get_provider_model
  - config.get_provider_priorities_from_litellm
  - config.DEFAULT_MODELS
  - config.DEFAULT_PROVIDER_PRIORITIES
  - config.RECOMMENDED_MODELS
  - provider.BaseLLMClient
  - provider.LLMProvider
  - provider.LLMProviderStatus
  - provider.LLMResponse
  - provider.LLMModelInfo
  - provider.GenerateOptions
  - clients.OpenRouterClient
  - clients.OllamaClient
  - clients.LiteLLMClient
  - manager.LLMManager
  - manager.ProviderInfo

# __main__.py | 14 lines
# Re-export module
type: re-export
exports:
  - cli.main

# provider.py | LLMProviderStatus, GenerateOptions, LLMResponse +3 | 152 lines

imports:
  stdlib: [abc.{ABC,abstractmethod}, dataclasses.{dataclass,field}, enum.Enum, typing.{Any,Dict,List,Literal,Optional}]

LLMProviderStatus:
  doc: "Provider availability status."
  bases: [str, Enum]

GenerateOptions:
  doc: "Options for LLM generation."
  methods:
    to_messages:
      sig: () -> List[Dict[str, str]]
      does: "Convert to messages format."
      side: "Modifies list"

LLMResponse:
  doc: "Response from LLM generation."

LLMModelInfo:
  doc: "Information about an available model."

BaseLLMClient:
  doc: "Abstract base class for synchronous LLM clients."
  bases: [ABC]
  abstract: true
  attrs:
    provider: str
  methods:
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
      does: "Generate completion."
      decorators: [abstractmethod]
    is_available:
      sig: () -> bool
      does: "Check if client is available."
      decorators: [abstractmethod]
    chat:
      sig: (messages:List[Dict[str,str]], max_tokens:int=4000) -> str
      does: "Chat completion (default implementation)."
      side: "Modifies list"

LLMProvider:
  doc: "Abstract base class for async LLM providers."
  bases: [ABC]
  abstract: true
  methods:
    name:
      sig: @property () -> str
      does: "Provider name."
      decorators: [property, abstractmethod]
    model:
      sig: @property () -> str
      does: "Current model name."
      decorators: [property, abstractmethod]
    is_available:
      sig: async () -> bool
      does: "Check if provider is available."
      decorators: [abstractmethod]
    list_models:
      sig: async () -> List[LLMModelInfo]
      does: "List available models."
      decorators: [abstractmethod]
    generate:
      sig: async (options:GenerateOptions) -> LLMResponse
      does: "Generate completion."
      decorators: [abstractmethod]
    has_model:
      sig: async (model_name:str) -> bool
      does: "Check if specific model is available."
    get_code_models:
      sig: (models:List[LLMModelInfo]) -> List[LLMModelInfo]
      does: "Filter models suitable for code generation."
    close:
      sig: async () -> None
      does: "Close provider connection."
    __aenter__:
      sig: async () -> None
      does: "aenter"
    __aexit__:
      sig: async () -> None
      does: "aexit"

# clients.py | LLMRateLimitError, OpenRouterClient, OllamaClient +3 | 342 lines

imports:
  stdlib: [os, time, typing.{List,Optional}]
  third_party: [httpx, litellm, config.{DEFAULT_MODELS,RECOMMENDED_MODELS,get_provider_model,load_env_file}, provider.{BaseLLMClient,LLMModelInfo}]

LLMRateLimitError:
  doc: "Exception raised when a rate limit is hit."
  bases: [Exception]
  attrs:
    message: str
    provider: str=''
    status_code: int=429
    headers: dict=None
    retry_after: float=None
  methods:
    __init__:
      sig: (message:str, provider:str='', status_code:int=429, headers:dict=None, retry_after:float=None) -> None
      does: "creates"
    __str__:
      sig: () -> None
      does: "str"

OpenRouterClient:
  doc: "OpenRouter API client for cloud LLM access."
  bases: [BaseLLMClient]
  attrs:
    api_key: str=None
    model: str=None
  methods:
    __init__:
      sig: (api_key:str=None, model:str=None) -> None
      does: "Initialize OpenRouter client."
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
      does: "Generate completion using OpenRouter."
      edge: "error → raise ImportError"
      edge: "error → raise ValueError"
      side: "Modifies list"
    is_available:
      sig: () -> bool
      does: "Check if OpenRouter is configured."
    list_recommended_models:
      sig: () -> List[tuple]
      does: "List recommended models for code tasks."
      decorators: [staticmethod]

OllamaClient:
  doc: "Ollama client for local LLM inference."
  bases: [BaseLLMClient]
  attrs:
    model: str=None
    host: str=None
  methods:
    __init__:
      sig: (model:str=None, host:str=None) -> None
      does: "Initialize Ollama client."
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
      does: "Generate completion using Ollama."
      edge: "error → raise ImportError"
      edge: "error → raise RuntimeError"
    is_available:
      sig: () -> bool
      does: "Check if Ollama is running."
    list_models:
      sig: () -> List[str]
      does: "List available Ollama models."
    list_recommended_models:
      sig: () -> List[tuple]
      does: "List recommended models for code tasks."
      decorators: [staticmethod]

LiteLLMClient:
  doc: "LiteLLM client for universal LLM access."
  bases: [BaseLLMClient]
  attrs:
    model: str=None
  methods:
    __init__:
      sig: (model:str=None) -> None
      does: "Initialize LiteLLM client."
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
      does: "Generate completion using LiteLLM."
      edge: "error → raise ImportError"
      edge: "error → raise RuntimeError"
      side: "Modifies list"
    is_available:
      sig: () -> bool
      does: "Check if LiteLLM is available."

GroqClient:
  doc: "Groq API client for fast inference."
  bases: [BaseLLMClient]
  attrs:
    api_key: str=None
    model: str=None
  methods:
    __init__:
      sig: (api_key:str=None, model:str=None) -> None
      does: "creates"
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
      does: "creates"
      edge: "error → raise ImportError"
      edge: "error → raise ValueError"
      side: "Modifies list"
    is_available:
      sig: () -> bool
      does: "is available"

TogetherClient:
  doc: "Together AI client."
  bases: [BaseLLMClient]
  attrs:
    api_key: str=None
    model: str=None
  methods:
    __init__:
      sig: (api_key:str=None, model:str=None) -> None
      does: "creates"
    generate:
      sig: (prompt:str, system:str=None, max_tokens:int=4000) -> str
      does: "creates"
      edge: "error → raise ImportError"
      edge: "error → raise ValueError"
      side: "Modifies list"
    is_available:
      sig: () -> bool
      does: "is available"

# cli.py | 204 lines

imports:
  stdlib: [argparse, sys, pathlib.Path]
  third_party: [generator.{CodeGenerator,GenerationResult,GeneratorConfig}]

functions:
  main:
    sig: () -> None
    does: "Main CLI entry point."
    side: "Adds element"

# generator.py | GeneratorConfig, GenerationResult, CodeGenerator | 303 lines

imports:
  stdlib: [re, sys, dataclasses.{dataclass,field}, pathlib.Path, typing.{Dict,List,Optional,Union}]
  third_party: [logic2test.parsers.{LogicParser,ModuleSpec,ProjectSpec}, renderers.{PythonRenderer,RenderConfig}]

GeneratorConfig:
  doc: "Configuration for code generation."

GenerationResult:
  doc: "Result of code generation."

CodeGenerator:
  doc: "Main code generator class."
  attrs:
    logic_file: Union[str,Path]
    config: Optional[GeneratorConfig]=None
  methods:
    __init__:
      sig: (logic_file:Union[str,Path], config:Optional[GeneratorConfig]=None) -> None
      does: "Initialize code generator."
      edge: "error → raise ValueError"
    project:
      sig: @property () -> ProjectSpec
      does: "Lazy-load and cache project spec."
      decorators: [property]
    generate:
      sig: (output_dir:Union[str,Path], modules:Optional[List[str]]=None) -> GenerationResult
      does: "Generate code for the project."
      side: "Writes data"
    generate_module:
      sig: (module_path:str) -> str
      does: "Generate code for a single module."
      edge: "error → raise ValueError"
    generate_class:
      sig: (class_name:str, module_path:Optional[str]=None) -> str
      does: "Generate code for a single class."
      edge: "error → raise ValueError"
    generate_function:
      sig: (func_name:str, module_path:Optional[str]=None) -> str
      does: "Generate code for a single function."
      edge: "error → raise ValueError"
    _get_output_path:
      sig: (output_dir:Path, module_path:str) -> Path
      does: "Generate output file path from module path."
    summary:
      sig: () -> Dict
      does: "Get summary of what can be generated."
    list_modules:
      sig: () -> List[str]
      does: "List all available module paths."
    list_classes:
      sig: () -> List[str]
      does: "List all available class names with their modules."
      side: "Modifies list"
    list_functions:
      sig: () -> List[str]
      does: "List all available function names with their modules."
      side: "Modifies list"

# renderers.py | RenderConfig, BaseRenderer, PythonRenderer | 417 lines

imports:
  stdlib: [re, sys, abc.{ABC,abstractmethod}, dataclasses.{dataclass,field}, pathlib.Path, typing.{Any,Dict,List,Optional,Set}]
  third_party: [logic2test.parsers.{ClassSpec,FunctionSpec,ModuleSpec}]

RenderConfig:
  doc: "Configuration for code rendering."

BaseRenderer:
  doc: "Abstract base class for language-specific renderers."
  bases: [ABC]
  abstract: true
  attrs:
    config: Optional[RenderConfig]=None
  methods:
    __init__:
      sig: (config:Optional[RenderConfig]=None) -> None
      does: "creates"
    render_module:
      sig: (module:ModuleSpec) -> str
      does: "Render a complete module."
      decorators: [abstractmethod]
    render_class:
      sig: (cls:ClassSpec) -> str
      does: "Render a class definition."
      decorators: [abstractmethod]
    render_function:
      sig: (func:FunctionSpec) -> str
      does: "Render a function definition."
      decorators: [abstractmethod]

PythonRenderer:
  doc: "Python code renderer."
  bases: [BaseRenderer]
  methods:
    render_module:
      sig: (module:ModuleSpec) -> str
      does: "Render a complete Python module."
      side: "Modifies list"
    _collect_imports:
      sig: (module:ModuleSpec) -> str
      does: "Collect and organize imports for a module."
      side: "Sets value"
    _render_constant:
      sig: (const:Dict[str,Any]) -> str
      does: "Render a constant definition."
    render_class:
      sig: (cls:ClassSpec) -> str
      does: "Render a Python class definition."
      side: "Modifies list"
    _render_field:
      sig: (fld:Dict[str,Any]) -> str
      does: "Render a dataclass field."
    _render_method:
      sig: (method:FunctionSpec) -> str
      does: "Render a method (function inside a class)."
    render_function:
      sig: (func:FunctionSpec) -> str
      does: "Render a standalone function."
    _render_function_internal:
      sig: (func:FunctionSpec, is_method:bool=False) -> str
      does: "Internal function rendering logic."
      side: "Modifies list"
    _build_params:
      sig: (func:FunctionSpec, is_method:bool) -> List[str]
      does: "Build parameter list for a function."
      side: "Modifies list"
    _split_params:
      sig: (params_str:str) -> List[str]
      does: "Split parameter string handling nested brackets."
      side: "Modifies list"
    render_init_file:
      sig: (modules:List[ModuleSpec]) -> str
      does: "Render an __init__.py file with exports."
      side: "Modifies list"

# __init__.py | 19 lines
# Re-export module
type: re-export
exports:
  - generator.CodeGenerator
  - generator.GeneratorConfig
  - generator.GenerationResult
  - renderers.PythonRenderer

# __main__.py | 12 lines
# Re-export module
type: re-export
exports:
  - cli.main

# 02_llm_enhanced.py | 114 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [logic2code.{CodeGenerator,GeneratorConfig}]

functions:
  example_llm_generation:
    sig: () -> None
    does: "Generate code with LLM-enhanced implementations."
  example_hybrid_generation:
    sig: () -> None
    does: "Hybrid generation: stubs + LLM for complex functions."
  example_compare_outputs:
    sig: () -> None
    does: "Compare stub vs LLM-generated outputs."

# 01_quickstart.py | 110 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [logic2code.{CodeGenerator,GeneratorConfig}]

functions:
  example_basic_generation:
    sig: () -> None
    does: "Basic code generation from a YAML file."
  example_with_config:
    sig: () -> None
    does: "Code generation with custom configuration."
  example_stubs_only:
    sig: () -> None
    does: "Generate stubs only (no implementations)."
  example_single_module:
    sig: () -> None
    does: "Generate a single module."

# __init__.py | 2 lines

# test_basic.py | 55 lines

imports:
  third_party: [pytest]

functions:
  test_import_logic2code:
    sig: () -> None
    does: "Test that logic2code can be imported."
  test_import_generator:
    sig: () -> None
    does: "Test generator module imports."
  test_config_defaults:
    sig: () -> None
    does: "Test GeneratorConfig has sensible defaults."
  test_generator_config_custom:
    sig: () -> None
    does: "Test GeneratorConfig accepts custom values."
  test_generator_config_llm:
    sig: () -> None
    does: "Test GeneratorConfig LLM options."

# 03_code_generation.py | 124 lines

imports:
  third_party: [lolm.{LLMManager,get_client}]

functions:
  generate_function:
    sig: (description:str) -> str
    does: "Generate a Python function from description."
  generate_class:
    sig: (description:str) -> str
    does: "Generate a Python class from description."
  explain_code:
    sig: (code:str) -> str
    does: "Explain what a piece of code does."
  review_code:
    sig: (code:str) -> str
    does: "Review code for improvements."

# 01_quickstart.py | 92 lines

imports:
  third_party: [lolm.{LLMManager,get_client}]

functions:
  example_simple_client:
    sig: () -> None
    does: "Simple client usage - auto-detect provider."
  example_specific_provider:
    sig: () -> None
    does: "Use a specific provider."
  example_manager:
    sig: () -> None
    does: "Use LLMManager for more control."
  example_fallback:
    sig: () -> None
    does: "Use fallback between providers."

# 02_configuration.py | 120 lines

imports:
  stdlib: [os, pathlib.Path]
  third_party: [lolm]

functions:
  show_defaults:
    sig: () -> None
    does: "Show default configuration values."
  show_recommended_models:
    sig: () -> None
    does: "Show recommended models for each provider."
  show_current_config:
    sig: () -> None
    does: "Show current user configuration."
  example_modify_config:
    sig: () -> None
    does: "Example of modifying configuration."
  show_environment_config:
    sig: () -> None
    does: "Show environment-based configuration."

# __init__.py | 2 lines

# test_basic.py | 68 lines

imports:
  third_party: [pytest]

functions:
  test_import_lolm:
    sig: () -> None
    does: "Test that lolm can be imported."
  test_import_config:
    sig: () -> None
    does: "Test config module imports."
  test_import_clients:
    sig: () -> None
    does: "Test client classes can be imported."
  test_config_defaults:
    sig: () -> None
    does: "Test LLMConfig has sensible defaults."
  test_manager_init:
    sig: () -> None
    does: "Test LLMManager can be instantiated."
  test_recommended_models:
    sig: () -> None
    does: "Test recommended models are defined."

# 01_quickstart.py | 96 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [logic2test.{GeneratorConfig,TestGenerator}]

functions:
  example_basic_generation:
    sig: () -> None
    does: "Basic test generation from a YAML file."
  example_with_config:
    sig: () -> None
    does: "Test generation with custom configuration."
  example_generate_all_types:
    sig: () -> None
    does: "Generate all test types."

# 02_custom_templates.py | 130 lines

imports:
  stdlib: [sys, pathlib.Path]
  third_party: [logic2test.parsers.{ClassSpec,FunctionSpec}, logic2test.templates.TestTemplate]

functions:
  example_function_test:
    sig: () -> None
    does: "Generate a test for a custom function spec."
  example_class_test:
    sig: () -> None
    does: "Generate tests for a custom class spec."
  example_dataclass_test:
    sig: () -> None
    does: "Generate tests for a dataclass."
  example_async_function_test:
    sig: () -> None
    does: "Generate test for an async function."

# __init__.py | 2 lines

# test_basic.py | 43 lines

imports:
  third_party: [pytest]

functions:
  test_import_logic2test:
    sig: () -> None
    does: "Test that logic2test can be imported."
  test_import_generator:
    sig: () -> None
    does: "Test generator module imports."
  test_config_defaults:
    sig: () -> None
    does: "Test GeneratorConfig has sensible defaults."
  test_generator_config_custom:
    sig: () -> None
    does: "Test GeneratorConfig accepts custom values."

# sample_sql.sql | users, products, orders +2 | 94 lines

users:

products:

orders:

order_items:

order_summary:

functions:
  calculate_order_total:
    sig: () -> None
    does: "processes order total"
  update_order_total:
    sig: () -> None
    does: "updates order total"
    side: "Updates state"

# sample_dataclasses.py | User, Product, Order +1 | 83 lines

imports:
  stdlib: [datetime, dataclasses.{dataclass,field}, typing.{Dict,List,Optional}]

User:
  doc: "Represents a user in the system."

Product:
  doc: "Represents a product in the catalog."

Order:
  doc: "Represents a customer order."

Address:
  doc: "Represents a shipping address."

# sample_async.py | Task, TaskResult, AsyncTaskQueue +1 | 211 lines

imports:
  stdlib: [datetime, contextlib.asynccontextmanager, dataclasses.{dataclass,field}, typing.{Any,Dict,List,Optional,TypeVar}]
  third_party: [asyncio]

Task:
  doc: "Async task with status tracking."

TaskResult:
  doc: "Result of task execution."

AsyncTaskQueue:
  doc: "Async task queue with concurrency control."
  attrs:
    max_concurrent: int=5
  methods:
    __init__:
      sig: (max_concurrent:int=5) -> None
      does: "creates"
    add_task:
      sig: async (task:Task) -> None
      does: "Add task to queue."
      side: "Adds element"
    get_task:
      sig: async (task_id:str) -> Optional[Task]
      does: "Get task by ID."
    process_task:
      sig: async (task_id:str, handler) -> TaskResult
      does: "Process a single task with semaphore."
    process_all:
      sig: async (handler) -> List[TaskResult]
      does: "Process all tasks in queue concurrently."
      side: "Modifies list"

AsyncCache:
  doc: "Simple async cache with TTL."
  attrs:
    ttl_seconds: int=300
  methods:
    __init__:
      sig: (ttl_seconds:int=300) -> None
      does: "creates"
    get:
      sig: async (key:str) -> Optional[Any]
      does: "Get value from cache."
    set:
      sig: async (key:str, value:Any) -> None
      does: "Set value in cache."
      side: "Sets value"
    delete:
      sig: async (key:str) -> bool
      does: "Delete value from cache."
      side: "Deletes data"
    clear:
      sig: async () -> None
      does: "Clear all cache entries."
      side: "Clears collection"

functions:
  async_timer:
    sig: async (name:str='operation') -> None
    does: "Async context manager for timing operations."
  fetch_with_retry:
    sig: async (url:str, max_retries:int=3, delay:float=1.0) -> Dict[str, Any]
    does: "Fetch URL with retry logic."
  parallel_map:
    sig: async (items:List[T], handler, max_concurrent:int=5) -> List[Any]
    does: "Apply handler to items in parallel with concurrency limit."
  race:
    sig: async () -> Any
    does: "Return result of first completed coroutine."
    side: "Removes and returns"
  timeout_wrapper:
    sig: async (coro, timeout_seconds:float, default=None) -> None
    does: "Wrap coroutine with timeout, return default on timeout."

# sample_class.py | Calculator | 97 lines

imports:
  stdlib: [typing.{Any,Dict,List,Optional}]

Calculator:
  doc: "Simple calculator with history."
  attrs:
    precision: int=2
  methods:
    __init__:
      sig: (precision:int=2) -> None
      does: "Initialize calculator."
    add:
      sig: (a:float, b:float) -> float
      does: "Add two numbers."
      side: "Adds element"
    subtract:
      sig: (a:float, b:float) -> float
      does: "Subtract b from a."
      side: "Modifies list"
    multiply:
      sig: (a:float, b:float) -> float
      does: "Multiply two numbers."
      side: "Modifies list"
    divide:
      sig: (a:float, b:float) -> Optional[float]
      does: "Divide a by b."
      side: "Modifies list"
    clear_history:
      sig: () -> None
      does: "Clear calculation history."
      side: "Clears collection"
    get_history:
      sig: () -> List[str]
      does: "Get calculation history."

# sample_pydantic.py | TaskStatus, Task, TaskQueue +1 | 79 lines

imports:
  stdlib: [datetime, enum.Enum, typing.{List,Optional}]
  third_party: [pydantic.{BaseModel,Field,field_validator}]

TaskStatus:
  doc: "Task status enumeration."
  bases: [str, Enum]

Task:
  doc: "Task model with Pydantic features."
  bases: [BaseModel]
  attrs:
    id: str
    name: str
    description: Optional[str]
    status: TaskStatus
    priority: int
    created_at: Optional[datetime]
    tags: List[str]
  methods:
    name_not_empty:
      sig: (v:str) -> str
      does: "Validate name is not empty."
      edge: "error → raise ValueError"
      decorators: [classmethod]

TaskQueue:
  doc: "Task queue container."
  bases: [BaseModel]
  attrs:
    name: str
    tasks: List[Task]
    max_size: int
  methods:
    add_task:
      sig: (task:Task) -> bool
      does: "Add task to queue."
      side: "Adds element"
    get_pending:
      sig: () -> List[Task]
      does: "Get pending tasks."
    get_by_status:
      sig: (status:TaskStatus) -> List[Task]
      does: "Get tasks by status."

Project:
  doc: "Project model with nested models."
  bases: [BaseModel]
  attrs:
    id: str
    name: str
    owner: str
    queues: List[TaskQueue]
    metadata: dict
  methods:
    total_tasks:
      sig: () -> int
      does: "Get total task count."

# sample_javascript.js | User, Product | 168 lines

User:
  methods:
    constructor:
      sig: (id, name, email) -> None
      does: "constructor"
    getDisplayName:
      sig: () -> None
      does: "retrieves display name"
    deactivate:
      sig: () -> None
      does: "deactivate"

Product:
  methods:
    constructor:
      sig: (sku, name, price) -> None
      does: "constructor"
    addTags:
      sig: () -> None
      does: "creates tags"
      side: "Adds element"
    isInStock:
      sig: () -> None
      does: "is in stock"
    formatPrice:
      sig: () -> None
      does: "formats price"

functions:
  calculateTotal:
    sig: (items) -> None
    does: "processes total"
  filterBy:
    sig: (arr, predicate) -> None
    does: "filters by"
  fetchData:
    sig: async (url) -> None
    does: "retrieves data"
  debounce:
    sig: (func, wait) -> None
    does: "debounce"
  deepClone:
    sig: (obj) -> None
    does: "deep clone"

# sample_rust.rs | User, Product, Order +3 | 210 lines

imports:
  third_party: [std::collections::HashMap, std::fmt]

User:
  methods:
    id:
      sig: (&self) -> Self::Id
      does: "id"

Product:

Order:
  methods:
    id:
      sig: (&self) -> Self::Id
      does: "id"

OrderItem:

Repository:

AppError:

functions:
  fmt:
    sig: (&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
    does: "fmt"
  id:
    sig: (&self) -> Self::Id;
    does: "id"
  id:
    sig: (&self) -> Self::Id
    does: "id"
  id:
    sig: (&self) -> Self::Id
    does: "id"
  new:
    sig: () -> Self
    does: "creates"
  add:
    sig: (&mut self, item: T) -> None
    does: "creates"
    side: "Adds element"
  get:
    sig: (&self, id: &str) -> Option<&T>
    does: "retrieves"
  get_all:
    sig: (&self) -> Vec<&T>
    does: "retrieves all"
  delete:
    sig: (&mut self, id: &str) -> bool
    does: "deletes"
    side: "Deletes data"
  count:
    sig: (&self) -> usize
    does: "count"
  create_user:
    sig: (id: u64, name: &str, email: &str) -> User
    does: "creates user"
  calculate_order_total:
    sig: (items: &[OrderItem]) -> f64
    does: "processes order total"
  validate_email:
    sig: (email: &str) -> Result<()>
    does: "validates email"
  process_order:
    sig: (mut order: Order) -> Result<Order>
    does: "processes order"
  test_create_user:
    sig: () -> None
    does: "checks create user"
  test_calculate_order_total:
    sig: () -> None
    does: "checks calculate order total"
  test_validate_email:
    sig: () -> None
    does: "checks validate email"

# sample_sql_dsl.py | SQLOperator, JoinType, Condition +4 | 232 lines

imports:
  stdlib: [dataclasses.{dataclass,field}, enum.Enum, typing.{Any,Dict,List,Optional,Union}]

SQLOperator:
  doc: "SQL comparison operators."
  bases: [Enum]

JoinType:
  doc: "SQL join types."
  bases: [Enum]

Condition:
  doc: "SQL WHERE condition."
  methods:
    to_sql:
      sig: () -> str
      does: "Convert to SQL string."

Join:
  doc: "SQL JOIN clause."
  methods:
    to_sql:
      sig: () -> str
      does: "Convert to SQL string."

QueryBuilder:
  doc: "Fluent SQL query builder."
  attrs:
    table: str
  methods:
    __init__:
      sig: (table:str) -> None
      does: "creates"
    select:
      sig: () -> "QueryBuilder"
      does: "Set columns to select."
    where:
      sig: (column:str, operator:Union[SQLOperator,str], value:Any=None) -> "QueryBuilder"
      does: "Add WHERE condition."
      side: "Modifies list"
    join:
      sig: (table:str, on_left:str, on_right:str, join_type:JoinType=JoinType.INNER) -> "QueryBuilder"
      does: "Add JOIN clause."
      side: "Modifies list"
    order_by:
      sig: () -> "QueryBuilder"
      does: "Set ORDER BY columns."
    group_by:
      sig: () -> "QueryBuilder"
      does: "Set GROUP BY columns."
    limit:
      sig: (count:int) -> "QueryBuilder"
      does: "Set LIMIT."
    offset:
      sig: (count:int) -> "QueryBuilder"
      does: "Set OFFSET."
      side: "Sets value"
    build:
      sig: () -> str
      does: "Build the SQL query string."
      side: "Modifies list"

InsertBuilder:
  doc: "SQL INSERT query builder."
  attrs:
    table: str
  methods:
    __init__:
      sig: (table:str) -> None
      does: "creates"
    columns:
      sig: () -> "InsertBuilder"
      does: "Set columns for insert."
    values:
      sig: () -> "InsertBuilder"
      does: "Add values row."
      side: "Modifies list"
    build:
      sig: () -> str
      does: "Build the INSERT query."
      side: "Modifies list"

UpdateBuilder:
  doc: "SQL UPDATE query builder."
  attrs:
    table: str
  methods:
    __init__:
      sig: (table:str) -> None
      does: "creates"
    set:
      sig: (column:str, value:Any) -> "UpdateBuilder"
      does: "Set column value."
      side: "Sets value"
    where:
      sig: (column:str, operator:SQLOperator, value:Any=None) -> "UpdateBuilder"
      does: "Add WHERE condition."
      side: "Modifies list"
    build:
      sig: () -> str
      does: "Build the UPDATE query."
      side: "Sets value"

functions:
  select:
    sig: (table:str) -> QueryBuilder
    does: "Create SELECT query builder."
  insert:
    sig: (table:str) -> InsertBuilder
    does: "Create INSERT query builder."
    side: "Inserts element"
  update:
    sig: (table:str) -> UpdateBuilder
    does: "Create UPDATE query builder."
    side: "Updates state"

# sample_typescript.ts | Repository | 142 lines

Repository:
  methods:
    add:
      sig: (item: T) -> void
      does: "creates"
      side: "Adds element"
    get:
      sig: (id: T['id']) -> Nullable<T>
      does: "retrieves"
    getAll:
      sig: () -> T[]
      does: "retrieves all"
    delete:
      sig: (id: T['id']) -> boolean
      does: "deletes"
      side: "Deletes data"
    count:
      sig: () -> number
      does: "count"

functions:
  createUser:
    sig: (id: number, name: string, email: string) -> User
    does: "creates user"
  calculateOrderTotal:
    sig: (items: OrderItem[]) -> number
    does: "processes order total"
  filterByStatus:
    sig: (items: T[], status: string) -> T[]
    does: "filters by status"
  groupBy:
    sig: (items: T[], key: K) -> Map<T[K], T[]>
    does: "group by"
  fetchUser:
    sig: async (id: number) -> Promise<Result<User>>
    does: "retrieves user"
  processOrder:
    sig: async (order: Order) -> Promise<Result<Order>>
    does: "processes order"

# sample_enum.py | Status, Priority, Color +2 | 96 lines

imports:
  stdlib: [enum.{Enum,IntEnum,auto}, typing.List]

Status:
  doc: "Status enumeration with auto values."
  bases: [Enum]

Priority:
  doc: "Priority levels as integers."
  bases: [IntEnum]

Color:
  doc: "Color enumeration with string values."
  bases: [Enum]
  methods:
    from_hex:
      sig: (hex_code:str) -> "Color"
      does: "Create color from hex code."
      decorators: [classmethod]

HttpStatus:
  doc: "HTTP status codes."
  bases: [IntEnum]
  methods:
    is_success:
      sig: @property () -> bool
      does: "Check if status is success."
      decorators: [property]
    is_error:
      sig: @property () -> bool
      does: "Check if status is error."
      decorators: [property]

TaskType:
  doc: "Task type enumeration."
  bases: [Enum]
  methods:
    get_timeout:
      sig: () -> int
      does: "Get default timeout for task type."
    get_allowed_statuses:
      sig: () -> List[Status]
      does: "Get allowed statuses for this task type."

# sample_algorithms.py | 252 lines

imports:
  stdlib: [functools.lru_cache, typing.{Generator,List,Optional,Tuple,TypeVar}]

functions:
  binary_search:
    sig: (arr:List[int], target:int) -> int
    does: "Binary search implementation."
  quicksort:
    sig: (arr:List[int]) -> List[int]
    does: "Quicksort implementation."
  merge_sort:
    sig: (arr:List[int]) -> List[int]
    does: "Merge sort implementation."
  _merge:
    sig: (left:List[int], right:List[int]) -> List[int]
    does: "Merge two sorted lists."
    side: "Modifies list"
  fibonacci:
    sig: (n:int) -> int
    does: "Calculate nth Fibonacci number with memoization."
  fibonacci_generator:
    sig: (limit:int) -> Generator[int, None, None]
    does: "Generate Fibonacci numbers up to limit."
  is_prime:
    sig: (n:int) -> bool
    does: "Check if number is prime."
  sieve_of_eratosthenes:
    sig: (limit:int) -> List[int]
    does: "Generate all primes up to limit using Sieve of Eratosthenes."
  gcd:
    sig: (a:int, b:int) -> int
    does: "Calculate greatest common divisor using Euclidean algorithm."
  lcm:
    sig: (a:int, b:int) -> int
    does: "Calculate least common multiple."
  levenshtein_distance:
    sig: (s1:str, s2:str) -> int
    does: "Calculate Levenshtein (edit) distance between two strings."
    side: "Modifies list"
  knapsack_01:
    sig: (weights:List[int], values:List[int], capacity:int) -> int
    does: "Solve 0/1 knapsack problem using dynamic programming."

# sample_api.py | APIResponse, User, APIError +1 | 139 lines

imports:
  stdlib: [datetime, json, dataclasses.{dataclass,field}, typing.{Any,Dict,List,Optional}]

APIResponse:
  doc: "Standard API response structure."

User:
  doc: "User model for API."

APIError:
  doc: "Custom API error."
  bases: [Exception]
  attrs:
    message: str
    code: int=400
  methods:
    __init__:
      sig: (message:str, code:int=400) -> None
      does: "creates"

UserAPI:
  doc: "User management API."
  methods:
    __init__:
      sig: () -> None
      does: "creates"
    create_user:
      sig: (username:str, email:str, roles:List[str]=None) -> APIResponse
      does: "Create a new user."
      edge: "error → raise APIError"
    get_user:
      sig: (user_id:int) -> APIResponse
      does: "Get user by ID."
      edge: "error → raise APIError"
    update_user:
      sig: (user_id:int) -> APIResponse
      does: "Update user fields."
      edge: "error → raise APIError"
      side: "Updates state"
    delete_user:
      sig: (user_id:int) -> APIResponse
      does: "Delete user by ID."
      edge: "error → raise APIError"
      side: "Deletes data"
    list_users:
      sig: (limit:int=10, offset:int=0) -> APIResponse
      does: "List all users with pagination."
    search_users:
      sig: (query:str) -> APIResponse
      does: "Search users by username or email."

functions:
  fetch_user_async:
    sig: async (api:UserAPI, user_id:int) -> APIResponse
    does: "Async wrapper for get_user."
  create_user_async:
    sig: async (api:UserAPI, username:str, email:str) -> APIResponse
    does: "Async wrapper for create_user."
  handle_api_error:
    sig: (func) -> None
    does: "Decorator to handle API errors."

# sample_java.java | SampleJava, Identifiable, User | 54 lines

imports:
  third_party: [java.util.{ArrayList,Collections,Comparator,List,Objects}]

SampleJava:

Identifiable:
  interface: true

User:

functions:
  getId:
    sig: () -> String
    does: "retrieves id"
  filterActive:
    sig: (List<User> users) -> List<User>
    does: "filters active"
  sortByName:
    sig: (List<User> users) -> List<User>
    does: "sorts by name"

# sample_functions.py | 124 lines

imports:
  stdlib: [json, os, typing.{Any,Dict,List,Optional}]

functions:
  calculate_total:
    sig: (items:List[int], tax_rate:float=0.1) -> float
    does: "Calculate total with tax."
  filter_by_status:
    sig: (records:List[Dict], status:str) -> List[Dict]
    does: "Filter records by status."
  merge_configs:
    sig: (base:Dict[str,Any], override:Dict[str,Any]) -> Dict[str, Any]
    does: "Merge two configuration dictionaries."
    side: "Updates state"
  validate_email:
    sig: (email:str) -> bool
    does: "Validate email format."
  load_json_file:
    sig: (path:str) -> Optional[Dict]
    does: "Load JSON file safely."
  get_env_or_default:
    sig: (key:str, default:str='') -> str
    does: "Get environment variable or default."
  chunk_list:
    sig: (items:List[Any], chunk_size:int) -> List[List[Any]]
    does: "Split list into chunks."
  format_currency:
    sig: (amount:int, currency:str='USD') -> str
    does: "Format amount as currency."

# sample_csharp.cs | IHasId, User | 37 lines

imports:
  third_party: [System, System.Linq, System.Collections.Generic]

IHasId:
  interface: true

User:

functions:
  FilterActive:
    sig: (IEnumerable<User> users) -> List<User>
    does: "filters active"
  FindById:
    sig: (IEnumerable<User> users, string id) -> User
    does: "retrieves by id"

# sample_go.go | User, Product, Order +3 | 120 lines

imports:
  third_party: [errors]

User:

Product:

Order:

OrderItem:

UserService:

Repository:
  interface: true

functions:
  NewUserService:
    sig: () -> None
    does: "creates user service"
  GetUser:
    sig: (id int) -> (*User, error)
    does: "retrieves user"
  CreateUser:
    sig: (name, email string) -> (*User, error)
    does: "creates user"
  CalculateTotal:
    sig: (items []OrderItem, taxRate float64) -> int64
    does: "processes total"
  FilterProducts:
    sig: (products []Product, predicate func(Product) -> bool
    does: "filters products"
  FormatPrice:
    sig: (cents int64, currency string) -> string
    does: "formats price"

# exceptions.py | ValidationError, ProcessingError | 12 lines

ValidationError:
  doc: "Validation error."
  bases: [Exception]

ProcessingError:
  doc: "Processing error."
  bases: [Exception]

# __init__.py | 22 lines
# Re-export module
type: re-export
exports:
  - models.User
  - models.Order
  - models.Product
  - utils.process_data
  - utils.validate_input
  - exceptions.ValidationError
  - exceptions.ProcessingError

# utils.py | 14 lines

imports:
  stdlib: [typing.{Any,Dict}]

functions:
  process_data:
    sig: (data:Dict[str,Any]) -> Dict[str, Any]
    does: "Process input data."
  validate_input:
    sig: (data:Dict[str,Any]) -> bool
    does: "Validate input data."

# models.py | User, Order, Product | 29 lines

imports:
  stdlib: [dataclasses.dataclass, typing.{List,Optional}]

User:
  doc: "User model."

Order:
  doc: "Order model."

Product:
  doc: "Product model."

# types.ts | 9 lines

# index.ts | 6 lines
# Index re-export file
type: index
pattern: 'export * from ./submodules'

# math.ts | 10 lines

functions:
  add:
    sig: (a: number, b: number) -> number
    does: "creates"
    side: "Adds element"
  multiply:
    sig: (a: number, b: number) -> number
    does: "multiply"

# __init__.py | 2 lines

# calculator.py | Calculator | 30 lines

Calculator:
  doc: "A tiny calculator used for Code2Logic examples."
  methods:
    add:
      sig: (a:float, b:float) -> float
      does: "Return the sum of two numbers."
      side: "Adds element"
    divide:
      sig: (a:float, b:float) -> float
      does: "Divide a by b."
      edge: "error → raise ZeroDivisionError"

functions:
  factorial:
    sig: (n:int) -> int
    does: "Compute n! for n >= 0."
    edge: "error → raise ValueError"

# user.py | User | 14 lines

imports:
  stdlib: [dataclasses.dataclass]

User:
  doc: "Simple user model."

# client.py | Response, APIClient | 24 lines

imports:
  stdlib: [dataclasses.dataclass]

Response:
  doc: "Very small HTTP-like response placeholder."

APIClient:
  doc: "Example client with async methods."
  methods:
    get:
      sig: async (url:str) -> Response
      does: "Fetch a URL."
    post:
      sig: async (url:str, data:dict) -> Response
      does: "Send JSON-like data."

# logicml_schema.py | LogicMLMethod, LogicMLClass, LogicMLModule +1 | 243 lines

imports:
  stdlib: [re, dataclasses.{dataclass,field}, typing.{Any,Dict,List,Optional,Tuple}]

LogicMLMethod:
  doc: "Schema for LogicML method."

LogicMLClass:
  doc: "Schema for LogicML class."

LogicMLModule:
  doc: "Schema for LogicML module."

LogicMLSchema:
  doc: "Complete LogicML specification schema."

functions:
  validate_logicml:
    sig: (spec:str) -> Tuple[bool, List[str]]
    does: "Validate LogicML specification."
    side: "Modifies list"
  parse_logicml_header:
    sig: (line:str) -> Optional[Dict[str, Any]]
    does: "Parse LogicML header comment."
  extract_logicml_signature:
    sig: (sig_line:str) -> Dict[str, Any]
    does: "Extract signature components from LogicML sig: line."

# __init__.py | 30 lines
# Re-export module
type: re-export
exports:
  - json_schema.JSONSchema
  - json_schema.parse_json_spec
  - json_schema.validate_json
  - logicml_schema.LogicMLSchema
  - logicml_schema.validate_logicml
  - markdown_schema.MarkdownSchema
  - markdown_schema.validate_markdown
  - yaml_schema.YAMLSchema
  - yaml_schema.validate_yaml

# yaml_schema.py | MethodSchema, ClassSchema, FunctionSchema +2 | 219 lines

imports:
  stdlib: [dataclasses.{dataclass,field}, typing.{Any,Dict,List,Tuple}]

MethodSchema:
  doc: "Schema for method definition."

ClassSchema:
  doc: "Schema for class definition."

FunctionSchema:
  doc: "Schema for function definition."

ModuleSchema:
  doc: "Schema for module definition."

YAMLSchema:
  doc: "Complete YAML specification schema."

functions:
  validate_yaml:
    sig: (spec:str) -> Tuple[bool, List[str]]
    does: "Validate YAML specification."
    side: "Modifies list"
  _validate_module:
    sig: (module:Dict, index:int) -> List[str]
    does: "Validate a module definition."
    side: "Modifies list"
  _validate_class:
    sig: (cls:Dict, prefix:str) -> List[str]
    does: "Validate a class definition."
    side: "Modifies list"

# json_schema.py | JSONMethodSchema, JSONClassSchema, JSONFunctionSchema +2 | 258 lines

imports:
  stdlib: [json, dataclasses.{dataclass,field}, typing.{Any,Dict,List,Optional,Tuple}]

JSONMethodSchema:
  doc: "Schema for JSON method definition."

JSONClassSchema:
  doc: "Schema for JSON class definition."

JSONFunctionSchema:
  doc: "Schema for JSON function definition."

JSONModuleSchema:
  doc: "Schema for JSON module definition."

JSONSchema:
  doc: "Complete JSON specification schema."

functions:
  validate_json:
    sig: (spec:str) -> Tuple[bool, List[str]]
    does: "Validate JSON specification."
    side: "Modifies list"
  _validate_json_module:
    sig: (module:Dict, index:int) -> List[str]
    does: "Validate a JSON module definition."
    side: "Modifies list"
  _validate_json_class:
    sig: (cls:Dict, prefix:str) -> List[str]
    does: "Validate a JSON class definition."
    side: "Modifies list"
  parse_json_spec:
    sig: (spec:str) -> Optional[JSONSchema]
    does: "Parse JSON specification into schema."
    side: "Modifies list"

# markdown_schema.py | MarkdownMethod, MarkdownClass, MarkdownModule +1 | 172 lines

imports:
  stdlib: [re, dataclasses.{dataclass,field}, typing.{Any,Dict,List,Tuple}]

MarkdownMethod:
  doc: "Schema for Markdown method."

MarkdownClass:
  doc: "Schema for Markdown class."

MarkdownModule:
  doc: "Schema for Markdown module."

MarkdownSchema:
  doc: "Complete Markdown specification schema."

functions:
  validate_markdown:
    sig: (spec:str) -> Tuple[bool, List[str]]
    does: "Validate Markdown specification."
    side: "Modifies list"
  extract_markdown_sections:
    sig: (spec:str) -> Dict[str, Any]
    does: "Extract sections from Markdown specification."

# common.py | 315 lines

imports:
  stdlib: [datetime, json, pathlib.Path]
  third_party: [function_logic.FunctionLogicGenerator, generators.{CSVGenerator,JSONGenerator,YAMLGenerator}, gherkin.GherkinGenerator, logicml.LogicMLGenerator, markdown_format.MarkdownHybridGenerator, models.ProjectInfo, toon_format.TOONGenerator]

functions:
  create_single_project:
    sig: (module_info, file_path:Path) -> ProjectInfo
    does: "creates single project"
  generate_spec:
    sig: (project:ProjectInfo, fmt:str) -> str
    does: "creates spec"
  _generate_token_json:
    sig: (project:ProjectInfo) -> str
    does: "Generate compact, token-friendly JSON spec (used by examp..."
    side: "Modifies list"
  _generate_token_json_compact:
    sig: (project:ProjectInfo) -> str
    does: "creates token json compact"
  generate_spec_token:
    sig: (project:ProjectInfo, fmt:str) -> str
    does: "Generate spec optimized for token benchmark (keeps histor..."
  get_async_reproduction_prompt:
    sig: (spec:str, fmt:str, file_name:str, with_tests:bool=False) -> str
    does: "retrieves async reproduction prompt"
  get_token_reproduction_prompt:
    sig: (spec:str, fmt:str, file_name:str, language:str='python') -> str
    does: "retrieves token reproduction prompt"
  get_simple_reproduction_prompt:
    sig: (spec:str, fmt:str, file_name:str) -> str
    does: "retrieves simple reproduction prompt"

# runner.py | BenchmarkRunner | 1068 lines

imports:
  stdlib: [re, sys, time, pathlib.Path, typing.{Any,Dict,List,Optional}]
  third_party: [difflib, analyzer.analyze_project, common.{create_single_project,generate_spec_token,get_token_reproduction_prompt}, concurrent.futures.{ThreadPoolExecutor,as_completed}, llm_clients.{BaseLLMClient,get_client}, metrics.ReproductionMetrics]

BenchmarkRunner:
  doc: "Unified benchmark runner for code2logic."
  attrs:
    client: Optional[BaseLLMClient]=None
    config: Optional[BenchmarkConfig]=None
  methods:
    __init__:
      sig: (client:Optional[BaseLLMClient]=None, config:Optional[BenchmarkConfig]=None) -> None
      does: "Initialize benchmark runner."
    _should_use_llm:
      sig: () -> bool
      does: "Return whether this runner should call an LLM."
    _get_client:
      sig: () -> BaseLLMClient
      does: "Get or create LLM client."
      edge: "error → raise RuntimeError"
    _template_generate_code:
      sig: (spec:str, fmt:str, file_name:str, language:str='python') -> str
      does: "Generate minimal code without an LLM (fallback mode)."
      side: "Modifies list"
    run_format_benchmark:
      sig: (folder:str, formats:List[str]=None, limit:Optional[int]=None, verbose:bool=False) -> BenchmarkResult
      does: "Run format comparison benchmark."
      side: "Modifies list"
    _test_format:
      sig: (project, original:str, fmt:str, file_name:str, client:Optional[BaseLLMClient], verbose:bool=False) -> FormatResult
      does: "Test a single format."
    run_file_benchmark:
      sig: (file_path:str, formats:List[str]=None, verbose:bool=False) -> BenchmarkResult
      does: "Run benchmark on a single file."
      side: "Modifies list"
    run_function_benchmark:
      sig: (file_path:str, function_names:List[str]=None, limit:Optional[int]=None, verbose:bool=False) -> BenchmarkResult
      does: "Run function-level reproduction benchmark."
      side: "Modifies list"
    _test_function:
      sig: (func, content:str, language:str, file_path:Path, client:Optional[BaseLLMClient], verbose:bool=False) -> FunctionResult
      does: "Test reproduction of a single function."
    run_project_benchmark:
      sig: (project_path:str, formats:List[str]=None, limit:Optional[int]=None, verbose:bool=False) -> BenchmarkResult
      does: "Run benchmark on entire project."
      side: "Modifies list"
    _reproduce_module:
      sig: (module_info, fmt:str, project_root:str, client:Optional[BaseLLMClient], verbose:bool=False) -> FileResult
      does: "Reproduce a single module."

functions:
  _test_python_syntax:
    sig: (code:str) -> bool
    does: "Test if Python code has valid syntax."
  _test_python_runs:
    sig: (code:str, timeout:int=5) -> bool
    does: "Test if Python code runs without errors."
    side: "Writes data"
  _basic_syntax_ok:
    sig: (code:str, language:str) -> bool
    does: "Heuristic syntax check for non-Python languages."
    side: "Modifies list"
  _count_structural_elements:
    sig: (code:str, language:str) -> dict
    does: "count structural elements"
  _structural_score:
    sig: (original:str, generated:str, language:str) -> float
    does: "structural score"
  _extract_code:
    sig: (response:str) -> str
    does: "Extract code from LLM response."
  run_benchmark:
    sig: (source:str, benchmark_type:str='format', formats:List[str]=None, limit:Optional[int]=None, output:Optional[str]=None, verbose:bool=False) -> BenchmarkResult
    does: "Convenience function to run benchmarks."
    edge: "error → raise ValueError"
    side: "Saves data"

# __init__.py | 36 lines
# Re-export module
type: re-export
exports:
  - common.create_single_project
  - common.generate_spec
  - common.generate_spec_token
  - common.get_async_reproduction_prompt
  - common.get_simple_reproduction_prompt
  - common.get_token_reproduction_prompt
  - results.BenchmarkConfig
  - results.BenchmarkResult
  - results.FileResult
  - results.FormatResult
  - results.FunctionResult
  - runner.BenchmarkRunner
  - runner.run_benchmark

# results.py | FormatResult, FileResult, FunctionResult +2 | 230 lines

imports:
  stdlib: [datetime, json, dataclasses.{asdict,dataclass,field}, pathlib.Path, typing.{Any,Dict,List,Optional}]

FormatResult:
  doc: "Result for a single format test."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"

FileResult:
  doc: "Result for single file reproduction."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"

FunctionResult:
  doc: "Result for single function reproduction."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"

BenchmarkResult:
  doc: "Complete benchmark result."
  methods:
    __post_init__:
      sig: () -> None
      does: "creates init"
    calculate_aggregates:
      sig: () -> None
      does: "Calculate aggregate metrics from detailed results."
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"
    to_json:
      sig: (indent:int=2) -> str
      does: "converts json"
    save:
      sig: (path:str) -> None
      does: "Save result to JSON file."
      side: "Saves data"
    load:
      sig: (path:str) -> 'BenchmarkResult'
      does: "Load result from JSON file."
      side: "Removes and returns"
      decorators: [classmethod]

BenchmarkConfig:
  doc: "Configuration for benchmark runs."
  methods:
    to_dict:
      sig: () -> Dict[str, Any]
      does: "converts dict"

# __init__.py | 24 lines
# Re-export module
type: re-export
exports:
  - analyzer.ProjectAnalyzer
  - analyzer.analyze_project
  - dependency.DependencyAnalyzer
  - errors.AnalysisError
  - errors.AnalysisResult
  - errors.ErrorHandler
  - errors.ErrorSeverity
  - errors.ErrorType
  - errors.create_error_handler
  - models.ClassInfo
  - models.DependencyNode
  - models.FunctionInfo
  - models.ModuleInfo
  - models.ProjectInfo
  - models.TypeInfo

# __init__.py | 40 lines
# Re-export module
type: re-export
exports:
  - file_formats.generate_file_csv
  - file_formats.generate_file_json
  - file_formats.generate_file_yaml
  - generators.CompactGenerator
  - generators.CSVGenerator
  - generators.JSONGenerator
  - generators.MarkdownGenerator
  - generators.YAMLGenerator
  - gherkin.CucumberYAMLGenerator
  - gherkin.GherkinGenerator
  - gherkin.StepDefinitionGenerator
  - gherkin.csv_to_gherkin
  - gherkin.gherkin_to_test_data
  - logicml.LogicMLGenerator
  - logicml.LogicMLSpec
  - markdown_format.MarkdownHybridGenerator
  - markdown_format.MarkdownSpec
  - toon_format.TOONGenerator
  - toon_format.TOONParser
  - toon_format.generate_toon

# __init__.py | 31 lines
# Re-export module
type: re-export
exports:
  - adaptive.LLM_CAPABILITIES
  - adaptive.AdaptiveReproducer
  - adaptive.AdaptiveResult
  - adaptive.get_llm_capabilities
  - benchmark.BenchmarkResult
  - benchmark.FormatResult
  - benchmark.ReproductionBenchmark
  - benchmark.run_benchmark
  - code_review.CodeReviewer
  - code_review.analyze_code_quality
  - code_review.check_performance_issues
  - code_review.check_security_issues
  - refactor.DuplicateGroup
  - refactor.RefactoringReport
  - refactor.RefactoringSuggestion
  - refactor.compare_codebases
  - refactor.find_duplicates
  - refactor.quick_analyze
  - refactor.suggest_refactoring

# __init__.py | 53 lines
# Re-export module
type: re-export
exports:
  - importlib.util.module_from_spec
  - importlib.util.spec_from_file_location
  - pathlib.Path
  - intent.EnhancedIntentGenerator
  - llm_clients.DEFAULT_MODELS
  - llm_clients.RECOMMENDED_MODELS
  - llm_clients.BaseLLMClient
  - llm_clients.LiteLLMClient
  - llm_clients.LLMManager
  - llm_clients.OllamaLocalClient
  - llm_clients.OpenRouterClient
  - llm_clients.get_client

# __init__.py | 8 lines
# Re-export module
type: re-export
exports:
  - mcp_server.call_tool
  - mcp_server.handle_request
  - mcp_server.run_server