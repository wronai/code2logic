{
  "name": "code2logic",
  "statistics": {
    "files": 152,
    "lines": 39758,
    "languages": {
      "python": 140,
      "javascript": 3,
      "csharp": 1,
      "go": 1,
      "java": 1,
      "rust": 1,
      "sql": 1,
      "typescript": 4
    }
  },
  "entrypoints": [
    "code2logic/__init__.py",
    "code2logic/__main__.py",
    "code2logic/base_generator.py",
    "code2logic/benchmarks/__init__.py",
    "code2logic/core/__init__.py",
    "code2logic/formats/__init__.py",
    "code2logic/integrations/__init__.py",
    "code2logic/llm.py",
    "code2logic/llm/__init__.py",
    "code2logic/project_reproducer.py"
  ],
  "modules": [
    {
      "path": "code2logic/__init__.py",
      "language": "python",
      "lines": 392,
      "classes": [],
      "functions": [
        {
          "name": "analyze_quality",
          "signature": "(target)",
          "intent": "processes quality",
          "is_async": false
        },
        {
          "name": "reproduce_project",
          "signature": "(source:str)",
          "intent": "reproduce project",
          "is_async": false
        }
      ],
      "imports": [
        "adaptive.LLM_CAPABILITIES",
        "adaptive.AdaptiveReproducer",
        "adaptive.AdaptiveResult",
        "adaptive.get_llm_capabilities",
        "analyzer.ProjectAnalyzer",
        "analyzer.analyze_project",
        "base.BaseGenerator",
        "base.BaseParser",
        "base.VerboseMixin",
        "benchmark.BenchmarkResult"
      ],
      "exports": [
        "analyze_quality",
        "reproduce_project"
      ]
    },
    {
      "path": "code2logic/__main__.py",
      "language": "python",
      "lines": 12,
      "classes": [],
      "functions": [],
      "imports": [
        "cli.main"
      ],
      "exports": []
    },
    {
      "path": "code2logic/adaptive.py",
      "language": "python",
      "lines": 469,
      "classes": [
        {
          "name": "ChunkInfo",
          "bases": [],
          "docstring": "Information about a code chunk."
        },
        {
          "name": "AdaptiveResult",
          "bases": [],
          "docstring": "Result of adaptive reproduction."
        },
        {
          "name": "AdaptiveReproducer",
          "bases": [],
          "docstring": "Adaptive code reproduction with LLM capability detection.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None,model:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_get_capabilities",
              "signature": "()->Dict[str, Any]",
              "intent": "retrieves capabilities",
              "is_async": false
            },
            {
              "name": "select_format",
              "signature": "(file_path:Path,content:str)->str",
              "intent": "retrieves format",
              "is_async": false
            },
            {
              "name": "should_chunk",
              "signature": "(content:str)->bool",
              "intent": "checks chunk",
              "is_async": false
            },
            {
              "name": "chunk_content",
              "signature": "(content:str,file_path:Path)->List[ChunkInfo]",
              "intent": "chunk content",
              "is_async": false
            },
            {
              "name": "generate_chunk_spec",
              "signature": "(chunk:ChunkInfo,format_name:str)->str",
              "intent": "creates chunk spec",
              "is_async": false
            },
            {
              "name": "_gherkin_for_chunk",
              "signature": "(chunk:ChunkInfo)->str",
              "intent": "gherkin for chunk",
              "is_async": false
            },
            {
              "name": "_yaml_for_chunk",
              "signature": "(chunk:ChunkInfo)->str",
              "intent": "yaml for chunk",
              "is_async": false
            },
            {
              "name": "_json_for_chunk",
              "signature": "(chunk:ChunkInfo)->str",
              "intent": "json for chunk",
              "is_async": false
            },
            {
              "name": "reproduce",
              "signature": "(file_path:str,output_dir:str=None)->AdaptiveResult",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_reproduce_single",
              "signature": "(path:Path,content:str,format_name:str,output_dir:str=None)->AdaptiveResult",
              "intent": "reproduce single",
              "is_async": false
            },
            {
              "name": "_reproduce_chunked",
              "signature": "(path:Path,content:str,format_name:str,output_dir:str=None)->AdaptiveResult",
              "intent": "reproduce chunked",
              "is_async": false
            },
            {
              "name": "_generate_from_spec",
              "signature": "(spec:str,format_name:str,file_ext:str)->str",
              "intent": "creates from spec",
              "is_async": false
            },
            {
              "name": "_save_result",
              "signature": "(output_dir:Path,original:str,spec:str,generated:str...+1)",
              "intent": "caches result",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_llm_capabilities",
          "signature": "(model:str)->Dict[str, Any]",
          "intent": "retrieves llm capabilities",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "dotenv.load_dotenv",
        "file_formats.generate_file_csv",
        "file_formats.generate_file_json",
        "file_formats.generate_file_yaml",
        "llm_clients.BaseLLMClient"
      ],
      "exports": [
        "LLM_CAPABILITIES",
        "ChunkInfo",
        "AdaptiveResult",
        "AdaptiveReproducer",
        "get_llm_capabilities"
      ]
    },
    {
      "path": "code2logic/analyzer.py",
      "language": "python",
      "lines": 410,
      "classes": [
        {
          "name": "ProjectAnalyzer",
          "bases": [],
          "docstring": "Main class for analyzing software projects.",
          "methods": [
            {
              "name": "_language_from_shebang",
              "signature": "(first_line:str)->Optional[str]",
              "intent": "language from shebang",
              "is_async": false
            },
            {
              "name": "__init__",
              "signature": "(root_path:str,use_treesitter:bool=True,verbose:bool=False,include_private:bool=False...+2)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_print_status",
              "signature": "()",
              "intent": "logs status",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "()->ProjectInfo",
              "intent": "processes",
              "is_async": false
            },
            {
              "name": "_scan_files",
              "signature": "()",
              "intent": "scan files",
              "is_async": false
            },
            {
              "name": "_get_git_nonignored_files",
              "signature": "()->Optional[List[Path]]",
              "intent": "retrieves git nonignored files",
              "is_async": false
            },
            {
              "name": "_detect_entrypoints",
              "signature": "()->List[str]",
              "intent": "detect entrypoints",
              "is_async": false
            },
            {
              "name": "get_statistics",
              "signature": "()->Dict",
              "intent": "retrieves statistics",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_project",
          "signature": "(path:str,use_treesitter:bool=True,verbose:bool=False)->ProjectInfo",
          "intent": "processes project",
          "is_async": false
        },
        {
          "name": "get_library_status",
          "signature": "()->Dict[str, bool]",
          "intent": "retrieves library status",
          "is_async": false
        }
      ],
      "imports": [
        "logging",
        "os",
        "subprocess",
        "sys",
        "time",
        "collections.defaultdict",
        "datetime",
        "pathlib.Path",
        "typing.Dict",
        "typing.List"
      ],
      "exports": [
        "ProjectAnalyzer",
        "analyze_project",
        "get_library_status"
      ]
    },
    {
      "path": "code2logic/base.py",
      "language": "python",
      "lines": 49,
      "classes": [
        {
          "name": "VerboseMixin",
          "bases": [],
          "docstring": "Mixin providing verbose logging functionality.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "log",
              "signature": "(msg:str,level:str='info')",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "debug",
              "signature": "(msg:str)",
              "intent": "debug",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(msg:str)",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "warn",
              "signature": "(msg:str)",
              "intent": "warn",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(msg:str)",
              "intent": "error",
              "is_async": false
            }
          ]
        },
        {
          "name": "BaseParser",
          "bases": [
            "VerboseMixin"
          ],
          "docstring": "Base class for code parsers.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(content:str,language:str=None)",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "parse_file",
              "signature": "(path:str)",
              "intent": "parses file",
              "is_async": false
            }
          ]
        },
        {
          "name": "BaseGenerator",
          "bases": [
            "VerboseMixin"
          ],
          "docstring": "Base class for output generators.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project,detail:str='full')->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "logging"
      ],
      "exports": [
        "VerboseMixin",
        "BaseParser",
        "BaseGenerator"
      ]
    },
    {
      "path": "code2logic/base_generator.py",
      "language": "python",
      "lines": 5,
      "classes": [
        {
          "name": "ProjectGenerator",
          "bases": [
            "Protocol"
          ],
          "docstring": null,
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo)->Any",
              "intent": "creates",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "typing.Protocol",
        "typing.Any",
        "models.ProjectInfo"
      ],
      "exports": [
        "ProjectGenerator"
      ]
    },
    {
      "path": "code2logic/benchmark.py",
      "language": "python",
      "lines": 349,
      "classes": [
        {
          "name": "FormatResult",
          "bases": [],
          "docstring": "Result for a single format test."
        },
        {
          "name": "BenchmarkResult",
          "bases": [],
          "docstring": "Complete benchmark result."
        },
        {
          "name": "ReproductionBenchmark",
          "bases": [],
          "docstring": "Benchmark reproduction quality across formats.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_spec",
              "signature": "(file_path:Path,format_name:str,detail:str='full')->str",
              "intent": "creates spec",
              "is_async": false
            },
            {
              "name": "reproduce_with_format",
              "signature": "(file_path:Path,format_name:str,original_code:str)->FormatResult",
              "intent": "reproduce with format",
              "is_async": false
            },
            {
              "name": "run_single",
              "signature": "(file_path:str,formats:List[str]=None)->BenchmarkResult",
              "intent": "starts single",
              "is_async": false
            },
            {
              "name": "run_all",
              "signature": "(files:List[str],output_dir:str=None)->Dict[str, Any]",
              "intent": "starts all",
              "is_async": false
            },
            {
              "name": "_generate_summary",
              "signature": "(results:List[BenchmarkResult])->Dict[str, Any]",
              "intent": "creates summary",
              "is_async": false
            },
            {
              "name": "_save_results",
              "signature": "(output_dir:Path,results:List[BenchmarkResult],summary:Dict)",
              "intent": "caches results",
              "is_async": false
            },
            {
              "name": "_generate_report",
              "signature": "(results:List[BenchmarkResult],summary:Dict)->str",
              "intent": "creates report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "run_benchmark",
          "signature": "(files:List[str],output_dir:str='benchmark_results',provider:str=None,model:str=None)->Dict[str, Any]",
          "intent": "starts benchmark",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "time",
        "dotenv.load_dotenv",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "datetime",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List"
      ],
      "exports": [
        "FormatResult",
        "BenchmarkResult",
        "FORMAT_PROMPTS",
        "ReproductionBenchmark",
        "run_benchmark"
      ]
    },
    {
      "path": "code2logic/benchmarks/__init__.py",
      "language": "python",
      "lines": 34,
      "classes": [],
      "functions": [],
      "imports": [
        "common.create_single_project",
        "common.generate_spec",
        "common.generate_spec_token",
        "common.get_async_reproduction_prompt",
        "common.get_simple_reproduction_prompt",
        "common.get_token_reproduction_prompt",
        "results.BenchmarkConfig",
        "results.BenchmarkResult",
        "results.FileResult",
        "results.FormatResult"
      ],
      "exports": []
    },
    {
      "path": "code2logic/benchmarks/common.py",
      "language": "python",
      "lines": 327,
      "classes": [],
      "functions": [
        {
          "name": "create_single_project",
          "signature": "(module_info,file_path:Path)->ProjectInfo",
          "intent": "creates single project",
          "is_async": false
        },
        {
          "name": "generate_spec",
          "signature": "(project:ProjectInfo,fmt:str)->str",
          "intent": "creates spec",
          "is_async": false
        },
        {
          "name": "_generate_token_json",
          "signature": "(project:ProjectInfo)->str",
          "intent": "creates token json",
          "is_async": false
        },
        {
          "name": "_generate_token_json_compact",
          "signature": "(project:ProjectInfo)->str",
          "intent": "creates token json compact",
          "is_async": false
        },
        {
          "name": "generate_spec_token",
          "signature": "(project:ProjectInfo,fmt:str)->str",
          "intent": "creates spec token",
          "is_async": false
        },
        {
          "name": "get_async_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str,with_tests:bool=False)->str",
          "intent": "retrieves async reproduction prompt",
          "is_async": false
        },
        {
          "name": "get_token_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str,language:str='python')->str",
          "intent": "retrieves token reproduction prompt",
          "is_async": false
        },
        {
          "name": "get_simple_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str)->str",
          "intent": "retrieves simple reproduction prompt",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "datetime",
        "pathlib.Path",
        "generators.CSVGenerator",
        "generators.JSONGenerator",
        "generators.YAMLGenerator",
        "function_logic.FunctionLogicGenerator",
        "gherkin.GherkinGenerator",
        "logicml.LogicMLGenerator",
        "markdown_format.MarkdownHybridGenerator"
      ],
      "exports": [
        "create_single_project",
        "generate_spec",
        "generate_spec_token",
        "get_async_reproduction_prompt",
        "get_token_reproduction_prompt",
        "get_simple_reproduction_prompt"
      ]
    },
    {
      "path": "code2logic/benchmarks/results.py",
      "language": "python",
      "lines": 162,
      "classes": [
        {
          "name": "FormatResult",
          "bases": [],
          "docstring": "Result for a single format test.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "FileResult",
          "bases": [],
          "docstring": "Result for single file reproduction.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "FunctionResult",
          "bases": [],
          "docstring": "Result for single function reproduction.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "BenchmarkResult",
          "bases": [],
          "docstring": "Complete benchmark result.",
          "methods": [
            {
              "name": "__post_init__",
              "signature": "()",
              "intent": "creates init",
              "is_async": false
            },
            {
              "name": "calculate_aggregates",
              "signature": "()",
              "intent": "processes aggregates",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "to_json",
              "signature": "(indent:int=2)->str",
              "intent": "converts json",
              "is_async": false
            },
            {
              "name": "save",
              "signature": "(path:str)",
              "intent": "caches",
              "is_async": false
            },
            {
              "name": "load",
              "signature": "(path:str)->'BenchmarkResult'",
              "intent": "retrieves",
              "is_async": false
            }
          ]
        },
        {
          "name": "BenchmarkConfig",
          "bases": [],
          "docstring": "Configuration for benchmark runs.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "json",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "FormatResult",
        "FileResult",
        "FunctionResult",
        "BenchmarkResult",
        "BenchmarkConfig"
      ]
    },
    {
      "path": "code2logic/benchmarks/runner.py",
      "language": "python",
      "lines": 883,
      "classes": [
        {
          "name": "BenchmarkRunner",
          "bases": [],
          "docstring": "Unified benchmark runner for code2logic.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:Optional[BaseLLMClient]=None,config:Optional[BenchmarkConfig]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_should_use_llm",
              "signature": "()->bool",
              "intent": "checks use llm",
              "is_async": false
            },
            {
              "name": "_get_client",
              "signature": "()->BaseLLMClient",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "_template_generate_code",
              "signature": "(spec:str,fmt:str,file_name:str,language:str='python')->str",
              "intent": "template generate code",
              "is_async": false
            },
            {
              "name": "run_format_benchmark",
              "signature": "(folder:str,formats:List[str]=None,limit:Optional[int]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts format benchmark",
              "is_async": false
            },
            {
              "name": "_test_format",
              "signature": "(project,original:str,fmt:str,file_name:str...+3)->FormatResult",
              "intent": "checks format",
              "is_async": false
            },
            {
              "name": "run_file_benchmark",
              "signature": "(file_path:str,formats:List[str]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts file benchmark",
              "is_async": false
            },
            {
              "name": "run_function_benchmark",
              "signature": "(file_path:str,function_names:List[str]=None,limit:Optional[int]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts function benchmark",
              "is_async": false
            },
            {
              "name": "_test_function",
              "signature": "(func,content:str,language:str,file_path:Path...+2)->FunctionResult",
              "intent": "checks function",
              "is_async": false
            },
            {
              "name": "run_project_benchmark",
              "signature": "(project_path:str,formats:List[str]=None,limit:Optional[int]=None,verbose:bool=False)->BenchmarkResult",
              "intent": "starts project benchmark",
              "is_async": false
            },
            {
              "name": "_reproduce_module",
              "signature": "(module_info,fmt:str,project_root:str,client:Optional[BaseLLMClient]...+1)->FileResult",
              "intent": "reproduce module",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_test_python_syntax",
          "signature": "(code:str)->bool",
          "intent": "checks python syntax",
          "is_async": false
        },
        {
          "name": "_test_python_runs",
          "signature": "(code:str,timeout:int=5)->bool",
          "intent": "checks python runs",
          "is_async": false
        },
        {
          "name": "_basic_syntax_ok",
          "signature": "(code:str,language:str)->bool",
          "intent": "basic syntax ok",
          "is_async": false
        },
        {
          "name": "_count_structural_elements",
          "signature": "(code:str,language:str)->dict",
          "intent": "count structural elements",
          "is_async": false
        },
        {
          "name": "_structural_score",
          "signature": "(original:str,generated:str,language:str)->float",
          "intent": "structural score",
          "is_async": false
        },
        {
          "name": "_extract_code",
          "signature": "(response:str)->str",
          "intent": "parses code",
          "is_async": false
        },
        {
          "name": "run_benchmark",
          "signature": "(source:str,benchmark_type:str='format',formats:List[str]=None,limit:Optional[int]=None...+2)->BenchmarkResult",
          "intent": "starts benchmark",
          "is_async": false
        }
      ],
      "imports": [
        "difflib",
        "re",
        "sys",
        "time",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "concurrent.futures.ThreadPoolExecutor"
      ],
      "exports": [
        "BenchmarkRunner",
        "run_benchmark"
      ]
    },
    {
      "path": "code2logic/chunked_reproduction.py",
      "language": "python",
      "lines": 358,
      "classes": [
        {
          "name": "Chunk",
          "bases": [],
          "docstring": "A chunk of specification for reproduction."
        },
        {
          "name": "ChunkedSpec",
          "bases": [],
          "docstring": "Chunked specification."
        },
        {
          "name": "ChunkedResult",
          "bases": [],
          "docstring": "Result of chunked reproduction."
        },
        {
          "name": "ChunkedReproducer",
          "bases": [],
          "docstring": "Reproduce code from chunked specifications.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client,model_name:str='default',max_tokens:Optional[int]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reproduce",
              "signature": "(spec:str,fmt:str,file_name:str)->ChunkedResult",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_extract_code",
              "signature": "(response:str)->str",
              "intent": "parses code",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_llm_limit",
          "signature": "(model_name:str)->int",
          "intent": "retrieves llm limit",
          "is_async": false
        },
        {
          "name": "chunk_yaml_spec",
          "signature": "(spec:str,max_tokens:int=2000)->List[Chunk]",
          "intent": "chunk yaml spec",
          "is_async": false
        },
        {
          "name": "chunk_gherkin_spec",
          "signature": "(spec:str,max_tokens:int=2000)->List[Chunk]",
          "intent": "chunk gherkin spec",
          "is_async": false
        },
        {
          "name": "chunk_markdown_spec",
          "signature": "(spec:str,max_tokens:int=2000)->List[Chunk]",
          "intent": "chunk markdown spec",
          "is_async": false
        },
        {
          "name": "chunk_spec",
          "signature": "(spec:str,fmt:str,max_tokens:int=2000)->ChunkedSpec",
          "intent": "chunk spec",
          "is_async": false
        },
        {
          "name": "get_chunk_prompt",
          "signature": "(chunk:Chunk,fmt:str,file_name:str,chunk_num:int...+1)->str",
          "intent": "retrieves chunk prompt",
          "is_async": false
        },
        {
          "name": "merge_chunk_codes",
          "signature": "(codes:List[str],file_name:str)->str",
          "intent": "merges chunk codes",
          "is_async": false
        },
        {
          "name": "auto_chunk_reproduce",
          "signature": "(spec:str,fmt:str,file_name:str,client...+1)->ChunkedResult",
          "intent": "auto chunk reproduce",
          "is_async": false
        },
        {
          "name": "adaptive_chunk_reproduce",
          "signature": "(spec:str,fmt:str,file_name:str,client...+2)->ChunkedResult",
          "intent": "adaptive chunk reproduce",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "typing.List",
        "typing.Optional",
        "utils.estimate_tokens"
      ],
      "exports": [
        "LLM_CONTEXT_LIMITS",
        "Chunk",
        "ChunkedSpec",
        "ChunkedResult",
        "get_llm_limit",
        "chunk_yaml_spec",
        "chunk_gherkin_spec",
        "chunk_markdown_spec",
        "chunk_spec",
        "get_chunk_prompt"
      ]
    },
    {
      "path": "code2logic/cli.py",
      "language": "python",
      "lines": 907,
      "classes": [
        {
          "name": "Colors",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Logger",
          "bases": [],
          "docstring": "Enhanced logger for CLI output.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False,debug:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_elapsed",
              "signature": "()->str",
              "intent": "elapsed",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(msg:str)",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "success",
              "signature": "(msg:str)",
              "intent": "success",
              "is_async": false
            },
            {
              "name": "warning",
              "signature": "(msg:str)",
              "intent": "warning",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(msg:str)",
              "intent": "error",
              "is_async": false
            },
            {
              "name": "step",
              "signature": "(msg:str)",
              "intent": "step",
              "is_async": false
            },
            {
              "name": "detail",
              "signature": "(msg:str)",
              "intent": "detail",
              "is_async": false
            },
            {
              "name": "debug_msg",
              "signature": "(msg:str)",
              "intent": "debug msg",
              "is_async": false
            },
            {
              "name": "stats",
              "signature": "(label:str,value)",
              "intent": "stats",
              "is_async": false
            },
            {
              "name": "separator",
              "signature": "()",
              "intent": "separator",
              "is_async": false
            },
            {
              "name": "header",
              "signature": "(msg:str)",
              "intent": "header",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "ensure_dependencies",
          "signature": "()",
          "intent": "ensure dependencies",
          "is_async": false
        },
        {
          "name": "_get_env_file_path",
          "signature": "()->str",
          "intent": "retrieves env file path",
          "is_async": false
        },
        {
          "name": "_read_text_file",
          "signature": "(path:str)->str",
          "intent": "retrieves text file",
          "is_async": false
        },
        {
          "name": "_write_text_file",
          "signature": "(path:str,content:str)->None",
          "intent": "logs text file",
          "is_async": false
        },
        {
          "name": "_set_env_var",
          "signature": "(var_name:str,value:str)->str",
          "intent": "updates env var",
          "is_async": false
        },
        {
          "name": "_unset_env_var",
          "signature": "(var_name:str)->str",
          "intent": "unset env var",
          "is_async": false
        },
        {
          "name": "_get_litellm_config_path",
          "signature": "()->str",
          "intent": "retrieves litellm config path",
          "is_async": false
        },
        {
          "name": "_get_user_llm_config_path",
          "signature": "()->str",
          "intent": "retrieves user llm config path",
          "is_async": false
        },
        {
          "name": "_load_user_llm_config",
          "signature": "()->dict",
          "intent": "retrieves user llm config",
          "is_async": false
        },
        {
          "name": "_save_user_llm_config",
          "signature": "(data:dict)->str",
          "intent": "caches user llm config",
          "is_async": false
        },
        {
          "name": "_load_litellm_yaml",
          "signature": "()->dict",
          "intent": "retrieves litellm yaml",
          "is_async": false
        },
        {
          "name": "_save_litellm_yaml",
          "signature": "(data:dict)->str",
          "intent": "caches litellm yaml",
          "is_async": false
        },
        {
          "name": "_infer_provider_from_litellm_model",
          "signature": "(litellm_model:str)->str",
          "intent": "infer provider from litellm model",
          "is_async": false
        },
        {
          "name": "_code2logic_llm_cli",
          "signature": "(argv:list[str])->None",
          "intent": "code2logic llm cli",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "(argv=None)",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "json",
        "logging",
        "os",
        "signal",
        "subprocess",
        "sys",
        "time",
        "datetime",
        "__version__"
      ],
      "exports": [
        "Colors",
        "Logger",
        "ensure_dependencies",
        "main"
      ]
    },
    {
      "path": "code2logic/code_review.py",
      "language": "python",
      "lines": 205,
      "classes": [
        {
          "name": "CodeReviewer",
          "bases": [],
          "docstring": "Automated code review with optional LLM enhancement.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "review",
              "signature": "(project,focus:str='all')->Dict[str, Any]",
              "intent": "review",
              "is_async": false
            },
            {
              "name": "generate_report",
              "signature": "(results:Dict[str,Any],project_name:str='Project')->str",
              "intent": "creates report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_code_quality",
          "signature": "(project)->Dict[str, List[Dict]]",
          "intent": "processes code quality",
          "is_async": false
        },
        {
          "name": "check_security_issues",
          "signature": "(project)->Dict[str, List[Dict]]",
          "intent": "checks security issues",
          "is_async": false
        },
        {
          "name": "check_performance_issues",
          "signature": "(project)->Dict[str, List[Dict]]",
          "intent": "checks performance issues",
          "is_async": false
        }
      ],
      "imports": [
        "collections.defaultdict",
        "typing.Any",
        "typing.Dict",
        "typing.List"
      ],
      "exports": [
        "SECURITY_PATTERNS",
        "PERFORMANCE_PATTERNS",
        "COMPLEXITY_HIGH",
        "COMPLEXITY_MEDIUM",
        "LINES_MAX",
        "FILE_LINES_MAX",
        "analyze_code_quality",
        "check_security_issues",
        "check_performance_issues",
        "CodeReviewer"
      ]
    },
    {
      "path": "code2logic/config.py",
      "language": "python",
      "lines": 174,
      "classes": [
        {
          "name": "Config",
          "bases": [],
          "docstring": "Configuration manager for Code2Logic.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(env_file:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_load_env_file",
              "signature": "(env_file:str=None)",
              "intent": "retrieves env file",
              "is_async": false
            },
            {
              "name": "_parse_env_file",
              "signature": "(path:Path)",
              "intent": "parses env file",
              "is_async": false
            },
            {
              "name": "_load_config_file",
              "signature": "()",
              "intent": "retrieves config file",
              "is_async": false
            },
            {
              "name": "get_api_key",
              "signature": "(provider:str)->Optional[str]",
              "intent": "retrieves api key",
              "is_async": false
            },
            {
              "name": "get_model",
              "signature": "(provider:str)->str",
              "intent": "retrieves model",
              "is_async": false
            },
            {
              "name": "get_ollama_host",
              "signature": "()->str",
              "intent": "retrieves ollama host",
              "is_async": false
            },
            {
              "name": "get_default_provider",
              "signature": "()->str",
              "intent": "retrieves default provider",
              "is_async": false
            },
            {
              "name": "is_verbose",
              "signature": "()->bool",
              "intent": "is verbose",
              "is_async": false
            },
            {
              "name": "get_project_name",
              "signature": "()->str",
              "intent": "retrieves project name",
              "is_async": false
            },
            {
              "name": "get_cache_dir",
              "signature": "()->Path",
              "intent": "retrieves cache dir",
              "is_async": false
            },
            {
              "name": "list_configured_providers",
              "signature": "()->Dict[str, bool]",
              "intent": "list configured providers",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "load_env",
          "signature": "()",
          "intent": "retrieves env",
          "is_async": false
        },
        {
          "name": "get_api_key",
          "signature": "(provider:str)->Optional[str]",
          "intent": "retrieves api key",
          "is_async": false
        },
        {
          "name": "get_model",
          "signature": "(provider:str)->str",
          "intent": "retrieves model",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.Optional"
      ],
      "exports": [
        "Config",
        "load_env",
        "get_api_key",
        "get_model",
        "SHELL_COMMANDS"
      ]
    },
    {
      "path": "code2logic/core/__init__.py",
      "language": "python",
      "lines": 21,
      "classes": [],
      "functions": [],
      "imports": [
        "analyzer.ProjectAnalyzer",
        "analyzer.analyze_project",
        "dependency.DependencyAnalyzer",
        "errors.AnalysisError",
        "errors.AnalysisResult",
        "errors.ErrorHandler",
        "errors.ErrorSeverity",
        "errors.ErrorType",
        "errors.create_error_handler",
        "models.ClassInfo"
      ],
      "exports": []
    },
    {
      "path": "code2logic/dependency.py",
      "language": "python",
      "lines": 187,
      "classes": [
        {
          "name": "DependencyAnalyzer",
          "bases": [],
          "docstring": "Analyzes dependency graphs using NetworkX.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "build_graph",
              "signature": "(modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "creates graph",
              "is_async": false
            },
            {
              "name": "analyze_metrics",
              "signature": "()->Dict[str, DependencyNode]",
              "intent": "processes metrics",
              "is_async": false
            },
            {
              "name": "get_entrypoints",
              "signature": "()->List[str]",
              "intent": "retrieves entrypoints",
              "is_async": false
            },
            {
              "name": "get_hubs",
              "signature": "()->List[str]",
              "intent": "retrieves hubs",
              "is_async": false
            },
            {
              "name": "detect_cycles",
              "signature": "()->List[List[str]]",
              "intent": "detect cycles",
              "is_async": false
            },
            {
              "name": "get_strongly_connected_components",
              "signature": "()->List[List[str]]",
              "intent": "retrieves strongly connected components",
              "is_async": false
            },
            {
              "name": "_detect_clusters",
              "signature": "()->Dict[str, int]",
              "intent": "detect clusters",
              "is_async": false
            },
            {
              "name": "_module_name",
              "signature": "(path:str)->str",
              "intent": "module name",
              "is_async": false
            },
            {
              "name": "get_dependency_depth",
              "signature": "(module_path:str)->int",
              "intent": "retrieves dependency depth",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_networkx_available",
          "signature": "()->bool",
          "intent": "is networkx available",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "models.DependencyNode",
        "models.ModuleInfo",
        "networkx"
      ],
      "exports": [
        "NETWORKX_AVAILABLE",
        "DependencyAnalyzer",
        "is_networkx_available"
      ]
    },
    {
      "path": "code2logic/errors.py",
      "language": "python",
      "lines": 371,
      "classes": [
        {
          "name": "ErrorSeverity",
          "bases": [
            "Enum"
          ],
          "docstring": "Error severity levels."
        },
        {
          "name": "ErrorType",
          "bases": [
            "Enum"
          ],
          "docstring": "Types of errors that can occur during analysis."
        },
        {
          "name": "AnalysisError",
          "bases": [],
          "docstring": "Represents an error during analysis.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "AnalysisResult",
          "bases": [],
          "docstring": "Result of analysis with errors tracked.",
          "methods": [
            {
              "name": "add_error",
              "signature": "(error:AnalysisError)",
              "intent": "creates error",
              "is_async": false
            },
            {
              "name": "has_errors",
              "signature": "()->bool",
              "intent": "has errors",
              "is_async": false
            },
            {
              "name": "summary",
              "signature": "()->str",
              "intent": "summary",
              "is_async": false
            }
          ]
        },
        {
          "name": "ErrorHandler",
          "bases": [],
          "docstring": "Handles errors during analysis with configurable behavior.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(mode:str='lenient',max_file_size_mb:float=10.0,timeout_seconds:float=30.0,logger:Optional[Any]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reset",
              "signature": "()",
              "intent": "reset",
              "is_async": false
            },
            {
              "name": "handle_error",
              "signature": "(error_type:ErrorType,path:str,message:str,exception:Optional[Exception]=None...+1)->bool",
              "intent": "handles error",
              "is_async": false
            },
            {
              "name": "_default_severity",
              "signature": "(error_type:ErrorType)->ErrorSeverity",
              "intent": "default severity",
              "is_async": false
            },
            {
              "name": "_log_error",
              "signature": "(error:AnalysisError)",
              "intent": "logs error",
              "is_async": false
            },
            {
              "name": "safe_read_file",
              "signature": "(path:Path)->Optional[str]",
              "intent": "safe read file",
              "is_async": false
            },
            {
              "name": "safe_write_file",
              "signature": "(path:Path,content:str)->bool",
              "intent": "safe write file",
              "is_async": false
            },
            {
              "name": "safe_parse",
              "signature": "(path:str,content:str,parser_func:Callable)->Any",
              "intent": "safe parse",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "create_error_handler",
          "signature": "(mode:str='lenient',max_file_size_mb:float=10.0)->ErrorHandler",
          "intent": "creates error handler",
          "is_async": false
        }
      ],
      "imports": [
        "logging",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "pathlib.Path",
        "typing.Any",
        "typing.Callable",
        "typing.Dict",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "ErrorSeverity",
        "ErrorType",
        "AnalysisError",
        "AnalysisResult",
        "ErrorHandler",
        "create_error_handler"
      ]
    },
    {
      "path": "code2logic/file_formats.py",
      "language": "python",
      "lines": 278,
      "classes": [],
      "functions": [
        {
          "name": "generate_file_csv",
          "signature": "(file_path:Path)->str",
          "intent": "creates file csv",
          "is_async": false
        },
        {
          "name": "generate_file_json",
          "signature": "(file_path:Path)->str",
          "intent": "creates file json",
          "is_async": false
        },
        {
          "name": "generate_file_yaml",
          "signature": "(file_path:Path)->str",
          "intent": "creates file yaml",
          "is_async": false
        },
        {
          "name": "_parse_file_elements",
          "signature": "(content:str)->Dict[str, Any]",
          "intent": "parses file elements",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict"
      ],
      "exports": [
        "generate_file_csv",
        "generate_file_json",
        "generate_file_yaml"
      ]
    },
    {
      "path": "code2logic/formats/__init__.py",
      "language": "python",
      "lines": 31,
      "classes": [],
      "functions": [],
      "imports": [
        "file_formats.generate_file_csv",
        "file_formats.generate_file_json",
        "file_formats.generate_file_yaml",
        "generators.CompactGenerator",
        "generators.CSVGenerator",
        "generators.JSONGenerator",
        "generators.MarkdownGenerator",
        "generators.YAMLGenerator",
        "gherkin.CucumberYAMLGenerator",
        "gherkin.GherkinGenerator"
      ],
      "exports": []
    },
    {
      "path": "code2logic/function_logic.py",
      "language": "python",
      "lines": 326,
      "classes": [
        {
          "name": "FunctionLogicGenerator",
          "bases": [],
          "docstring": null,
          "properties": [
            "FILE_EXTENSION: str"
          ],
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)->None",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_json",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates json",
              "is_async": false
            },
            {
              "name": "generate_yaml",
              "signature": "(project:ProjectInfo,detail:str='full')->str",
              "intent": "creates yaml",
              "is_async": false
            },
            {
              "name": "generate_toon",
              "signature": "(project:ProjectInfo,detail:str='full',no_repeat_name:bool=False,no_repeat_details:bool=False...+2)->str",
              "intent": "creates toon",
              "is_async": false
            },
            {
              "name": "generate_toon_schema",
              "signature": "()->str",
              "intent": "creates toon schema",
              "is_async": false
            },
            {
              "name": "_build_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates data",
              "is_async": false
            },
            {
              "name": "_module_items",
              "signature": "(module)->List[Tuple[str, str, FunctionInfo]]",
              "intent": "module items",
              "is_async": false
            },
            {
              "name": "_build_sig",
              "signature": "(func:FunctionInfo,include_async_prefix:bool=True,language:str='')->str",
              "intent": "creates sig",
              "is_async": false
            },
            {
              "name": "_build_loc",
              "signature": "(func:FunctionInfo)->str",
              "intent": "creates loc",
              "is_async": false
            },
            {
              "name": "_build_does",
              "signature": "(func:FunctionInfo)->str",
              "intent": "creates does",
              "is_async": false
            },
            {
              "name": "_item_to_dict",
              "signature": "(kind:str,qualified_name:str,func:FunctionInfo,detail:str...+1)->dict",
              "intent": "item to dict",
              "is_async": false
            },
            {
              "name": "_format_function",
              "signature": "(kind:str,qualified_name:str,func:FunctionInfo,detail:str...+2)->List[str]",
              "intent": "formats function",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "typing.List",
        "typing.Tuple",
        "models.FunctionInfo",
        "models.ProjectInfo",
        "shared_utils.remove_self_from_params",
        "shared_utils.truncate_docstring",
        "toon_format.TOONGenerator"
      ],
      "exports": [
        "FunctionLogicGenerator"
      ]
    },
    {
      "path": "code2logic/generators.py",
      "language": "python",
      "lines": 1787,
      "classes": [
        {
          "name": "MarkdownGenerator",
          "bases": [],
          "docstring": "Generates Markdown output for project analysis.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail_level:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_gen_tree",
              "signature": "(lines:List[str],project:ProjectInfo)",
              "intent": "gen tree",
              "is_async": false
            },
            {
              "name": "_print_tree",
              "signature": "(lines:List[str],tree:dict,prefix:str,depth:int=0)",
              "intent": "logs tree",
              "is_async": false
            },
            {
              "name": "_gen_module",
              "signature": "(lines:List[str],m:ModuleInfo,detail:str,proj:ProjectInfo)",
              "intent": "gen module",
              "is_async": false
            },
            {
              "name": "_gen_class",
              "signature": "(lines:List[str],cls:ClassInfo,detail:str)",
              "intent": "gen class",
              "is_async": false
            },
            {
              "name": "_sig",
              "signature": "(f:FunctionInfo)->str",
              "intent": "sig",
              "is_async": false
            }
          ]
        },
        {
          "name": "CompactGenerator",
          "bases": [],
          "docstring": "Generates ultra-compact output for token efficiency.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        },
        {
          "name": "JSONGenerator",
          "bases": [],
          "docstring": "Generates JSON output for machine processing.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,flat:bool=False,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_from_module",
              "signature": "(module:ModuleInfo,detail:str='full')->str",
              "intent": "creates from module",
              "is_async": false
            },
            {
              "name": "_generate_nested",
              "signature": "(project:ProjectInfo,detail:str)->str",
              "intent": "creates nested",
              "is_async": false
            },
            {
              "name": "_field_to_dict",
              "signature": "(field:FieldInfo)->dict",
              "intent": "field to dict",
              "is_async": false
            },
            {
              "name": "_generate_flat",
              "signature": "(project:ProjectInfo,detail:str)->str",
              "intent": "creates flat",
              "is_async": false
            },
            {
              "name": "_build_element_row",
              "signature": "(m:ModuleInfo,elem_type:str,name:str,signature:str...+3)->dict",
              "intent": "creates element row",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_compute_hash",
              "signature": "(name:str,signature:str)->str",
              "intent": "processes hash",
              "is_async": false
            }
          ]
        },
        {
          "name": "YAMLGenerator",
          "bases": [],
          "docstring": "Generates YAML output for human-readable representation.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,flat:bool=False,detail:str='standard',compact:bool=True)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_schema",
              "signature": "(format_type:str='compact')->str",
              "intent": "creates schema",
              "is_async": false
            },
            {
              "name": "_generate_compact_schema",
              "signature": "()->str",
              "intent": "creates compact schema",
              "is_async": false
            },
            {
              "name": "_generate_full_schema",
              "signature": "()->str",
              "intent": "creates full schema",
              "is_async": false
            },
            {
              "name": "_generate_hybrid_schema",
              "signature": "()->str",
              "intent": "creates hybrid schema",
              "is_async": false
            },
            {
              "name": "generate_hybrid",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates hybrid",
              "is_async": false
            },
            {
              "name": "_build_enhanced_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates enhanced signature",
              "is_async": false
            },
            {
              "name": "_extract_constants",
              "signature": "(module:ModuleInfo)->list",
              "intent": "parses constants",
              "is_async": false
            },
            {
              "name": "_extract_dataclasses",
              "signature": "(module:ModuleInfo)->list",
              "intent": "parses dataclasses",
              "is_async": false
            },
            {
              "name": "_extract_conditional_imports",
              "signature": "(module:ModuleInfo)->list",
              "intent": "parses conditional imports",
              "is_async": false
            },
            {
              "name": "generate_from_module",
              "signature": "(module:ModuleInfo,detail:str='full')->str",
              "intent": "creates from module",
              "is_async": false
            },
            {
              "name": "_build_flat_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates flat data",
              "is_async": false
            },
            {
              "name": "_build_nested_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates nested data",
              "is_async": false
            },
            {
              "name": "_constants_for_module_verbose",
              "signature": "(module:ModuleInfo,limit:int=12)->list",
              "intent": "constants for module verbose",
              "is_async": false
            },
            {
              "name": "_build_row",
              "signature": "(path:str,elem_type:str,name:str,signature:str...+3)->dict",
              "intent": "creates row",
              "is_async": false
            },
            {
              "name": "_build_function_row",
              "signature": "(path:str,f:FunctionInfo,language:str,detail:str...+2)->dict",
              "intent": "creates function row",
              "is_async": false
            },
            {
              "name": "_build_method_row",
              "signature": "(path:str,class_name:str,f:FunctionInfo,language:str...+3)->dict",
              "intent": "creates method row",
              "is_async": false
            },
            {
              "name": "_function_to_dict",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "function to dict",
              "is_async": false
            },
            {
              "name": "_method_to_dict",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "method to dict",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_compute_hash",
              "signature": "(name:str,signature:str)->str",
              "intent": "processes hash",
              "is_async": false
            },
            {
              "name": "_generate_simple_yaml",
              "signature": "(project:ProjectInfo,flat:bool,detail:str)->str",
              "intent": "creates simple yaml",
              "is_async": false
            },
            {
              "name": "_build_compact_data",
              "signature": "(project:ProjectInfo,detail:str)->dict",
              "intent": "creates compact data",
              "is_async": false
            },
            {
              "name": "_compact_imports",
              "signature": "(imports:list)->list",
              "intent": "compact imports",
              "is_async": false
            },
            {
              "name": "_compact_class",
              "signature": "(cls:ClassInfo,detail:str,module_types:Optional[list]=None)->dict",
              "intent": "compact class",
              "is_async": false
            },
            {
              "name": "_compact_function",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "compact function",
              "is_async": false
            },
            {
              "name": "_compact_method",
              "signature": "(f:FunctionInfo,detail:str)->dict",
              "intent": "compact method",
              "is_async": false
            },
            {
              "name": "_build_compact_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates compact signature",
              "is_async": false
            },
            {
              "name": "_constants_for_module_verbose",
              "signature": "(module:ModuleInfo,limit:int=10)->list",
              "intent": "constants for module verbose",
              "is_async": false
            },
            {
              "name": "_constants_for_module",
              "signature": "(module:ModuleInfo,limit:int=10)->list",
              "intent": "constants for module",
              "is_async": false
            },
            {
              "name": "_constant_to_dict",
              "signature": "(constant:ConstantInfo)->dict",
              "intent": "constant to dict",
              "is_async": false
            },
            {
              "name": "_field_to_dict",
              "signature": "(field:FieldInfo)->dict",
              "intent": "field to dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "CSVGenerator",
          "bases": [],
          "docstring": "Generates CSV output optimized for LLM processing.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_build_row",
              "signature": "(m:ModuleInfo,elem_type:str,name:str,signature:str...+3)->dict",
              "intent": "creates row",
              "is_async": false
            },
            {
              "name": "_build_function_row",
              "signature": "(m:ModuleInfo,elem_type:str,name:str,f:FunctionInfo...+3)->dict",
              "intent": "creates function row",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_compute_hash",
              "signature": "(name:str,signature:str)->str",
              "intent": "processes hash",
              "is_async": false
            },
            {
              "name": "_escape_csv",
              "signature": "(text:str)->str",
              "intent": "escape csv",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "bytes_to_kb",
          "signature": "(bytes_value:int)->float",
          "intent": "bytes to kb",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "collections.defaultdict",
        "pathlib.Path",
        "typing.List",
        "typing.Optional",
        "models.ClassInfo",
        "models.ConstantInfo",
        "models.FieldInfo",
        "models.FunctionInfo",
        "models.ModuleInfo"
      ],
      "exports": [
        "bytes_to_kb",
        "MarkdownGenerator",
        "CompactGenerator",
        "JSONGenerator",
        "YAMLGenerator",
        "CSVGenerator"
      ]
    },
    {
      "path": "code2logic/gherkin.py",
      "language": "python",
      "lines": 764,
      "classes": [
        {
          "name": "GherkinScenario",
          "bases": [],
          "docstring": "Represents a single Gherkin scenario."
        },
        {
          "name": "GherkinFeature",
          "bases": [],
          "docstring": "Represents a Gherkin feature file."
        },
        {
          "name": "StepDefinition",
          "bases": [],
          "docstring": "Represents a step definition."
        },
        {
          "name": "GherkinGenerator",
          "bases": [],
          "docstring": "Generates Gherkin feature files from code analysis.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(language:str='en')",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard',group_by:str='domain')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_test_scenarios",
              "signature": "(project:ProjectInfo,group_by:str='domain')->List[GherkinFeature]",
              "intent": "creates test scenarios",
              "is_async": false
            },
            {
              "name": "get_step_definitions",
              "signature": "()->List[StepDefinition]",
              "intent": "retrieves step definitions",
              "is_async": false
            },
            {
              "name": "_extract_features",
              "signature": "(project:ProjectInfo,group_by:str)->List[GherkinFeature]",
              "intent": "parses features",
              "is_async": false
            },
            {
              "name": "_create_feature",
              "signature": "(group_name:str,items:List[dict],project:ProjectInfo,group_by:str)->GherkinFeature",
              "intent": "creates feature",
              "is_async": false
            },
            {
              "name": "_create_scenario",
              "signature": "(category:str,items:List[dict],domain:str)->GherkinScenario",
              "intent": "creates scenario",
              "is_async": false
            },
            {
              "name": "_create_edge_case_scenarios",
              "signature": "(category:str,items:List[dict])->List[GherkinScenario]",
              "intent": "creates edge case scenarios",
              "is_async": false
            },
            {
              "name": "_create_when_step",
              "signature": "(func:FunctionInfo,verb:str)->str",
              "intent": "creates when step",
              "is_async": false
            },
            {
              "name": "_create_background",
              "signature": "(domain:str,items:List[dict])->Optional[List[str]]",
              "intent": "creates background",
              "is_async": false
            },
            {
              "name": "_create_examples_table",
              "signature": "(items:List[dict])->List[Dict[str, str]]",
              "intent": "creates examples table",
              "is_async": false
            },
            {
              "name": "_extract_param_placeholders",
              "signature": "(func:FunctionInfo)->str",
              "intent": "parses param placeholders",
              "is_async": false
            },
            {
              "name": "_register_step",
              "signature": "(step_type:str,pattern:str,func:FunctionInfo)",
              "intent": "registers step",
              "is_async": false
            },
            {
              "name": "_render_features",
              "signature": "(features:List[GherkinFeature],detail:str)->str",
              "intent": "formats features",
              "is_async": false
            },
            {
              "name": "_render_feature",
              "signature": "(feature:GherkinFeature,detail:str)->str",
              "intent": "formats feature",
              "is_async": false
            },
            {
              "name": "_render_scenario",
              "signature": "(scenario:GherkinScenario,detail:str)->str",
              "intent": "formats scenario",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_name_to_readable",
              "signature": "(name:str)->str",
              "intent": "name to readable",
              "is_async": false
            },
            {
              "name": "_step_to_func_name",
              "signature": "(step:str)->str",
              "intent": "step to func name",
              "is_async": false
            }
          ]
        },
        {
          "name": "StepDefinitionGenerator",
          "bases": [],
          "docstring": "Generates step definition stubs from Gherkin features.",
          "methods": [
            {
              "name": "generate_pytest_bdd",
              "signature": "(features:List[GherkinFeature])->str",
              "intent": "creates pytest bdd",
              "is_async": false
            },
            {
              "name": "generate_behave",
              "signature": "(features:List[GherkinFeature])->str",
              "intent": "creates behave",
              "is_async": false
            },
            {
              "name": "generate_cucumber_js",
              "signature": "(features:List[GherkinFeature])->str",
              "intent": "creates cucumber js",
              "is_async": false
            },
            {
              "name": "_step_to_func_name",
              "signature": "(step:str)->str",
              "intent": "step to func name",
              "is_async": false
            }
          ]
        },
        {
          "name": "CucumberYAMLGenerator",
          "bases": [],
          "docstring": "Generates Cucumber YAML configuration and test data.",
          "methods": [
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard')->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_extract_domain",
              "signature": "(path:str)->str",
              "intent": "parses domain",
              "is_async": false
            },
            {
              "name": "_categorize",
              "signature": "(name:str)->str",
              "intent": "categorize",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "csv_to_gherkin",
          "signature": "(csv_content:str,language:str='en')->str",
          "intent": "csv to gherkin",
          "is_async": false
        },
        {
          "name": "gherkin_to_test_data",
          "signature": "(gherkin_content:str)->Dict[str, Any]",
          "intent": "gherkin to test data",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "collections.defaultdict",
        "dataclasses.dataclass",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "models.FunctionInfo",
        "models.ProjectInfo"
      ],
      "exports": [
        "GherkinScenario",
        "GherkinFeature",
        "StepDefinition",
        "GherkinGenerator",
        "StepDefinitionGenerator",
        "CucumberYAMLGenerator",
        "csv_to_gherkin",
        "gherkin_to_test_data"
      ]
    },
    {
      "path": "code2logic/integrations/__init__.py",
      "language": "python",
      "lines": 5,
      "classes": [],
      "functions": [],
      "imports": [
        "mcp_server.call_tool",
        "mcp_server.handle_request",
        "mcp_server.run_server"
      ],
      "exports": []
    },
    {
      "path": "code2logic/intent.py",
      "language": "python",
      "lines": 429,
      "classes": [
        {
          "name": "IntentType",
          "bases": [
            "Enum"
          ],
          "docstring": "Types of user intents for code analysis."
        },
        {
          "name": "Intent",
          "bases": [],
          "docstring": "Represents a detected user intent."
        },
        {
          "name": "EnhancedIntentGenerator",
          "bases": [],
          "docstring": "Generator intencji z NLP - lemmatyzacja, ekstrakcja z docstringw.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(lang:str='en')",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(name:str,docstring:Optional[str]=None)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_extract_from_docstring",
              "signature": "(docstring:str)->Optional[str]",
              "intent": "parses from docstring",
              "is_async": false
            },
            {
              "name": "_split_name",
              "signature": "(name:str)->List[str]",
              "intent": "splits name",
              "is_async": false
            },
            {
              "name": "get_available_features",
              "signature": "()->dict[str, bool]",
              "intent": "retrieves available features",
              "is_async": false
            }
          ]
        },
        {
          "name": "IntentAnalyzer",
          "bases": [],
          "docstring": "Analyzes user queries to detect intent and provide suggestions.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_extract_keywords",
              "signature": "(query:str)->List[str]",
              "intent": "parses keywords",
              "is_async": false
            },
            {
              "name": "_calculate_intent_confidence",
              "signature": "(keywords:List[str],patterns:List[str])->float",
              "intent": "processes intent confidence",
              "is_async": false
            },
            {
              "name": "_identify_target",
              "signature": "(query:str,project:Any)->str",
              "intent": "identify target",
              "is_async": false
            },
            {
              "name": "_generate_description",
              "signature": "(intent_type:IntentType,target:str)->str",
              "intent": "creates description",
              "is_async": false
            },
            {
              "name": "_generate_suggestions",
              "signature": "(intent_type:IntentType,target:str,project:Any)->List[str]",
              "intent": "creates suggestions",
              "is_async": false
            },
            {
              "name": "analyze_intent",
              "signature": "(query:str,project:Any)->List[Intent]",
              "intent": "processes intent",
              "is_async": false
            },
            {
              "name": "detect_code_smells",
              "signature": "(project:Any)->List[dict]",
              "intent": "detect code smells",
              "is_async": false
            },
            {
              "name": "suggest_refactoring",
              "signature": "(target:str,project:Any)->List[str]",
              "intent": "suggest refactoring",
              "is_async": false
            },
            {
              "name": "_find_target_object",
              "signature": "(target:str,project:Any)->Any",
              "intent": "retrieves target object",
              "is_async": false
            },
            {
              "name": "_suggest_module_refactoring",
              "signature": "(module:Any)->List[str]",
              "intent": "suggest module refactoring",
              "is_async": false
            },
            {
              "name": "_suggest_class_refactoring",
              "signature": "(cls:Any)->List[str]",
              "intent": "suggest class refactoring",
              "is_async": false
            },
            {
              "name": "_suggest_function_refactoring",
              "signature": "(func:Any)->List[str]",
              "intent": "suggest function refactoring",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "enum.auto",
        "typing.TYPE_CHECKING",
        "typing.Any",
        "typing.List",
        "typing.Optional",
        "nltk"
      ],
      "exports": [
        "IntentType",
        "Intent",
        "EnhancedIntentGenerator",
        "IntentAnalyzer"
      ]
    },
    {
      "path": "code2logic/llm.py",
      "language": "python",
      "lines": 287,
      "classes": [
        {
          "name": "LLMConfig",
          "bases": [],
          "docstring": "Configuration for LLM backend."
        },
        {
          "name": "CodeAnalyzer",
          "bases": [],
          "docstring": "LLM-powered code analysis for Code2Logic.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(model:str=None,provider:str=None,base_url:str=None,api_key:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "suggest_refactoring",
              "signature": "(project)->list[dict[str, Any]]",
              "intent": "suggest refactoring",
              "is_async": false
            },
            {
              "name": "find_semantic_duplicates",
              "signature": "(project)->list[dict[str, Any]]",
              "intent": "retrieves semantic duplicates",
              "is_async": false
            },
            {
              "name": "generate_code",
              "signature": "(project,target_lang:str,module_filter:Optional[str]=None)->dict[str, str]",
              "intent": "creates code",
              "is_async": false
            },
            {
              "name": "translate_function",
              "signature": "(name:str,signature:str,intent:str,source_lang:str...+1)->str",
              "intent": "converts function",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f)->str",
              "intent": "creates signature",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_available_backends",
          "signature": "()->dict[str, bool]",
          "intent": "retrieves available backends",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "dataclasses.dataclass",
        "importlib.util.find_spec",
        "typing.Any",
        "typing.Optional",
        "llm_clients.LiteLLMClient",
        "llm_clients.OllamaLocalClient",
        "llm_clients.OpenRouterClient",
        "llm_clients.get_client"
      ],
      "exports": [
        "LLMConfig",
        "CodeAnalyzer",
        "get_available_backends"
      ]
    },
    {
      "path": "code2logic/llm/__init__.py",
      "language": "python",
      "lines": 40,
      "classes": [],
      "functions": [],
      "imports": [
        "importlib.util.module_from_spec",
        "importlib.util.spec_from_file_location",
        "pathlib.Path",
        "intent.EnhancedIntentGenerator",
        "llm_clients.DEFAULT_MODELS",
        "llm_clients.RECOMMENDED_MODELS",
        "llm_clients.BaseLLMClient",
        "llm_clients.LiteLLMClient",
        "llm_clients.LLMManager",
        "llm_clients.OllamaLocalClient"
      ],
      "exports": []
    },
    {
      "path": "code2logic/llm_clients.py",
      "language": "python",
      "lines": 209,
      "classes": [],
      "functions": [
        {
          "name": "_get_user_llm_config_path",
          "signature": "()->str",
          "intent": "retrieves user llm config path",
          "is_async": false
        },
        {
          "name": "_load_user_llm_config",
          "signature": "()->dict[str, Any]",
          "intent": "retrieves user llm config",
          "is_async": false
        },
        {
          "name": "_get_priority_mode",
          "signature": "()->str",
          "intent": "retrieves priority mode",
          "is_async": false
        },
        {
          "name": "get_priority_mode",
          "signature": "()->str",
          "intent": "retrieves priority mode",
          "is_async": false
        },
        {
          "name": "_get_provider_priority_overrides",
          "signature": "()->dict[str, int]",
          "intent": "retrieves provider priority overrides",
          "is_async": false
        },
        {
          "name": "_get_model_priority_rules",
          "signature": "()->dict[str, dict[str, int]]",
          "intent": "retrieves model priority rules",
          "is_async": false
        },
        {
          "name": "_get_model_priority",
          "signature": "(model_string:str)->Optional[int]",
          "intent": "retrieves model priority",
          "is_async": false
        },
        {
          "name": "_get_provider_model_string",
          "signature": "(provider:str)->str",
          "intent": "retrieves provider model string",
          "is_async": false
        },
        {
          "name": "_get_priority_order",
          "signature": "()->list[str]",
          "intent": "retrieves priority order",
          "is_async": false
        },
        {
          "name": "_get_effective_provider_order",
          "signature": "()->list[tuple[str, int]]",
          "intent": "retrieves effective provider order",
          "is_async": false
        },
        {
          "name": "get_effective_provider_priorities",
          "signature": "()->dict[str, int]",
          "intent": "retrieves effective provider priorities",
          "is_async": false
        },
        {
          "name": "_candidate_litellm_yaml_paths",
          "signature": "()->list[str]",
          "intent": "candidate litellm yaml paths",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "typing.Any",
        "typing.Optional",
        "lolm.DEFAULT_MODELS",
        "lolm.DEFAULT_PROVIDER_PRIORITIES",
        "lolm.RECOMMENDED_MODELS",
        "lolm.BaseLLMClient",
        "lolm.LiteLLMClient",
        "lolm.LLMConfig"
      ],
      "exports": [
        "get_priority_mode",
        "get_effective_provider_priorities"
      ]
    },
    {
      "path": "code2logic/llm_profiler.py",
      "language": "python",
      "lines": 490,
      "classes": [
        {
          "name": "LLMProfile",
          "bases": [],
          "docstring": "Profile of LLM capabilities for code reproduction.",
          "methods": [
            {
              "name": "__post_init__",
              "signature": "()",
              "intent": "creates init",
              "is_async": false
            }
          ]
        },
        {
          "name": "ProfileTestResult",
          "bases": [],
          "docstring": "Result of a single profile test."
        },
        {
          "name": "LLMProfiler",
          "bases": [],
          "docstring": "Profile LLM capabilities for code reproduction.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client,verbose:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "run_profile",
              "signature": "(quick:bool=False)->LLMProfile",
              "intent": "starts profile",
              "is_async": false
            },
            {
              "name": "_test_reproduction",
              "signature": "(name:str,code:str)->ProfileTestResult",
              "intent": "checks reproduction",
              "is_async": false
            },
            {
              "name": "_code_to_spec",
              "signature": "(code:str)->str",
              "intent": "code to spec",
              "is_async": false
            },
            {
              "name": "_extract_code",
              "signature": "(response:str)->str",
              "intent": "parses code",
              "is_async": false
            },
            {
              "name": "_check_syntax",
              "signature": "(code:str)->bool",
              "intent": "checks syntax",
              "is_async": false
            },
            {
              "name": "_calculate_similarity",
              "signature": "(original:str,reproduced:str)->float",
              "intent": "processes similarity",
              "is_async": false
            },
            {
              "name": "_calculate_metrics",
              "signature": "(profile:LLMProfile,results:list[ProfileTestResult])->LLMProfile",
              "intent": "processes metrics",
              "is_async": false
            },
            {
              "name": "_test_consistency",
              "signature": "(profile:LLMProfile)->LLMProfile",
              "intent": "checks consistency",
              "is_async": false
            }
          ]
        },
        {
          "name": "AdaptiveChunker",
          "bases": [],
          "docstring": "Adaptive chunking based on LLM profile.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(profile:Optional[LLMProfile]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "get_optimal_settings",
              "signature": "()->dict[str, Any]",
              "intent": "retrieves optimal settings",
              "is_async": false
            },
            {
              "name": "chunk_spec",
              "signature": "(spec:str,format:str='yaml')->list[dict[str, Any]]",
              "intent": "chunk spec",
              "is_async": false
            },
            {
              "name": "recommend_format",
              "signature": "(spec_size_tokens:int)->str",
              "intent": "recommend format",
              "is_async": false
            },
            {
              "name": "estimate_chunks_needed",
              "signature": "(spec_size_tokens:int)->int",
              "intent": "estimate chunks needed",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_get_profiles_path",
          "signature": "()->Path",
          "intent": "retrieves profiles path",
          "is_async": false
        },
        {
          "name": "load_profiles",
          "signature": "()->dict[str, LLMProfile]",
          "intent": "retrieves profiles",
          "is_async": false
        },
        {
          "name": "save_profile",
          "signature": "(profile:LLMProfile)->None",
          "intent": "caches profile",
          "is_async": false
        },
        {
          "name": "get_profile",
          "signature": "(provider:str,model:str)->Optional[LLMProfile]",
          "intent": "retrieves profile",
          "is_async": false
        },
        {
          "name": "get_or_create_profile",
          "signature": "(provider:str,model:str)->LLMProfile",
          "intent": "retrieves or create profile",
          "is_async": false
        },
        {
          "name": "_create_default_profile",
          "signature": "(provider:str,model:str)->LLMProfile",
          "intent": "creates default profile",
          "is_async": false
        },
        {
          "name": "profile_llm",
          "signature": "(client,quick:bool=False)->LLMProfile",
          "intent": "profile llm",
          "is_async": false
        },
        {
          "name": "get_adaptive_chunker",
          "signature": "(provider:str,model:str)->AdaptiveChunker",
          "intent": "retrieves adaptive chunker",
          "is_async": false
        }
      ],
      "imports": [
        "hashlib",
        "json",
        "time",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime",
        "difflib.SequenceMatcher",
        "pathlib.Path",
        "typing.Any"
      ],
      "exports": [
        "PROFILE_TEST_CASES",
        "LLMProfile",
        "ProfileTestResult",
        "load_profiles",
        "save_profile",
        "get_profile",
        "get_or_create_profile",
        "LLMProfiler",
        "AdaptiveChunker",
        "profile_llm"
      ]
    },
    {
      "path": "code2logic/logicml.py",
      "language": "python",
      "lines": 305,
      "classes": [
        {
          "name": "LogicMLSpec",
          "bases": [],
          "docstring": "LogicML specification output."
        },
        {
          "name": "LogicMLGenerator",
          "bases": [],
          "docstring": "Generates LogicML format - optimized for LLM code reproduction.",
          "properties": [
            "FORMAT_NAME: str",
            "FILE_EXTENSION: str",
            "TOKEN_EFFICIENCY: float",
            "REPRODUCTION_FIDELITY: float"
          ],
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)->None",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard',level:str='typed')->LogicMLSpec",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_module",
              "signature": "(module:ModuleInfo,detail:str,level:str='typed')->str",
              "intent": "creates module",
              "is_async": false
            },
            {
              "name": "_generate_imports",
              "signature": "(imports:List[str])->str",
              "intent": "creates imports",
              "is_async": false
            },
            {
              "name": "_generate_class",
              "signature": "(cls:ClassInfo,detail:str,level:str='typed')->str",
              "intent": "creates class",
              "is_async": false
            },
            {
              "name": "_generate_method",
              "signature": "(method:FunctionInfo,detail:str,level:str='typed',indent:int=2)->str",
              "intent": "creates method",
              "is_async": false
            },
            {
              "name": "_generate_functions",
              "signature": "(functions:List[FunctionInfo],detail:str,level:str='typed')->str",
              "intent": "creates functions",
              "is_async": false
            },
            {
              "name": "_detect_side_effects",
              "signature": "(method:FunctionInfo)->Optional[str]",
              "intent": "detect side effects",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_logicml",
          "signature": "(project:ProjectInfo,detail:str='standard')->str",
          "intent": "creates logicml",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Set",
        "models.ClassInfo",
        "models.FunctionInfo",
        "models.ModuleInfo",
        "models.ProjectInfo"
      ],
      "exports": [
        "LogicMLSpec",
        "LogicMLGenerator",
        "generate_logicml",
        "LOGICML_EXAMPLE"
      ]
    },
    {
      "path": "code2logic/markdown_format.py",
      "language": "python",
      "lines": 265,
      "classes": [
        {
          "name": "MarkdownSpec",
          "bases": [],
          "docstring": "Markdown specification for a project."
        },
        {
          "name": "MarkdownHybridGenerator",
          "bases": [],
          "docstring": "Generates optimized Markdown hybrid format.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='full')->MarkdownSpec",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_header",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates header",
              "is_async": false
            },
            {
              "name": "_generate_tree",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates tree",
              "is_async": false
            },
            {
              "name": "_generate_imports",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates imports",
              "is_async": false
            },
            {
              "name": "_generate_classes_yaml",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates classes yaml",
              "is_async": false
            },
            {
              "name": "_generate_functions_gherkin",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates functions gherkin",
              "is_async": false
            },
            {
              "name": "_generate_dependencies",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates dependencies",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_markdown_hybrid",
          "signature": "(project:ProjectInfo,detail:str='full')->str",
          "intent": "creates markdown hybrid",
          "is_async": false
        },
        {
          "name": "generate_file_markdown",
          "signature": "(file_path:str)->str",
          "intent": "creates file markdown",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "generators.YAMLGenerator",
        "gherkin.GherkinGenerator",
        "models.ProjectInfo"
      ],
      "exports": [
        "MarkdownSpec",
        "MarkdownHybridGenerator",
        "generate_markdown_hybrid",
        "generate_file_markdown"
      ]
    },
    {
      "path": "code2logic/mcp_server.py",
      "language": "python",
      "lines": 297,
      "classes": [],
      "functions": [
        {
          "name": "handle_request",
          "signature": "(request:dict)->dict",
          "intent": "handles request",
          "is_async": false
        },
        {
          "name": "call_tool",
          "signature": "(tool_name:str,arguments:dict)->str",
          "intent": "call tool",
          "is_async": false
        },
        {
          "name": "run_server",
          "signature": "()",
          "intent": "starts server",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "sys",
        "__version__"
      ],
      "exports": [
        "handle_request",
        "call_tool",
        "run_server"
      ]
    },
    {
      "path": "code2logic/metrics.py",
      "language": "python",
      "lines": 479,
      "classes": [
        {
          "name": "TextMetrics",
          "bases": [],
          "docstring": "Text-level similarity metrics."
        },
        {
          "name": "StructuralMetrics",
          "bases": [],
          "docstring": "Structural code metrics."
        },
        {
          "name": "SemanticMetrics",
          "bases": [],
          "docstring": "Semantic preservation metrics."
        },
        {
          "name": "FormatMetrics",
          "bases": [],
          "docstring": "Format-specific efficiency metrics."
        },
        {
          "name": "ReproductionResult",
          "bases": [],
          "docstring": "Complete reproduction analysis result.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "to_report",
              "signature": "()->str",
              "intent": "converts report",
              "is_async": false
            }
          ]
        },
        {
          "name": "ReproductionMetrics",
          "bases": [],
          "docstring": "Analyze reproduction quality with multiple metrics.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "(original:str,generated:str,spec:str='',format_name:str=''...+1)->ReproductionResult",
              "intent": "processes",
              "is_async": false
            },
            {
              "name": "_compute_text_metrics",
              "signature": "(original:str,generated:str)->TextMetrics",
              "intent": "processes text metrics",
              "is_async": false
            },
            {
              "name": "_cosine_similarity",
              "signature": "(words1:List[str],words2:List[str])->float",
              "intent": "cosine similarity",
              "is_async": false
            },
            {
              "name": "_compute_structural_metrics",
              "signature": "(original:str,generated:str)->StructuralMetrics",
              "intent": "processes structural metrics",
              "is_async": false
            },
            {
              "name": "_count_elements_ast",
              "signature": "(code:str)->Dict[str, int]",
              "intent": "count elements ast",
              "is_async": false
            },
            {
              "name": "_compute_semantic_metrics",
              "signature": "(original:str,generated:str)->SemanticMetrics",
              "intent": "processes semantic metrics",
              "is_async": false
            },
            {
              "name": "_compute_format_metrics",
              "signature": "(original:str,generated:str,spec:str,format_name:str)->FormatMetrics",
              "intent": "processes format metrics",
              "is_async": false
            },
            {
              "name": "_compute_overall_score",
              "signature": "(result:ReproductionResult)->float",
              "intent": "processes overall score",
              "is_async": false
            },
            {
              "name": "_get_grade",
              "signature": "(score:float)->str",
              "intent": "retrieves grade",
              "is_async": false
            },
            {
              "name": "_generate_recommendations",
              "signature": "(result:ReproductionResult)->List[str]",
              "intent": "creates recommendations",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_reproduction",
          "signature": "(original:str,generated:str,spec:str='',format_name:str=''...+1)->ReproductionResult",
          "intent": "processes reproduction",
          "is_async": false
        },
        {
          "name": "compare_formats",
          "signature": "(original:str,results:Dict[str,Tuple[str,str]],verbose:bool=False)->Dict[str, Any]",
          "intent": "compare formats",
          "is_async": false
        }
      ],
      "imports": [
        "difflib",
        "logging",
        "re",
        "collections.Counter",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List"
      ],
      "exports": [
        "TextMetrics",
        "StructuralMetrics",
        "SemanticMetrics",
        "FormatMetrics",
        "ReproductionResult",
        "ReproductionMetrics",
        "analyze_reproduction",
        "compare_formats"
      ]
    },
    {
      "path": "code2logic/models.py",
      "language": "python",
      "lines": 296,
      "classes": [
        {
          "name": "FunctionInfo",
          "bases": [],
          "docstring": "Information about a function or method."
        },
        {
          "name": "ClassInfo",
          "bases": [],
          "docstring": "Information about a class or interface."
        },
        {
          "name": "TypeInfo",
          "bases": [],
          "docstring": "Information about a type alias, interface, or enum."
        },
        {
          "name": "ModuleInfo",
          "bases": [],
          "docstring": "Information about a source file/module."
        },
        {
          "name": "DependencyNode",
          "bases": [],
          "docstring": "Node in the dependency graph with metrics."
        },
        {
          "name": "ProjectInfo",
          "bases": [],
          "docstring": "Complete project analysis results."
        },
        {
          "name": "ConstantInfo",
          "bases": [],
          "docstring": "Module-level constant information."
        },
        {
          "name": "FieldInfo",
          "bases": [],
          "docstring": "Dataclass field information."
        },
        {
          "name": "AttributeInfo",
          "bases": [],
          "docstring": "Instance attribute information (self.x = ...)."
        },
        {
          "name": "PropertyInfo",
          "bases": [],
          "docstring": "Property information (@property, @x.setter)."
        },
        {
          "name": "OptionalImport",
          "bases": [],
          "docstring": "Try/except import block information."
        },
        {
          "name": "ClassInfo",
          "bases": [],
          "docstring": "Information about a class or interface."
        },
        {
          "name": "FunctionInfo",
          "bases": [],
          "docstring": "Information about a function or method."
        },
        {
          "name": "ModuleInfo",
          "bases": [],
          "docstring": "Information about a source file/module."
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Dict",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "FunctionInfo",
        "ClassInfo",
        "TypeInfo",
        "ModuleInfo",
        "DependencyNode",
        "ProjectInfo",
        "ConstantInfo",
        "FieldInfo",
        "AttributeInfo",
        "PropertyInfo"
      ]
    },
    {
      "path": "code2logic/parsers.py",
      "language": "python",
      "lines": 2265,
      "classes": [
        {
          "name": "_PyFunctionBodyAnalyzer",
          "bases": [
            "ast.NodeVisitor"
          ],
          "docstring": null,
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_add_call",
              "signature": "(name:str)->None",
              "intent": "creates call",
              "is_async": false
            },
            {
              "name": "_add_raise",
              "signature": "(name:str)->None",
              "intent": "creates raise",
              "is_async": false
            },
            {
              "name": "visit_Call",
              "signature": "(node)",
              "intent": "visit call",
              "is_async": false
            },
            {
              "name": "visit_Raise",
              "signature": "(node)",
              "intent": "visit raise",
              "is_async": false
            },
            {
              "name": "visit_If",
              "signature": "(node)",
              "intent": "visit if",
              "is_async": false
            },
            {
              "name": "visit_For",
              "signature": "(node)",
              "intent": "visit for",
              "is_async": false
            },
            {
              "name": "visit_AsyncFor",
              "signature": "(node)",
              "intent": "visit asyncfor",
              "is_async": false
            },
            {
              "name": "visit_While",
              "signature": "(node)",
              "intent": "visit while",
              "is_async": false
            },
            {
              "name": "visit_IfExp",
              "signature": "(node)",
              "intent": "visit ifexp",
              "is_async": false
            },
            {
              "name": "visit_BoolOp",
              "signature": "(node)",
              "intent": "visit boolop",
              "is_async": false
            },
            {
              "name": "visit_Try",
              "signature": "(node)",
              "intent": "visit try",
              "is_async": false
            },
            {
              "name": "visit_comprehension",
              "signature": "(node)",
              "intent": "visit comprehension",
              "is_async": false
            },
            {
              "name": "visit_Match",
              "signature": "(node)",
              "intent": "visit match",
              "is_async": false
            },
            {
              "name": "visit_FunctionDef",
              "signature": "(node)",
              "intent": "visit functiondef",
              "is_async": false
            },
            {
              "name": "visit_AsyncFunctionDef",
              "signature": "(node)",
              "intent": "visit asyncfunctiondef",
              "is_async": false
            },
            {
              "name": "visit_ClassDef",
              "signature": "(node)",
              "intent": "visit classdef",
              "is_async": false
            },
            {
              "name": "visit_Lambda",
              "signature": "(node)",
              "intent": "visit lambda",
              "is_async": false
            }
          ]
        },
        {
          "name": "TreeSitterParser",
          "bases": [],
          "docstring": "Parser using Tree-sitter for high-accuracy AST parsing.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_init_parsers",
              "signature": "()",
              "intent": "creates parsers",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "(language:str)->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "get_supported_languages",
              "signature": "()->List[str]",
              "intent": "retrieves supported languages",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(filepath:str,content:str,language:str)->Optional[ModuleInfo]",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(filepath:str,content:str,tree)->ModuleInfo",
              "intent": "parses python",
              "is_async": false
            },
            {
              "name": "_extract_constants",
              "signature": "(tree,content:str)->List[ConstantInfo]",
              "intent": "parses constants",
              "is_async": false
            },
            {
              "name": "_extract_type_checking_imports",
              "signature": "(tree,content:str)->List[str]",
              "intent": "parses type checking imports",
              "is_async": false
            },
            {
              "name": "_extract_conditional_imports",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses conditional imports",
              "is_async": false
            },
            {
              "name": "_extract_aliases",
              "signature": "(tree,content:str)->dict",
              "intent": "parses aliases",
              "is_async": false
            },
            {
              "name": "_extract_py_function",
              "signature": "(node,content:str,decorated_node=None,filepath:Optional[str]=None)->Optional[FunctionInfo]",
              "intent": "parses py function",
              "is_async": false
            },
            {
              "name": "_extract_py_enum",
              "signature": "(node,content:str)->Optional[TypeInfo]",
              "intent": "parses py enum",
              "is_async": false
            },
            {
              "name": "_extract_py_class",
              "signature": "(node,content:str,decorated_node=None,filepath:Optional[str]=None)->Optional[ClassInfo]",
              "intent": "parses py class",
              "is_async": false
            },
            {
              "name": "_extract_dataclass_field",
              "signature": "(node,content:str)->Optional[FieldInfo]",
              "intent": "parses dataclass field",
              "is_async": false
            },
            {
              "name": "_extract_class_attribute",
              "signature": "(node,content:str)->Optional[AttributeInfo]",
              "intent": "parses class attribute",
              "is_async": false
            },
            {
              "name": "_extract_init_attributes",
              "signature": "(func_node,content:str)->List[AttributeInfo]",
              "intent": "parses init attributes",
              "is_async": false
            },
            {
              "name": "_extract_class_property",
              "signature": "(node,content:str)->Optional[str]",
              "intent": "parses class property",
              "is_async": false
            },
            {
              "name": "_extract_py_import",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses py import",
              "is_async": false
            },
            {
              "name": "_extract_py_from_import",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses py from import",
              "is_async": false
            },
            {
              "name": "_extract_py_constant",
              "signature": "(node,content:str)->Optional[ConstantInfo]",
              "intent": "parses py constant",
              "is_async": false
            },
            {
              "name": "_extract_conditional_imports",
              "signature": "(node,content:str)->List[str]",
              "intent": "parses conditional imports",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(filepath:str,content:str,tree,language:str)->ModuleInfo",
              "intent": "parses js ts",
              "is_async": false
            },
            {
              "name": "_extract_js_class",
              "signature": "(node,content:str)->Optional[ClassInfo]",
              "intent": "parses js class",
              "is_async": false
            },
            {
              "name": "_extract_js_method",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js method",
              "is_async": false
            },
            {
              "name": "_extract_js_function",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js function",
              "is_async": false
            },
            {
              "name": "_extract_js_var_fn",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js var fn",
              "is_async": false
            },
            {
              "name": "_extract_js_arrow_fn",
              "signature": "(node,content:str)->Optional[FunctionInfo]",
              "intent": "parses js arrow fn",
              "is_async": false
            },
            {
              "name": "_extract_js_require_imports",
              "signature": "(node,content:str,imports:list)",
              "intent": "parses js require imports",
              "is_async": false
            },
            {
              "name": "_extract_from_expression_stmt",
              "signature": "(node,content:str,functions:list,exports:list...+1)",
              "intent": "parses from expression stmt",
              "is_async": false
            },
            {
              "name": "_walk_nested_functions",
              "signature": "(root,content:str,functions:list,seen_fn_names:set)",
              "intent": "walk nested functions",
              "is_async": false
            },
            {
              "name": "_extract_js_params",
              "signature": "(params_node,content:str)->List[str]",
              "intent": "parses js params",
              "is_async": false
            },
            {
              "name": "_extract_ts_type",
              "signature": "(node,content:str)->Optional[TypeInfo]",
              "intent": "parses ts type",
              "is_async": false
            },
            {
              "name": "_extract_ts_enum",
              "signature": "(node,content:str)->Optional[TypeInfo]",
              "intent": "parses ts enum",
              "is_async": false
            },
            {
              "name": "_extract_js_constant",
              "signature": "(node,content:str)->Optional[str]",
              "intent": "parses js constant",
              "is_async": false
            },
            {
              "name": "_extract_js_comment",
              "signature": "(node,content:str)->Optional[str]",
              "intent": "parses js comment",
              "is_async": false
            },
            {
              "name": "_find_child",
              "signature": "(node,type_name:str)",
              "intent": "retrieves child",
              "is_async": false
            },
            {
              "name": "_text",
              "signature": "(node,content:str)->str",
              "intent": "text",
              "is_async": false
            },
            {
              "name": "_extract_string",
              "signature": "(node,content:str)->str",
              "intent": "parses string",
              "is_async": false
            },
            {
              "name": "_truncate_docstring",
              "signature": "(docstring:Optional[str],max_len:int=80)->Optional[str]",
              "intent": "truncate docstring",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalParser",
          "bases": [],
          "docstring": "Fallback parser using Python AST and regex.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(filepath:str,content:str,language:str)->Optional[ModuleInfo]",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(filepath:str,content:str)->Optional[ModuleInfo]",
              "intent": "parses python",
              "is_async": false
            },
            {
              "name": "_extract_ast_enum",
              "signature": "(node:Any)->Optional[TypeInfo]",
              "intent": "parses ast enum",
              "is_async": false
            },
            {
              "name": "_extract_ast_function",
              "signature": "(node)->FunctionInfo",
              "intent": "parses ast function",
              "is_async": false
            },
            {
              "name": "_extract_ast_class",
              "signature": "(node:Any)->ClassInfo",
              "intent": "parses ast class",
              "is_async": false
            },
            {
              "name": "_extract_ast_constant",
              "signature": "(node:Any,content:str)->Optional[ConstantInfo]",
              "intent": "parses ast constant",
              "is_async": false
            },
            {
              "name": "_format_ast_value",
              "signature": "(value_node:Any,content:str)->str",
              "intent": "formats ast value",
              "is_async": false
            },
            {
              "name": "_ann_str",
              "signature": "(node)->str",
              "intent": "ann str",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(filepath:str,content:str,language:str)->ModuleInfo",
              "intent": "parses js ts",
              "is_async": false
            },
            {
              "name": "_parse_go",
              "signature": "(filepath:str,content:str)->ModuleInfo",
              "intent": "parses go",
              "is_async": false
            },
            {
              "name": "_parse_rust",
              "signature": "(filepath:str,content:str)->ModuleInfo",
              "intent": "parses rust",
              "is_async": false
            },
            {
              "name": "_parse_java",
              "signature": "(filepath:str,content:str)->ModuleInfo",
              "intent": "parses java",
              "is_async": false
            },
            {
              "name": "_parse_csharp",
              "signature": "(filepath:str,content:str)->ModuleInfo",
              "intent": "parses csharp",
              "is_async": false
            },
            {
              "name": "_parse_sql",
              "signature": "(filepath:str,content:str)->ModuleInfo",
              "intent": "parses sql",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_normalize_import_path",
          "signature": "(import_path:str)->str",
          "intent": "normalize import path",
          "is_async": false
        },
        {
          "name": "_clean_imports",
          "signature": "(imports:List[str])->List[str]",
          "intent": "clean imports",
          "is_async": false
        },
        {
          "name": "_combine_import_name",
          "signature": "(module_name:str,identifier:str)->str",
          "intent": "merges import name",
          "is_async": false
        },
        {
          "name": "_truncate_constant_value",
          "signature": "(value_text:str,limit:int=400)->str",
          "intent": "truncate constant value",
          "is_async": false
        },
        {
          "name": "_py_expr_to_dotted_name",
          "signature": "(expr)->str",
          "intent": "py expr to dotted name",
          "is_async": false
        },
        {
          "name": "_analyze_python_function_node",
          "signature": "(func_node)",
          "intent": "processes python function node",
          "is_async": false
        },
        {
          "name": "is_tree_sitter_available",
          "signature": "()->bool",
          "intent": "is tree sitter available",
          "is_async": false
        }
      ],
      "imports": [
        "ast",
        "re",
        "textwrap",
        "typing.List",
        "typing.Optional",
        "intent.EnhancedIntentGenerator",
        "models.AttributeInfo",
        "models.ClassInfo",
        "models.ConstantInfo",
        "models.FieldInfo"
      ],
      "exports": [
        "TREE_SITTER_AVAILABLE",
        "TreeSitterParser",
        "UniversalParser",
        "is_tree_sitter_available"
      ]
    },
    {
      "path": "code2logic/project_reproducer.py",
      "language": "python",
      "lines": 318,
      "classes": [
        {
          "name": "FileResult",
          "bases": [],
          "docstring": "Result for a single file reproduction."
        },
        {
          "name": "ProjectResult",
          "bases": [],
          "docstring": "Result for project reproduction."
        },
        {
          "name": "ProjectReproducer",
          "bases": [],
          "docstring": "Multi-file project reproduction system.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None,max_workers:int=4,target_lang:str=None,use_llm:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_get_client",
              "signature": "()->BaseLLMClient",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "find_source_files",
              "signature": "(project_path:str,extensions:Set[str]=None,exclude_patterns:List[str]=None)->List[Path]",
              "intent": "retrieves source files",
              "is_async": false
            },
            {
              "name": "reproduce_file",
              "signature": "(file_path:Path,output_dir:Path)->FileResult",
              "intent": "reproduce file",
              "is_async": false
            },
            {
              "name": "reproduce_project",
              "signature": "(project_path:str,output_dir:str=None,parallel:bool=False)->ProjectResult",
              "intent": "reproduce project",
              "is_async": false
            },
            {
              "name": "_aggregate_results",
              "signature": "(project_path:str,results:List[FileResult])->ProjectResult",
              "intent": "aggregate results",
              "is_async": false
            },
            {
              "name": "_save_report",
              "signature": "(output_dir:Path,result:ProjectResult)",
              "intent": "caches report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "reproduce_project",
          "signature": "(project_path:str,output_dir:str=None,target_lang:str=None,parallel:bool=False...+1)->ProjectResult",
          "intent": "reproduce project",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "concurrent.futures.ThreadPoolExecutor",
        "concurrent.futures.as_completed",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime",
        "pathlib.Path",
        "typing.Dict",
        "typing.List"
      ],
      "exports": [
        "SUPPORTED_EXTENSIONS",
        "FileResult",
        "ProjectResult",
        "ProjectReproducer",
        "reproduce_project"
      ]
    },
    {
      "path": "code2logic/prompts.py",
      "language": "python",
      "lines": 120,
      "classes": [],
      "functions": [
        {
          "name": "get_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str,language:str='python'...+1)->str",
          "intent": "retrieves reproduction prompt",
          "is_async": false
        },
        {
          "name": "get_review_prompt",
          "signature": "(code:str,spec:str,fmt:str)->str",
          "intent": "retrieves review prompt",
          "is_async": false
        },
        {
          "name": "get_fix_prompt",
          "signature": "(code:str,issues:list,spec:str)->str",
          "intent": "retrieves fix prompt",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Dict"
      ],
      "exports": [
        "FORMAT_HINTS",
        "get_reproduction_prompt",
        "get_review_prompt",
        "get_fix_prompt"
      ]
    },
    {
      "path": "code2logic/quality.py",
      "language": "python",
      "lines": 212,
      "classes": [
        {
          "name": "QualityIssue",
          "bases": [],
          "docstring": "Represents a code quality issue."
        },
        {
          "name": "QualityReport",
          "bases": [],
          "docstring": "Complete quality analysis report.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "QualityAnalyzer",
          "bases": [],
          "docstring": "Analyzes code quality and generates recommendations.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(thresholds:Dict[str,int]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "(project:ProjectInfo)->QualityReport",
              "intent": "processes",
              "is_async": false
            },
            {
              "name": "analyze_modules",
              "signature": "(modules:List[ModuleInfo])->QualityReport",
              "intent": "processes modules",
              "is_async": false
            },
            {
              "name": "_analyze_module",
              "signature": "(module:ModuleInfo,report:QualityReport)",
              "intent": "processes module",
              "is_async": false
            },
            {
              "name": "_check_function",
              "signature": "(func,file_path:str,report:QualityReport)",
              "intent": "checks function",
              "is_async": false
            },
            {
              "name": "_check_class",
              "signature": "(file_path:str,report:QualityReport)",
              "intent": "checks class",
              "is_async": false
            },
            {
              "name": "_get_file_recommendation",
              "signature": "(module:ModuleInfo)->str",
              "intent": "retrieves file recommendation",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "analyze_quality",
          "signature": "(project:ProjectInfo,thresholds:Dict[str,int]=None)->QualityReport",
          "intent": "processes quality",
          "is_async": false
        },
        {
          "name": "get_quality_summary",
          "signature": "(report:QualityReport)->str",
          "intent": "retrieves quality summary",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "models.ModuleInfo",
        "models.ProjectInfo"
      ],
      "exports": [
        "QualityIssue",
        "QualityReport",
        "QualityAnalyzer",
        "analyze_quality",
        "get_quality_summary"
      ]
    },
    {
      "path": "code2logic/refactor.py",
      "language": "python",
      "lines": 308,
      "classes": [
        {
          "name": "DuplicateGroup",
          "bases": [],
          "docstring": "Group of duplicate functions."
        },
        {
          "name": "RefactoringSuggestion",
          "bases": [],
          "docstring": "Single refactoring suggestion."
        },
        {
          "name": "RefactoringReport",
          "bases": [],
          "docstring": "Complete refactoring analysis report.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "to_markdown",
              "signature": "()->str",
              "intent": "converts markdown",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "find_duplicates",
          "signature": "(project_path:str,threshold:float=0.8)->List[DuplicateGroup]",
          "intent": "retrieves duplicates",
          "is_async": false
        },
        {
          "name": "analyze_quality",
          "signature": "(project_path:str,include_security:bool=True,include_performance:bool=True)->RefactoringReport",
          "intent": "processes quality",
          "is_async": false
        },
        {
          "name": "suggest_refactoring",
          "signature": "(project_path:str,use_llm:bool=False,client:BaseLLMClient=None)->RefactoringReport",
          "intent": "suggest refactoring",
          "is_async": false
        },
        {
          "name": "compare_codebases",
          "signature": "(project1:str,project2:str)->Dict[str, Any]",
          "intent": "compare codebases",
          "is_async": false
        },
        {
          "name": "quick_analyze",
          "signature": "(project_path:str)->Dict[str, Any]",
          "intent": "quick analyze",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "analyzer.analyze_project",
        "code_review.analyze_code_quality",
        "code_review.check_security_issues",
        "llm_clients.BaseLLMClient"
      ],
      "exports": [
        "DuplicateGroup",
        "RefactoringSuggestion",
        "RefactoringReport",
        "find_duplicates",
        "analyze_quality",
        "suggest_refactoring",
        "compare_codebases",
        "quick_analyze"
      ]
    },
    {
      "path": "code2logic/reproducer.py",
      "language": "python",
      "lines": 537,
      "classes": [
        {
          "name": "ReproductionStatus",
          "bases": [
            "Enum"
          ],
          "docstring": "Status of file reproduction."
        },
        {
          "name": "FileValidation",
          "bases": [],
          "docstring": "Validation result for a single file.",
          "methods": [
            {
              "name": "score",
              "signature": "()->float",
              "intent": "score",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "ReproductionResult",
          "bases": [],
          "docstring": "Result of reproduction process.",
          "methods": [
            {
              "name": "success_rate",
              "signature": "()->float",
              "intent": "success rate",
              "is_async": false
            },
            {
              "name": "average_score",
              "signature": "()->float",
              "intent": "average score",
              "is_async": false
            },
            {
              "name": "summary",
              "signature": "()->str",
              "intent": "summary",
              "is_async": false
            }
          ]
        },
        {
          "name": "SpecReproducer",
          "bases": [],
          "docstring": "Reproduces code structure from logic specifications.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reproduce_from_yaml",
              "signature": "(spec_path:str,output_dir:str,filter_paths:Optional[List[str]]=None)->ReproductionResult",
              "intent": "reproduce from yaml",
              "is_async": false
            },
            {
              "name": "reproduce_from_json",
              "signature": "(spec_path:str,output_dir:str,filter_paths:Optional[List[str]]=None)->ReproductionResult",
              "intent": "reproduce from json",
              "is_async": false
            },
            {
              "name": "_reproduce",
              "signature": "(spec:Dict[str,Any],output_dir:str,filter_paths:Optional[List[str]]=None)->ReproductionResult",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_generate_file",
              "signature": "(module:Dict[str,Any],output_path:Path)->bool",
              "intent": "creates file",
              "is_async": false
            },
            {
              "name": "_generate_python",
              "signature": "(module:Dict[str,Any])->str",
              "intent": "creates python",
              "is_async": false
            },
            {
              "name": "_render_docstring",
              "signature": "(text:str,indent:str)->List[str]",
              "intent": "formats docstring",
              "is_async": false
            },
            {
              "name": "_sanitize_python_property",
              "signature": "(prop:str)->str",
              "intent": "sanitize python property",
              "is_async": false
            },
            {
              "name": "_generate_python_class",
              "signature": "(cls:Dict[str,Any])->List[str]",
              "intent": "creates python class",
              "is_async": false
            },
            {
              "name": "_generate_python_method",
              "signature": "(method:Dict[str,Any])->List[str]",
              "intent": "creates python method",
              "is_async": false
            },
            {
              "name": "_generate_python_function",
              "signature": "(func:Dict[str,Any])->List[str]",
              "intent": "creates python function",
              "is_async": false
            },
            {
              "name": "_generate_typescript",
              "signature": "(module:Dict[str,Any])->str",
              "intent": "creates typescript",
              "is_async": false
            },
            {
              "name": "_generate_ts_class",
              "signature": "(cls:Dict[str,Any])->List[str]",
              "intent": "creates ts class",
              "is_async": false
            },
            {
              "name": "_generate_ts_method",
              "signature": "(method:Dict[str,Any])->List[str]",
              "intent": "creates ts method",
              "is_async": false
            },
            {
              "name": "_generate_ts_function",
              "signature": "(func:Dict[str,Any])->List[str]",
              "intent": "creates ts function",
              "is_async": false
            },
            {
              "name": "_parse_signature",
              "signature": "(sig:str)->str",
              "intent": "parses signature",
              "is_async": false
            }
          ]
        },
        {
          "name": "SpecValidator",
          "bases": [],
          "docstring": "Validates generated files against logic specification.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "validate",
              "signature": "(spec_path:str,generated_dir:str,filter_paths:Optional[List[str]]=None)->List[FileValidation]",
              "intent": "validates",
              "is_async": false
            },
            {
              "name": "_validate_file",
              "signature": "(module:Dict[str,Any],base_path:Path)->FileValidation",
              "intent": "validates file",
              "is_async": false
            },
            {
              "name": "_check_python_syntax",
              "signature": "(content:str,validation:FileValidation)->bool",
              "intent": "checks python syntax",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "_safe_load_yaml_file",
          "signature": "(path:str)->Any",
          "intent": "safe load yaml file",
          "is_async": false
        },
        {
          "name": "reproduce_project",
          "signature": "(spec_path:str,output_dir:str,filter_paths:Optional[List[str]]=None,validate:bool=True...+1)->ReproductionResult",
          "intent": "reproduce project",
          "is_async": false
        },
        {
          "name": "validate_files",
          "signature": "(spec_path:str,generated_dir:str,filter_paths:Optional[List[str]]=None)->List[FileValidation]",
          "intent": "validates files",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "ReproductionStatus",
        "FileValidation",
        "ReproductionResult",
        "SpecReproducer",
        "SpecValidator",
        "reproduce_project",
        "validate_files"
      ]
    },
    {
      "path": "code2logic/reproduction.py",
      "language": "python",
      "lines": 333,
      "classes": [
        {
          "name": "CodeReproducer",
          "bases": [],
          "docstring": "Code reproduction workflow using LLM.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None,provider:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "reproduce_file",
              "signature": "(source_path:str,output_dir:str=None)->Dict[str, Any]",
              "intent": "reproduce file",
              "is_async": false
            },
            {
              "name": "generate_from_gherkin",
              "signature": "(gherkin:str,language:str='python')->str",
              "intent": "creates from gherkin",
              "is_async": false
            },
            {
              "name": "_save_results",
              "signature": "(output_dir:Path,results:Dict[str,Any])",
              "intent": "caches results",
              "is_async": false
            },
            {
              "name": "_generate_report",
              "signature": "(results:Dict[str,Any])->str",
              "intent": "creates report",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_file_gherkin",
          "signature": "(file_path:Path)->str",
          "intent": "creates file gherkin",
          "is_async": false
        },
        {
          "name": "compare_code",
          "signature": "(original:str,generated:str)->Dict[str, Any]",
          "intent": "compare code",
          "is_async": false
        },
        {
          "name": "extract_code_block",
          "signature": "(text:str,language:str='python')->str",
          "intent": "parses code block",
          "is_async": false
        }
      ],
      "imports": [
        "difflib",
        "re",
        "datetime",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "llm_clients.BaseLLMClient",
        "llm_clients.get_client"
      ],
      "exports": [
        "generate_file_gherkin",
        "compare_code",
        "extract_code_block",
        "CodeReproducer"
      ]
    },
    {
      "path": "code2logic/schemas/__init__.py",
      "language": "python",
      "lines": 25,
      "classes": [],
      "functions": [],
      "imports": [
        "json_schema.JSONSchema",
        "json_schema.parse_json_spec",
        "json_schema.validate_json",
        "logicml_schema.LogicMLSchema",
        "logicml_schema.validate_logicml",
        "markdown_schema.MarkdownSchema",
        "markdown_schema.validate_markdown",
        "yaml_schema.YAMLSchema",
        "yaml_schema.validate_yaml"
      ],
      "exports": []
    },
    {
      "path": "code2logic/schemas/json_schema.py",
      "language": "python",
      "lines": 206,
      "classes": [
        {
          "name": "JSONMethodSchema",
          "bases": [],
          "docstring": "Schema for JSON method definition."
        },
        {
          "name": "JSONClassSchema",
          "bases": [],
          "docstring": "Schema for JSON class definition."
        },
        {
          "name": "JSONFunctionSchema",
          "bases": [],
          "docstring": "Schema for JSON function definition."
        },
        {
          "name": "JSONModuleSchema",
          "bases": [],
          "docstring": "Schema for JSON module definition."
        },
        {
          "name": "JSONSchema",
          "bases": [],
          "docstring": "Complete JSON specification schema."
        }
      ],
      "functions": [
        {
          "name": "validate_json",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates json",
          "is_async": false
        },
        {
          "name": "_validate_json_module",
          "signature": "(module:Dict,index:int)->List[str]",
          "intent": "validates json module",
          "is_async": false
        },
        {
          "name": "_validate_json_class",
          "signature": "(cls:Dict,prefix:str)->List[str]",
          "intent": "validates json class",
          "is_async": false
        },
        {
          "name": "parse_json_spec",
          "signature": "(spec:str)->Optional[JSONSchema]",
          "intent": "parses json spec",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple"
      ],
      "exports": [
        "JSONMethodSchema",
        "JSONClassSchema",
        "JSONFunctionSchema",
        "JSONModuleSchema",
        "JSONSchema",
        "validate_json",
        "parse_json_spec"
      ]
    },
    {
      "path": "code2logic/schemas/logicml_schema.py",
      "language": "python",
      "lines": 184,
      "classes": [
        {
          "name": "LogicMLMethod",
          "bases": [],
          "docstring": "Schema for LogicML method."
        },
        {
          "name": "LogicMLClass",
          "bases": [],
          "docstring": "Schema for LogicML class."
        },
        {
          "name": "LogicMLModule",
          "bases": [],
          "docstring": "Schema for LogicML module."
        },
        {
          "name": "LogicMLSchema",
          "bases": [],
          "docstring": "Complete LogicML specification schema.\n\n    Design Principles:\n    1."
        }
      ],
      "functions": [
        {
          "name": "validate_logicml",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates logicml",
          "is_async": false
        },
        {
          "name": "parse_logicml_header",
          "signature": "(line:str)->Optional[Dict[str, Any]]",
          "intent": "parses logicml header",
          "is_async": false
        },
        {
          "name": "extract_logicml_signature",
          "signature": "(sig_line:str)->Dict[str, Any]",
          "intent": "parses logicml signature",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Tuple"
      ],
      "exports": [
        "LogicMLMethod",
        "LogicMLClass",
        "LogicMLModule",
        "LogicMLSchema",
        "validate_logicml",
        "parse_logicml_header",
        "extract_logicml_signature"
      ]
    },
    {
      "path": "code2logic/schemas/markdown_schema.py",
      "language": "python",
      "lines": 118,
      "classes": [
        {
          "name": "MarkdownMethod",
          "bases": [],
          "docstring": "Schema for Markdown method."
        },
        {
          "name": "MarkdownClass",
          "bases": [],
          "docstring": "Schema for Markdown class."
        },
        {
          "name": "MarkdownModule",
          "bases": [],
          "docstring": "Schema for Markdown module."
        },
        {
          "name": "MarkdownSchema",
          "bases": [],
          "docstring": "Complete Markdown specification schema."
        }
      ],
      "functions": [
        {
          "name": "validate_markdown",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates markdown",
          "is_async": false
        },
        {
          "name": "extract_markdown_sections",
          "signature": "(spec:str)->Dict[str, Any]",
          "intent": "parses markdown sections",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Tuple"
      ],
      "exports": [
        "MarkdownMethod",
        "MarkdownClass",
        "MarkdownModule",
        "MarkdownSchema",
        "validate_markdown",
        "extract_markdown_sections"
      ]
    },
    {
      "path": "code2logic/schemas/yaml_schema.py",
      "language": "python",
      "lines": 167,
      "classes": [
        {
          "name": "MethodSchema",
          "bases": [],
          "docstring": "Schema for method definition."
        },
        {
          "name": "ClassSchema",
          "bases": [],
          "docstring": "Schema for class definition."
        },
        {
          "name": "FunctionSchema",
          "bases": [],
          "docstring": "Schema for function definition."
        },
        {
          "name": "ModuleSchema",
          "bases": [],
          "docstring": "Schema for module definition."
        },
        {
          "name": "YAMLSchema",
          "bases": [],
          "docstring": "Complete YAML specification schema."
        }
      ],
      "functions": [
        {
          "name": "validate_yaml",
          "signature": "(spec:str)->Tuple[bool, List[str]]",
          "intent": "validates yaml",
          "is_async": false
        },
        {
          "name": "_validate_module",
          "signature": "(module:Dict,index:int)->List[str]",
          "intent": "validates module",
          "is_async": false
        },
        {
          "name": "_validate_class",
          "signature": "(cls:Dict,prefix:str)->List[str]",
          "intent": "validates class",
          "is_async": false
        }
      ],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Tuple"
      ],
      "exports": [
        "MethodSchema",
        "ClassSchema",
        "FunctionSchema",
        "ModuleSchema",
        "YAMLSchema",
        "validate_yaml"
      ]
    },
    {
      "path": "code2logic/shared_utils.py",
      "language": "python",
      "lines": 279,
      "classes": [],
      "functions": [
        {
          "name": "compact_imports",
          "signature": "(imports:List[str],max_items:int=10)->List[str]",
          "intent": "compact imports",
          "is_async": false
        },
        {
          "name": "deduplicate_imports",
          "signature": "(imports:List[str])->List[str]",
          "intent": "deduplicate imports",
          "is_async": false
        },
        {
          "name": "abbreviate_type",
          "signature": "(type_str:str)->str",
          "intent": "abbreviate type",
          "is_async": false
        },
        {
          "name": "expand_type",
          "signature": "(abbrev:str)->str",
          "intent": "expand type",
          "is_async": false
        },
        {
          "name": "build_signature",
          "signature": "(params:List[str],return_type:Optional[str]=None,include_self:bool=False,abbreviate:bool=False...+1)->str",
          "intent": "creates signature",
          "is_async": false
        },
        {
          "name": "remove_self_from_params",
          "signature": "(params:List[str])->List[str]",
          "intent": "deletes self from params",
          "is_async": false
        },
        {
          "name": "categorize_function",
          "signature": "(name:str)->str",
          "intent": "categorize function",
          "is_async": false
        },
        {
          "name": "extract_domain",
          "signature": "(path:str)->str",
          "intent": "parses domain",
          "is_async": false
        },
        {
          "name": "compute_hash",
          "signature": "(name:str,signature:str,length:int=8)->str",
          "intent": "processes hash",
          "is_async": false
        },
        {
          "name": "truncate_docstring",
          "signature": "(docstring:Optional[str],max_length:int=60)->str",
          "intent": "truncate docstring",
          "is_async": false
        },
        {
          "name": "escape_for_yaml",
          "signature": "(text:str)->str",
          "intent": "escape for yaml",
          "is_async": false
        },
        {
          "name": "clean_identifier",
          "signature": "(name:str)->str",
          "intent": "clean identifier",
          "is_async": false
        }
      ],
      "imports": [
        "hashlib",
        "re",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Set"
      ],
      "exports": [
        "compact_imports",
        "deduplicate_imports",
        "TYPE_ABBREVIATIONS",
        "abbreviate_type",
        "expand_type",
        "build_signature",
        "remove_self_from_params",
        "CATEGORY_PATTERNS",
        "categorize_function",
        "DOMAIN_KEYWORDS"
      ]
    },
    {
      "path": "code2logic/similarity.py",
      "language": "python",
      "lines": 201,
      "classes": [
        {
          "name": "SimilarityDetector",
          "bases": [],
          "docstring": "Detects similar functions using fuzzy string matching.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(threshold:float=80.0)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "find_similar_functions",
              "signature": "(modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "retrieves similar functions",
              "is_async": false
            },
            {
              "name": "find_duplicate_signatures",
              "signature": "(modules:List[ModuleInfo])->Dict[str, List[str]]",
              "intent": "retrieves duplicate signatures",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(name:str,params:List[str],return_type:str=None)->str",
              "intent": "creates signature",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "is_rapidfuzz_available",
          "signature": "()->bool",
          "intent": "is rapidfuzz available",
          "is_async": false
        },
        {
          "name": "get_refactoring_suggestions",
          "signature": "(similar_functions:Dict[str,List[str]])->List[Dict[str, any]]",
          "intent": "retrieves refactoring suggestions",
          "is_async": false
        }
      ],
      "imports": [
        "logging",
        "time",
        "collections.defaultdict",
        "typing.Dict",
        "typing.List",
        "models.ModuleInfo",
        "rapidfuzz.fuzz",
        "rapidfuzz.process"
      ],
      "exports": [
        "RAPIDFUZZ_AVAILABLE",
        "SimilarityDetector",
        "is_rapidfuzz_available",
        "get_refactoring_suggestions"
      ]
    },
    {
      "path": "code2logic/terminal.py",
      "language": "python",
      "lines": 496,
      "classes": [
        {
          "name": "ShellRenderer",
          "bases": [],
          "docstring": "Renders colorized markdown output in terminal.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(use_colors:bool=True,verbose:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_supports_colors",
              "signature": "()->bool",
              "intent": "supports colors",
              "is_async": false
            },
            {
              "name": "enable_log",
              "signature": "()->None",
              "intent": "enable log",
              "is_async": false
            },
            {
              "name": "get_log",
              "signature": "()->str",
              "intent": "retrieves log",
              "is_async": false
            },
            {
              "name": "clear_log",
              "signature": "()->None",
              "intent": "deletes log",
              "is_async": false
            },
            {
              "name": "_log",
              "signature": "(text:str)->None",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "_c",
              "signature": "(color:str,text:str)->str",
              "intent": "c",
              "is_async": false
            },
            {
              "name": "heading",
              "signature": "(level:int,text:str)->None",
              "intent": "heading",
              "is_async": false
            },
            {
              "name": "codeblock",
              "signature": "(language:Language,content:str)->None",
              "intent": "codeblock",
              "is_async": false
            },
            {
              "name": "render_markdown",
              "signature": "(text:str)->None",
              "intent": "formats markdown",
              "is_async": false
            },
            {
              "name": "success",
              "signature": "(message:str)->None",
              "intent": "success",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(message:str)->None",
              "intent": "error",
              "is_async": false
            },
            {
              "name": "warning",
              "signature": "(message:str)->None",
              "intent": "warning",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(message:str)->None",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "status",
              "signature": "(icon:str,message:str,type:Literal[info,success,warning,error]='info')->None",
              "intent": "status",
              "is_async": false
            },
            {
              "name": "kv",
              "signature": "(key:str,value:Any)->None",
              "intent": "kv",
              "is_async": false
            },
            {
              "name": "progress",
              "signature": "(done:int,total:int,label:str='')->None",
              "intent": "progress",
              "is_async": false
            },
            {
              "name": "separator",
              "signature": "(char:str='',width:int=60)->None",
              "intent": "separator",
              "is_async": false
            },
            {
              "name": "table",
              "signature": "(headers:List[str],rows:List[List[Any]],widths:Optional[List[int]]=None)->None",
              "intent": "table",
              "is_async": false
            },
            {
              "name": "task",
              "signature": "(name:str,status:Literal[pending,running,done,failed],duration:Optional[float]=None)->None",
              "intent": "task",
              "is_async": false
            },
            {
              "name": "inline",
              "signature": "(text:str)->str",
              "intent": "inline",
              "is_async": false
            },
            {
              "name": "print",
              "signature": "(text:str,color:Optional[str]=None)->None",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "newline",
              "signature": "()->None",
              "intent": "newline",
              "is_async": false
            },
            {
              "name": "_highlight_line",
              "signature": "(line:str,language:str)->str",
              "intent": "highlight line",
              "is_async": false
            },
            {
              "name": "_highlight_yaml",
              "signature": "(line:str)->str",
              "intent": "highlight yaml",
              "is_async": false
            },
            {
              "name": "_highlight_json",
              "signature": "(line:str)->str",
              "intent": "highlight json",
              "is_async": false
            },
            {
              "name": "_highlight_python",
              "signature": "(line:str)->str",
              "intent": "highlight python",
              "is_async": false
            },
            {
              "name": "_highlight_bash",
              "signature": "(line:str)->str",
              "intent": "highlight bash",
              "is_async": false
            },
            {
              "name": "_highlight_js",
              "signature": "(line:str)->str",
              "intent": "highlight js",
              "is_async": false
            },
            {
              "name": "_highlight_gherkin",
              "signature": "(line:str)->str",
              "intent": "highlight gherkin",
              "is_async": false
            },
            {
              "name": "_highlight_log",
              "signature": "(line:str)->str",
              "intent": "highlight log",
              "is_async": false
            },
            {
              "name": "_highlight_markdown",
              "signature": "(line:str)->str",
              "intent": "highlight markdown",
              "is_async": false
            },
            {
              "name": "save_log",
              "signature": "(filepath:str)->None",
              "intent": "caches log",
              "is_async": false
            }
          ]
        },
        {
          "name": "RenderAPI",
          "bases": [],
          "docstring": "Convenience API for terminal rendering.",
          "methods": [
            {
              "name": "heading",
              "signature": "(level:int,text:str)->None",
              "intent": "heading",
              "is_async": false
            },
            {
              "name": "code",
              "signature": "(lang:Language,content:str)->None",
              "intent": "code",
              "is_async": false
            },
            {
              "name": "codeblock",
              "signature": "(lang:Language,content:str)->None",
              "intent": "codeblock",
              "is_async": false
            },
            {
              "name": "markdown",
              "signature": "(text:str)->None",
              "intent": "markdown",
              "is_async": false
            },
            {
              "name": "success",
              "signature": "(message:str)->None",
              "intent": "success",
              "is_async": false
            },
            {
              "name": "error",
              "signature": "(message:str)->None",
              "intent": "error",
              "is_async": false
            },
            {
              "name": "warning",
              "signature": "(message:str)->None",
              "intent": "warning",
              "is_async": false
            },
            {
              "name": "info",
              "signature": "(message:str)->None",
              "intent": "info",
              "is_async": false
            },
            {
              "name": "status",
              "signature": "(icon:str,message:str,type:Literal[info,success,warning,error]='info')->None",
              "intent": "status",
              "is_async": false
            },
            {
              "name": "kv",
              "signature": "(key:str,value:Any)->None",
              "intent": "kv",
              "is_async": false
            },
            {
              "name": "progress",
              "signature": "(done:int,total:int,label:str='')->None",
              "intent": "progress",
              "is_async": false
            },
            {
              "name": "separator",
              "signature": "(char:str='',width:int=60)->None",
              "intent": "separator",
              "is_async": false
            },
            {
              "name": "table",
              "signature": "(headers:List[str],rows:List[List[Any]],widths:Optional[List[int]]=None)->None",
              "intent": "table",
              "is_async": false
            },
            {
              "name": "task",
              "signature": "(name:str,status:Literal[pending,running,done,failed],duration:Optional[float]=None)->None",
              "intent": "task",
              "is_async": false
            },
            {
              "name": "inline",
              "signature": "(text:str)->str",
              "intent": "inline",
              "is_async": false
            },
            {
              "name": "print",
              "signature": "(text:str,color:Optional[str]=None)->None",
              "intent": "logs",
              "is_async": false
            },
            {
              "name": "newline",
              "signature": "()->None",
              "intent": "newline",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_renderer",
          "signature": "(use_colors:bool=True,verbose:bool=True)->ShellRenderer",
          "intent": "retrieves renderer",
          "is_async": false
        },
        {
          "name": "set_renderer",
          "signature": "(renderer:ShellRenderer)->None",
          "intent": "updates renderer",
          "is_async": false
        }
      ],
      "imports": [
        "os",
        "re",
        "sys",
        "typing.Any",
        "typing.List",
        "typing.Literal",
        "typing.Optional"
      ],
      "exports": [
        "COLORS",
        "ShellRenderer",
        "get_renderer",
        "set_renderer",
        "RenderAPI"
      ]
    },
    {
      "path": "code2logic/tools/__init__.py",
      "language": "python",
      "lines": 28,
      "classes": [],
      "functions": [],
      "imports": [
        "adaptive.LLM_CAPABILITIES",
        "adaptive.AdaptiveReproducer",
        "adaptive.AdaptiveResult",
        "adaptive.get_llm_capabilities",
        "benchmark.BenchmarkResult",
        "benchmark.FormatResult",
        "benchmark.ReproductionBenchmark",
        "benchmark.run_benchmark",
        "code_review.CodeReviewer",
        "code_review.analyze_code_quality"
      ],
      "exports": []
    },
    {
      "path": "code2logic/toon_format.py",
      "language": "python",
      "lines": 663,
      "classes": [
        {
          "name": "TOONGenerator",
          "bases": [],
          "docstring": "Generates TOON format output from ProjectInfo.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(delimiter:str=',',use_tabs:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_short_lang",
              "signature": "(lang:str)->str",
              "intent": "short lang",
              "is_async": false
            },
            {
              "name": "_compress_module_path",
              "signature": "(path:str,prev_dir:Any)->tuple[str, str]",
              "intent": "compress module path",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(project:ProjectInfo,detail:str='standard',no_repeat_name:bool=False)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_hybrid",
              "signature": "(project:ProjectInfo,detail:str='full',no_repeat_name:bool=True,hub_top_n:int=5...+1)->str",
              "intent": "creates hybrid",
              "is_async": false
            },
            {
              "name": "_generate_modules",
              "signature": "(modules:List[ModuleInfo],detail:str,no_repeat_name:bool=False)->List[str]",
              "intent": "creates modules",
              "is_async": false
            },
            {
              "name": "_generate_types",
              "signature": "(types:List[TypeInfo],indent:int=0)->List[str]",
              "intent": "creates types",
              "is_async": false
            },
            {
              "name": "_generate_classes",
              "signature": "(classes:List[ClassInfo],detail:str,indent:int=0)->List[str]",
              "intent": "creates classes",
              "is_async": false
            },
            {
              "name": "_generate_methods",
              "signature": "(methods:List[FunctionInfo],detail:str='standard',indent:int=0)->List[str]",
              "intent": "creates methods",
              "is_async": false
            },
            {
              "name": "_generate_functions",
              "signature": "(functions:List[FunctionInfo],detail:str,indent:int=0)->List[str]",
              "intent": "creates functions",
              "is_async": false
            },
            {
              "name": "_build_signature",
              "signature": "(f:FunctionInfo)->str",
              "intent": "creates signature",
              "is_async": false
            },
            {
              "name": "_quote",
              "signature": "(value:Any)->str",
              "intent": "quote",
              "is_async": false
            },
            {
              "name": "generate_compact",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates compact",
              "is_async": false
            },
            {
              "name": "generate_full",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates full",
              "is_async": false
            },
            {
              "name": "generate_schema",
              "signature": "(format_type:str='standard')->str",
              "intent": "creates schema",
              "is_async": false
            },
            {
              "name": "generate_ultra_compact",
              "signature": "(project:ProjectInfo)->str",
              "intent": "creates ultra compact",
              "is_async": false
            }
          ]
        },
        {
          "name": "TOONParser",
          "bases": [],
          "docstring": "Parse TOON format back to Python dict.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(content:str)->Dict[str, Any]",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_value",
              "signature": "(value:str)->Any",
              "intent": "parses value",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "generate_toon",
          "signature": "(project:ProjectInfo,detail:str='standard',use_tabs:bool=False)->str",
          "intent": "creates toon",
          "is_async": false
        },
        {
          "name": "parse_toon",
          "signature": "(content:str)->Dict[str, Any]",
          "intent": "parses toon",
          "is_async": false
        }
      ],
      "imports": [
        "re",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "models.ClassInfo",
        "models.FunctionInfo",
        "models.ModuleInfo",
        "models.ProjectInfo",
        "models.TypeInfo",
        "shared_utils.compact_imports"
      ],
      "exports": [
        "TOONGenerator",
        "TOONParser",
        "generate_toon",
        "parse_toon"
      ]
    },
    {
      "path": "code2logic/universal.py",
      "language": "python",
      "lines": 957,
      "classes": [
        {
          "name": "ElementType",
          "bases": [
            "Enum"
          ],
          "docstring": "Types of code elements."
        },
        {
          "name": "Language",
          "bases": [
            "Enum"
          ],
          "docstring": "Supported languages."
        },
        {
          "name": "Parameter",
          "bases": [],
          "docstring": "Function/method parameter."
        },
        {
          "name": "CodeElement",
          "bases": [],
          "docstring": "Universal representation of a code element."
        },
        {
          "name": "CodeLogic",
          "bases": [],
          "docstring": "Universal code logic representation for a single file.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "_element_to_dict",
              "signature": "(elem:CodeElement)->Dict[str, Any]",
              "intent": "element to dict",
              "is_async": false
            },
            {
              "name": "to_compact",
              "signature": "()->str",
              "intent": "converts compact",
              "is_async": false
            },
            {
              "name": "_element_to_compact",
              "signature": "(elem:CodeElement,indent:int)->List[str]",
              "intent": "element to compact",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalParser",
          "bases": [],
          "docstring": "Parse source code into universal CodeLogic format.",
          "methods": [
            {
              "name": "detect_language",
              "signature": "(content:str,file_ext:str)->Language",
              "intent": "detect language",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "(file_path:Union[str,Path])->CodeLogic",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_parse_rust",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses rust",
              "is_async": false
            },
            {
              "name": "_parse_java",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses java",
              "is_async": false
            },
            {
              "name": "_parse_csharp",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses csharp",
              "is_async": false
            },
            {
              "name": "_parse_python",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses python",
              "is_async": false
            },
            {
              "name": "_parse_js_ts",
              "signature": "(path:Path,content:str,hash_:str,lang:Language)->CodeLogic",
              "intent": "parses js ts",
              "is_async": false
            },
            {
              "name": "_parse_go",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses go",
              "is_async": false
            },
            {
              "name": "_parse_sql",
              "signature": "(path:Path,content:str,hash_:str)->CodeLogic",
              "intent": "parses sql",
              "is_async": false
            },
            {
              "name": "_parse_generic",
              "signature": "(path:Path,content:str,hash_:str,lang:Language)->CodeLogic",
              "intent": "parses generic",
              "is_async": false
            }
          ]
        },
        {
          "name": "CodeGenerator",
          "bases": [],
          "docstring": "Generate code from CodeLogic in target language.",
          "methods": [
            {
              "name": "generate",
              "signature": "(logic:CodeLogic,target_lang:Language)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_generate_python",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates python",
              "is_async": false
            },
            {
              "name": "_generate_python_element",
              "signature": "(elem:CodeElement,indent:int=0)->List[str]",
              "intent": "creates python element",
              "is_async": false
            },
            {
              "name": "_generate_typescript",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates typescript",
              "is_async": false
            },
            {
              "name": "_generate_go",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates go",
              "is_async": false
            },
            {
              "name": "_generate_sql",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates sql",
              "is_async": false
            },
            {
              "name": "_generate_rust",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates rust",
              "is_async": false
            },
            {
              "name": "_generate_java",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates java",
              "is_async": false
            },
            {
              "name": "_generate_csharp",
              "signature": "(logic:CodeLogic)->str",
              "intent": "creates csharp",
              "is_async": false
            },
            {
              "name": "_generate_generic",
              "signature": "(logic:CodeLogic,target:Language)->str",
              "intent": "creates generic",
              "is_async": false
            }
          ]
        },
        {
          "name": "UniversalReproducer",
          "bases": [],
          "docstring": "Universal code reproduction system.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(client:BaseLLMClient=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "_get_client",
              "signature": "()->BaseLLMClient",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "extract_logic",
              "signature": "(file_path:str)->CodeLogic",
              "intent": "parses logic",
              "is_async": false
            },
            {
              "name": "reproduce",
              "signature": "(source_path:str,target_lang:str=None,output_dir:str=None,use_llm:bool=True)->Dict[str, Any]",
              "intent": "reproduce",
              "is_async": false
            },
            {
              "name": "_generate_with_llm",
              "signature": "(logic:CodeLogic,target:Language)->str",
              "intent": "creates with llm",
              "is_async": false
            },
            {
              "name": "_save_result",
              "signature": "(output_dir:Path,original:str,logic:CodeLogic,generated:str...+1)",
              "intent": "caches result",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "reproduce_file",
          "signature": "(source_path:str,target_lang:str=None,output_dir:str=None,use_llm:bool=True)->Dict[str, Any]",
          "intent": "reproduce file",
          "is_async": false
        }
      ],
      "imports": [
        "hashlib",
        "json",
        "re",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict"
      ],
      "exports": [
        "ElementType",
        "Language",
        "Parameter",
        "CodeElement",
        "CodeLogic",
        "UniversalParser",
        "CodeGenerator",
        "UniversalReproducer",
        "reproduce_file"
      ]
    },
    {
      "path": "code2logic/utils.py",
      "language": "python",
      "lines": 16,
      "classes": [],
      "functions": [
        {
          "name": "estimate_tokens",
          "signature": "(text:str)->int",
          "intent": "estimate tokens",
          "is_async": false
        },
        {
          "name": "write_text_atomic",
          "signature": "(path:Path,content:str)->None",
          "intent": "logs text atomic",
          "is_async": false
        },
        {
          "name": "cleanup_generated_root",
          "signature": "(generated_root:Path,allowed_dirs:set[str])->None",
          "intent": "cleanup generated root",
          "is_async": false
        }
      ],
      "imports": [
        "shutil",
        "pathlib.Path"
      ],
      "exports": [
        "estimate_tokens",
        "write_text_atomic",
        "cleanup_generated_root"
      ]
    },
    {
      "path": "examples/01_quick_start.py",
      "language": "python",
      "lines": 47,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "pathlib.Path",
        "code2logic.analyze_project",
        "code2logic.quick_analyze",
        "code2logic.GherkinGenerator",
        "code2logic.CSVGenerator"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "examples/02_refactoring.py",
      "language": "python",
      "lines": 45,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "pathlib.Path",
        "code2logic.find_duplicates",
        "code2logic.analyze_quality",
        "code2logic.suggest_refactoring"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "examples/03_reproduction.py",
      "language": "python",
      "lines": 57,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "argparse",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.UniversalReproducer",
        "code2logic.reproduce_file",
        "code2logic.generate_file_gherkin"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "examples/04_project.py",
      "language": "python",
      "lines": 55,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "argparse",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.reproduce_project",
        "code2logic.compare_codebases"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "examples/05_llm_integration.py",
      "language": "python",
      "lines": 87,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "argparse",
        "os",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.get_client",
        "code2logic.OpenRouterClient",
        "code2logic.OllamaLocalClient",
        "code2logic.LLM_CAPABILITIES",
        "code2logic.suggest_refactoring"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "examples/06_metrics.py",
      "language": "python",
      "lines": 85,
      "classes": [],
      "functions": [
        {
          "name": "analyze_file",
          "signature": "(source_path:str,verbose:bool=False,no_llm:bool=False)",
          "intent": "processes file",
          "is_async": false
        },
        {
          "name": "_template_generate",
          "signature": "(spec:str)->str",
          "intent": "template generate",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "argparse",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.ReproductionMetrics",
        "code2logic.get_client",
        "code2logic.generate_file_gherkin",
        "code2logic.reproduction.extract_code_block"
      ],
      "exports": [
        "analyze_file",
        "main"
      ]
    },
    {
      "path": "examples/06_metrics_simple.py",
      "language": "python",
      "lines": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "examples/08_format_benchmark.py",
      "language": "python",
      "lines": 90,
      "classes": [],
      "functions": [
        {
          "name": "print_format_comparison",
          "signature": "(result)",
          "intent": "logs format comparison",
          "is_async": false
        },
        {
          "name": "print_per_file_results",
          "signature": "(result)",
          "intent": "logs per file results",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig"
      ],
      "exports": [
        "print_format_comparison",
        "print_per_file_results",
        "main"
      ]
    },
    {
      "path": "examples/09_async_benchmark.py",
      "language": "python",
      "lines": 60,
      "classes": [],
      "functions": [
        {
          "name": "print_results",
          "signature": "(result)",
          "intent": "logs results",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig"
      ],
      "exports": [
        "print_results",
        "main"
      ]
    },
    {
      "path": "examples/10_function_reproduction.py",
      "language": "python",
      "lines": 51,
      "classes": [],
      "functions": [
        {
          "name": "print_results",
          "signature": "(result)",
          "intent": "logs results",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig"
      ],
      "exports": [
        "print_results",
        "main"
      ]
    },
    {
      "path": "examples/11_token_benchmark.py",
      "language": "python",
      "lines": 69,
      "classes": [],
      "functions": [
        {
          "name": "print_token_efficiency",
          "signature": "(result)",
          "intent": "logs token efficiency",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig"
      ],
      "exports": [
        "print_token_efficiency",
        "main"
      ]
    },
    {
      "path": "examples/12_comprehensive_analysis.py",
      "language": "python",
      "lines": 95,
      "classes": [],
      "functions": [
        {
          "name": "print_comprehensive_analysis",
          "signature": "(result)",
          "intent": "logs comprehensive analysis",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig"
      ],
      "exports": [
        "ALL_FORMATS",
        "print_comprehensive_analysis",
        "main"
      ]
    },
    {
      "path": "examples/12_comprehensive_analysis_simple.py",
      "language": "python",
      "lines": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "examples/13_project_benchmark.py",
      "language": "python",
      "lines": 70,
      "classes": [],
      "functions": [
        {
          "name": "print_project_results",
          "signature": "(result)",
          "intent": "logs project results",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig"
      ],
      "exports": [
        "print_project_results",
        "main"
      ]
    },
    {
      "path": "examples/14_repeatability_test.py",
      "language": "python",
      "lines": 331,
      "classes": [
        {
          "name": "RunResult",
          "bases": [],
          "docstring": "Result of a single generation run."
        },
        {
          "name": "RepeatabilityResult",
          "bases": [],
          "docstring": "Repeatability analysis for a format."
        }
      ],
      "functions": [
        {
          "name": "_template_generate",
          "signature": "(spec:str,fmt:str,file_name:str)->str",
          "intent": "template generate",
          "is_async": false
        },
        {
          "name": "generate_spec",
          "signature": "(project:ProjectInfo,fmt:str)->str",
          "intent": "creates spec",
          "is_async": false
        },
        {
          "name": "get_reproduction_prompt",
          "signature": "(spec:str,fmt:str,file_name:str)->str",
          "intent": "retrieves reproduction prompt",
          "is_async": false
        },
        {
          "name": "calculate_similarity",
          "signature": "(code1:str,code2:str)->float",
          "intent": "processes similarity",
          "is_async": false
        },
        {
          "name": "get_diff",
          "signature": "(code1:str,code2:str,label1:str='Run 1',label2:str='Run 2')->List[str]",
          "intent": "retrieves diff",
          "is_async": false
        },
        {
          "name": "test_syntax",
          "signature": "(code:str)->bool",
          "intent": "checks syntax",
          "is_async": false
        },
        {
          "name": "run_repeatability_test",
          "signature": "(file_path:str,formats:List[str],num_runs:int=3,verbose:bool=False...+1)->Dict[str, RepeatabilityResult]",
          "intent": "starts repeatability test",
          "is_async": false
        },
        {
          "name": "print_repeatability_summary",
          "signature": "(results:Dict[str,RepeatabilityResult])",
          "intent": "logs repeatability summary",
          "is_async": false
        },
        {
          "name": "save_repeatability_report",
          "signature": "(results:Dict[str,RepeatabilityResult],output:str)",
          "intent": "caches repeatability report",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "difflib",
        "json",
        "sys",
        "time",
        "pathlib.Path",
        "datetime",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Dict"
      ],
      "exports": [
        "RunResult",
        "RepeatabilityResult",
        "generate_spec",
        "get_reproduction_prompt",
        "calculate_similarity",
        "get_diff",
        "test_syntax",
        "run_repeatability_test",
        "print_repeatability_summary",
        "save_repeatability_report"
      ]
    },
    {
      "path": "examples/15_unified_benchmark.py",
      "language": "python",
      "lines": 143,
      "classes": [],
      "functions": [
        {
          "name": "print_format_results",
          "signature": "(result)",
          "intent": "logs format results",
          "is_async": false
        },
        {
          "name": "print_function_results",
          "signature": "(result)",
          "intent": "logs function results",
          "is_async": false
        },
        {
          "name": "print_project_results",
          "signature": "(result)",
          "intent": "logs project results",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "os",
        "sys",
        "pathlib.Path",
        "dotenv.load_dotenv",
        "code2logic.benchmarks.BenchmarkRunner",
        "code2logic.benchmarks.BenchmarkConfig",
        "code2logic.benchmarks.run_benchmark",
        "code2logic.llm_clients.get_client"
      ],
      "exports": [
        "print_format_results",
        "print_function_results",
        "print_project_results",
        "main"
      ]
    },
    {
      "path": "examples/16_terminal_demo.py",
      "language": "python",
      "lines": 178,
      "classes": [],
      "functions": [
        {
          "name": "demo_headings",
          "signature": "()",
          "intent": "demo headings",
          "is_async": false
        },
        {
          "name": "demo_codeblocks",
          "signature": "()",
          "intent": "demo codeblocks",
          "is_async": false
        },
        {
          "name": "demo_status_messages",
          "signature": "()",
          "intent": "demo status messages",
          "is_async": false
        },
        {
          "name": "demo_progress",
          "signature": "()",
          "intent": "demo progress",
          "is_async": false
        },
        {
          "name": "demo_tasks",
          "signature": "()",
          "intent": "demo tasks",
          "is_async": false
        },
        {
          "name": "demo_key_value",
          "signature": "()",
          "intent": "demo key value",
          "is_async": false
        },
        {
          "name": "demo_tables",
          "signature": "()",
          "intent": "demo tables",
          "is_async": false
        },
        {
          "name": "demo_markdown",
          "signature": "()",
          "intent": "demo markdown",
          "is_async": false
        },
        {
          "name": "demo_log_highlighting",
          "signature": "()",
          "intent": "demo log highlighting",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "code2logic.terminal.render",
        "code2logic.terminal.ShellRenderer",
        "code2logic.terminal.get_renderer",
        "code2logic.terminal.set_renderer"
      ],
      "exports": [
        "demo_headings",
        "demo_codeblocks",
        "demo_status_messages",
        "demo_progress",
        "demo_tasks",
        "demo_key_value",
        "demo_tables",
        "demo_markdown",
        "demo_log_highlighting",
        "main"
      ]
    },
    {
      "path": "examples/behavioral_benchmark.py",
      "language": "python",
      "lines": 220,
      "classes": [
        {
          "name": "CaseResult",
          "bases": [],
          "docstring": null
        },
        {
          "name": "FunctionBehaviorResult",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "_load_module_from_path",
          "signature": "(path:Path,module_name:str)->Any",
          "intent": "retrieves module from path",
          "is_async": false
        },
        {
          "name": "_exec_function_from_code",
          "signature": "(code:str,function_name:str)->Callable[..., Any]",
          "intent": "exec function from code",
          "is_async": false
        },
        {
          "name": "_values_equal",
          "signature": "(got:Any,expected:Any)->bool",
          "intent": "values equal",
          "is_async": false
        },
        {
          "name": "_run_case",
          "signature": "(label:str,fn:Callable[Any,Any],expected:Any)->CaseResult",
          "intent": "starts case",
          "is_async": false
        },
        {
          "name": "_looks_like_template_stub",
          "signature": "(code:str)->bool",
          "intent": "looks like template stub",
          "is_async": false
        },
        {
          "name": "_cases_for",
          "signature": "(function_name:str)->List[Tuple[str, Callable[[], Tuple[Tuple[Any, ...], Dict[str, Any]]]]]",
          "intent": "cases for",
          "is_async": false
        },
        {
          "name": "_apply_env_hook",
          "signature": "(kwargs:Dict[str,Any])->Dict[str, Any]",
          "intent": "apply env hook",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()->None",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "importlib.util",
        "json",
        "os",
        "tempfile",
        "dataclasses.asdict",
        "dataclasses.dataclass",
        "pathlib.Path",
        "typing.Any",
        "typing.Callable",
        "typing.Dict"
      ],
      "exports": [
        "CaseResult",
        "FunctionBehaviorResult",
        "main"
      ]
    },
    {
      "path": "examples/benchmark_report.py",
      "language": "python",
      "lines": 170,
      "classes": [
        {
          "name": "Artifact",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "_load_json",
          "signature": "(path:Path)->Optional[Dict[str, Any]]",
          "intent": "retrieves json",
          "is_async": false
        },
        {
          "name": "_sizeof",
          "signature": "(path:Path)->int",
          "intent": "sizeof",
          "is_async": false
        },
        {
          "name": "_fmt_bytes",
          "signature": "(n:int)->str",
          "intent": "fmt bytes",
          "is_async": false
        },
        {
          "name": "_token_estimate_bytes",
          "signature": "(n:int)->int",
          "intent": "token estimate bytes",
          "is_async": false
        },
        {
          "name": "_calc_function_summary",
          "signature": "(d:Dict[str,Any])->Tuple[int, float, float]",
          "intent": "calc function summary",
          "is_async": false
        },
        {
          "name": "_calc_file_summary",
          "signature": "(d:Dict[str,Any])->Tuple[int, float, float, float]",
          "intent": "calc file summary",
          "is_async": false
        },
        {
          "name": "_read_commands",
          "signature": "(commands_path:Path)->List[str]",
          "intent": "retrieves commands",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()->None",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "shlex",
        "dataclasses.dataclass",
        "datetime",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "Artifact",
        "main"
      ]
    },
    {
      "path": "examples/benchmark_summary.py",
      "language": "python",
      "lines": 100,
      "classes": [],
      "functions": [
        {
          "name": "_fmt_bytes",
          "signature": "(n:int)->str",
          "intent": "fmt bytes",
          "is_async": false
        },
        {
          "name": "_token_estimate_bytes",
          "signature": "(n:int)->int",
          "intent": "token estimate bytes",
          "is_async": false
        },
        {
          "name": "_artifact_row",
          "signature": "(label:str,path:str)->str",
          "intent": "artifact row",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "sys"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "examples/code2logic/sample_project/__init__.py",
      "language": "python",
      "lines": 1,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "examples/code2logic/sample_project/api/client.py",
      "language": "python",
      "lines": 15,
      "classes": [
        {
          "name": "Response",
          "bases": [],
          "docstring": "Very small HTTP-like response placeholder."
        },
        {
          "name": "APIClient",
          "bases": [],
          "docstring": "Example client with async methods.",
          "methods": [
            {
              "name": "get",
              "signature": "(url:str)->Response",
              "intent": "retrieves",
              "is_async": true
            },
            {
              "name": "post",
              "signature": "(url:str,data:dict)->Response",
              "intent": "creates",
              "is_async": true
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass"
      ],
      "exports": [
        "Response",
        "APIClient"
      ]
    },
    {
      "path": "examples/code2logic/sample_project/calculator.py",
      "language": "python",
      "lines": 22,
      "classes": [
        {
          "name": "Calculator",
          "bases": [],
          "docstring": "A tiny calculator used for Code2Logic examples.",
          "methods": [
            {
              "name": "add",
              "signature": "(a:float,b:float)->float",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "divide",
              "signature": "(a:float,b:float)->float",
              "intent": "splits",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "factorial",
          "signature": "(n:int)->int",
          "intent": "factorial",
          "is_async": false
        }
      ],
      "imports": [],
      "exports": [
        "Calculator",
        "factorial"
      ]
    },
    {
      "path": "examples/code2logic/sample_project/models/user.py",
      "language": "python",
      "lines": 9,
      "classes": [
        {
          "name": "User",
          "bases": [],
          "docstring": "Simple user model."
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass"
      ],
      "exports": [
        "User"
      ]
    },
    {
      "path": "examples/duplicate_detection.py",
      "language": "python",
      "lines": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "examples/token_efficiency.py",
      "language": "python",
      "lines": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "examples/windsurf_mcp_integration.py",
      "language": "python",
      "lines": 0,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "logic2code/__init__.py",
      "language": "python",
      "lines": 13,
      "classes": [],
      "functions": [],
      "imports": [
        "generator.CodeGenerator",
        "generator.GeneratorConfig",
        "generator.GenerationResult",
        "renderers.PythonRenderer"
      ],
      "exports": []
    },
    {
      "path": "logic2code/__main__.py",
      "language": "python",
      "lines": 8,
      "classes": [],
      "functions": [],
      "imports": [
        "cli.main"
      ],
      "exports": []
    },
    {
      "path": "logic2code/cli.py",
      "language": "python",
      "lines": 152,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "generator.CodeGenerator",
        "generator.GeneratorConfig",
        "generator.GenerationResult"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "logic2code/examples/01_quickstart.py",
      "language": "python",
      "lines": 72,
      "classes": [],
      "functions": [
        {
          "name": "example_basic_generation",
          "signature": "()",
          "intent": "example basic generation",
          "is_async": false
        },
        {
          "name": "example_with_config",
          "signature": "()",
          "intent": "example with config",
          "is_async": false
        },
        {
          "name": "example_stubs_only",
          "signature": "()",
          "intent": "example stubs only",
          "is_async": false
        },
        {
          "name": "example_single_module",
          "signature": "()",
          "intent": "example single module",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "sys",
        "logic2code.CodeGenerator",
        "logic2code.GeneratorConfig"
      ],
      "exports": [
        "example_basic_generation",
        "example_with_config",
        "example_stubs_only",
        "example_single_module"
      ]
    },
    {
      "path": "logic2code/examples/02_llm_enhanced.py",
      "language": "python",
      "lines": 77,
      "classes": [],
      "functions": [
        {
          "name": "example_llm_generation",
          "signature": "()",
          "intent": "example llm generation",
          "is_async": false
        },
        {
          "name": "example_hybrid_generation",
          "signature": "()",
          "intent": "example hybrid generation",
          "is_async": false
        },
        {
          "name": "example_compare_outputs",
          "signature": "()",
          "intent": "example compare outputs",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "sys",
        "logic2code.CodeGenerator",
        "logic2code.GeneratorConfig"
      ],
      "exports": [
        "example_llm_generation",
        "example_hybrid_generation",
        "example_compare_outputs"
      ]
    },
    {
      "path": "logic2code/generator.py",
      "language": "python",
      "lines": 233,
      "classes": [
        {
          "name": "GeneratorConfig",
          "bases": [],
          "docstring": "Configuration for code generation."
        },
        {
          "name": "GenerationResult",
          "bases": [],
          "docstring": "Result of code generation."
        },
        {
          "name": "CodeGenerator",
          "bases": [],
          "docstring": "Main code generator class.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(logic_file:Union[str,Path],config:Optional[GeneratorConfig]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "project",
              "signature": "()->ProjectSpec",
              "intent": "project",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(output_dir:Union[str,Path],modules:Optional[List[str]]=None)->GenerationResult",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_module",
              "signature": "(module_path:str)->str",
              "intent": "creates module",
              "is_async": false
            },
            {
              "name": "generate_class",
              "signature": "(class_name:str,module_path:Optional[str]=None)->str",
              "intent": "creates class",
              "is_async": false
            },
            {
              "name": "generate_function",
              "signature": "(func_name:str,module_path:Optional[str]=None)->str",
              "intent": "creates function",
              "is_async": false
            },
            {
              "name": "_get_output_path",
              "signature": "(output_dir:Path,module_path:str)->Path",
              "intent": "retrieves output path",
              "is_async": false
            },
            {
              "name": "summary",
              "signature": "()->Dict",
              "intent": "summary",
              "is_async": false
            },
            {
              "name": "list_modules",
              "signature": "()->List[str]",
              "intent": "list modules",
              "is_async": false
            },
            {
              "name": "list_classes",
              "signature": "()->List[str]",
              "intent": "list classes",
              "is_async": false
            },
            {
              "name": "list_functions",
              "signature": "()->List[str]",
              "intent": "list functions",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "sys",
        "logic2test.parsers.LogicParser"
      ],
      "exports": [
        "GeneratorConfig",
        "GenerationResult",
        "CodeGenerator"
      ]
    },
    {
      "path": "logic2code/renderers.py",
      "language": "python",
      "lines": 297,
      "classes": [
        {
          "name": "RenderConfig",
          "bases": [],
          "docstring": "Configuration for code rendering."
        },
        {
          "name": "BaseRenderer",
          "bases": [
            "ABC"
          ],
          "docstring": "Abstract base class for language-specific renderers.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(config:Optional[RenderConfig]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "render_module",
              "signature": "(module:ModuleSpec)->str",
              "intent": "formats module",
              "is_async": false
            },
            {
              "name": "render_class",
              "signature": "(cls:ClassSpec)->str",
              "intent": "formats class",
              "is_async": false
            },
            {
              "name": "render_function",
              "signature": "(func:FunctionSpec)->str",
              "intent": "formats function",
              "is_async": false
            }
          ]
        },
        {
          "name": "PythonRenderer",
          "bases": [
            "BaseRenderer"
          ],
          "docstring": "Python code renderer.",
          "methods": [
            {
              "name": "render_module",
              "signature": "(module:ModuleSpec)->str",
              "intent": "formats module",
              "is_async": false
            },
            {
              "name": "_collect_imports",
              "signature": "(module:ModuleSpec)->str",
              "intent": "collect imports",
              "is_async": false
            },
            {
              "name": "_render_constant",
              "signature": "(const:Dict[str,Any])->str",
              "intent": "formats constant",
              "is_async": false
            },
            {
              "name": "render_class",
              "signature": "(cls:ClassSpec)->str",
              "intent": "formats class",
              "is_async": false
            },
            {
              "name": "_render_field",
              "signature": "(fld:Dict[str,Any])->str",
              "intent": "formats field",
              "is_async": false
            },
            {
              "name": "_render_method",
              "signature": "(method:FunctionSpec)->str",
              "intent": "formats method",
              "is_async": false
            },
            {
              "name": "render_function",
              "signature": "(func:FunctionSpec)->str",
              "intent": "formats function",
              "is_async": false
            },
            {
              "name": "_render_function_internal",
              "signature": "(func:FunctionSpec,is_method:bool=False)->str",
              "intent": "formats function internal",
              "is_async": false
            },
            {
              "name": "_build_params",
              "signature": "(func:FunctionSpec,is_method:bool)->List[str]",
              "intent": "creates params",
              "is_async": false
            },
            {
              "name": "_split_params",
              "signature": "(params_str:str)->List[str]",
              "intent": "splits params",
              "is_async": false
            },
            {
              "name": "render_init_file",
              "signature": "(modules:List[ModuleSpec])->str",
              "intent": "formats init file",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "re",
        "abc.ABC",
        "abc.abstractmethod",
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Set"
      ],
      "exports": [
        "RenderConfig",
        "BaseRenderer",
        "PythonRenderer"
      ]
    },
    {
      "path": "logic2code/tests/__init__.py",
      "language": "python",
      "lines": 1,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "logic2code/tests/test_basic.py",
      "language": "python",
      "lines": 40,
      "classes": [],
      "functions": [
        {
          "name": "test_import_logic2code",
          "signature": "()",
          "intent": "checks import logic2code",
          "is_async": false
        },
        {
          "name": "test_import_generator",
          "signature": "()",
          "intent": "checks import generator",
          "is_async": false
        },
        {
          "name": "test_config_defaults",
          "signature": "()",
          "intent": "checks config defaults",
          "is_async": false
        },
        {
          "name": "test_generator_config_custom",
          "signature": "()",
          "intent": "checks generator config custom",
          "is_async": false
        },
        {
          "name": "test_generator_config_llm",
          "signature": "()",
          "intent": "checks generator config llm",
          "is_async": false
        }
      ],
      "imports": [
        "pytest"
      ],
      "exports": [
        "test_import_logic2code",
        "test_import_generator",
        "test_config_defaults",
        "test_generator_config_custom",
        "test_generator_config_llm"
      ]
    },
    {
      "path": "logic2test/__init__.py",
      "language": "python",
      "lines": 14,
      "classes": [],
      "functions": [],
      "imports": [
        "generator.TestGenerator",
        "generator.GeneratorConfig",
        "generator.GenerationResult",
        "parsers.LogicParser",
        "templates.TestTemplate"
      ],
      "exports": []
    },
    {
      "path": "logic2test/__main__.py",
      "language": "python",
      "lines": 8,
      "classes": [],
      "functions": [],
      "imports": [
        "cli.main"
      ],
      "exports": []
    },
    {
      "path": "logic2test/cli.py",
      "language": "python",
      "lines": 131,
      "classes": [],
      "functions": [
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "sys",
        "pathlib.Path",
        "generator.TestGenerator",
        "generator.GeneratorConfig",
        "generator.GenerationResult"
      ],
      "exports": [
        "main"
      ]
    },
    {
      "path": "logic2test/examples/01_quickstart.py",
      "language": "python",
      "lines": 62,
      "classes": [],
      "functions": [
        {
          "name": "example_basic_generation",
          "signature": "()",
          "intent": "example basic generation",
          "is_async": false
        },
        {
          "name": "example_with_config",
          "signature": "()",
          "intent": "example with config",
          "is_async": false
        },
        {
          "name": "example_generate_all_types",
          "signature": "()",
          "intent": "example generate all types",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "sys",
        "logic2test.TestGenerator",
        "logic2test.GeneratorConfig"
      ],
      "exports": [
        "example_basic_generation",
        "example_with_config",
        "example_generate_all_types"
      ]
    },
    {
      "path": "logic2test/examples/02_custom_templates.py",
      "language": "python",
      "lines": 92,
      "classes": [],
      "functions": [
        {
          "name": "example_function_test",
          "signature": "()",
          "intent": "example function test",
          "is_async": false
        },
        {
          "name": "example_class_test",
          "signature": "()",
          "intent": "example class test",
          "is_async": false
        },
        {
          "name": "example_dataclass_test",
          "signature": "()",
          "intent": "example dataclass test",
          "is_async": false
        },
        {
          "name": "example_async_function_test",
          "signature": "()",
          "intent": "example async function test",
          "is_async": false
        }
      ],
      "imports": [
        "pathlib.Path",
        "sys",
        "logic2test.templates.TestTemplate",
        "logic2test.parsers.FunctionSpec",
        "logic2test.parsers.ClassSpec"
      ],
      "exports": [
        "example_function_test",
        "example_class_test",
        "example_dataclass_test",
        "example_async_function_test"
      ]
    },
    {
      "path": "logic2test/generator.py",
      "language": "python",
      "lines": 328,
      "classes": [
        {
          "name": "GeneratorConfig",
          "bases": [],
          "docstring": "Configuration for test generation."
        },
        {
          "name": "GenerationResult",
          "bases": [],
          "docstring": "Result of test generation."
        },
        {
          "name": "TestGenerator",
          "bases": [],
          "docstring": "Main test generator class.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(logic_file:Union[str,Path],config:Optional[GeneratorConfig]=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "project",
              "signature": "()->ProjectSpec",
              "intent": "project",
              "is_async": false
            },
            {
              "name": "generate_unit_tests",
              "signature": "(output_dir:Union[str,Path],modules:Optional[List[str]]=None)->GenerationResult",
              "intent": "creates unit tests",
              "is_async": false
            },
            {
              "name": "_generate_module_tests",
              "signature": "(module:ModuleSpec)->tuple",
              "intent": "creates module tests",
              "is_async": false
            },
            {
              "name": "_generate_class_tests",
              "signature": "(cls:ClassSpec)->str",
              "intent": "creates class tests",
              "is_async": false
            },
            {
              "name": "_should_test_class",
              "signature": "(cls:ClassSpec)->bool",
              "intent": "checks test class",
              "is_async": false
            },
            {
              "name": "_should_test_function",
              "signature": "(func:FunctionSpec)->bool",
              "intent": "checks test function",
              "is_async": false
            },
            {
              "name": "_get_test_filename",
              "signature": "(module_path:str)->str",
              "intent": "retrieves test filename",
              "is_async": false
            },
            {
              "name": "generate_integration_tests",
              "signature": "(output_dir:Union[str,Path],entry_points:Optional[List[str]]=None)->GenerationResult",
              "intent": "creates integration tests",
              "is_async": false
            },
            {
              "name": "generate_property_tests",
              "signature": "(output_dir:Union[str,Path])->GenerationResult",
              "intent": "creates property tests",
              "is_async": false
            },
            {
              "name": "summary",
              "signature": "()->Dict",
              "intent": "summary",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union",
        "parsers.LogicParser",
        "parsers.ProjectSpec"
      ],
      "exports": [
        "GeneratorConfig",
        "GenerationResult",
        "TestGenerator"
      ]
    },
    {
      "path": "logic2test/parsers.py",
      "language": "python",
      "lines": 272,
      "classes": [
        {
          "name": "FunctionSpec",
          "bases": [],
          "docstring": "Specification of a function/method extracted from logic file."
        },
        {
          "name": "ClassSpec",
          "bases": [],
          "docstring": "Specification of a class extracted from logic file."
        },
        {
          "name": "ModuleSpec",
          "bases": [],
          "docstring": "Specification of a module extracted from logic file."
        },
        {
          "name": "ProjectSpec",
          "bases": [],
          "docstring": "Full project specification from logic file."
        },
        {
          "name": "LogicParser",
          "bases": [],
          "docstring": "Parser for Code2Logic output formats.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(file_path:Union[str,Path])",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "parse",
              "signature": "()->ProjectSpec",
              "intent": "parses",
              "is_async": false
            },
            {
              "name": "_detect_and_parse_format",
              "signature": "()->None",
              "intent": "detect and parse format",
              "is_async": false
            },
            {
              "name": "_parse_yaml",
              "signature": "()->None",
              "intent": "parses yaml",
              "is_async": false
            },
            {
              "name": "_parse_yaml_simple",
              "signature": "()->None",
              "intent": "parses yaml simple",
              "is_async": false
            },
            {
              "name": "_parse_toon",
              "signature": "()->None",
              "intent": "parses toon",
              "is_async": false
            },
            {
              "name": "_build_project_spec",
              "signature": "()->ProjectSpec",
              "intent": "creates project spec",
              "is_async": false
            },
            {
              "name": "_build_module_spec",
              "signature": "(mod_data:Dict)->ModuleSpec",
              "intent": "creates module spec",
              "is_async": false
            },
            {
              "name": "_build_class_spec",
              "signature": "(cls_data:Dict,module_path:str)->ClassSpec",
              "intent": "creates class spec",
              "is_async": false
            },
            {
              "name": "_build_function_spec",
              "signature": "(func_data:Dict,module_path:str,is_method:bool=False,class_name:Optional[str]=None)->FunctionSpec",
              "intent": "creates function spec",
              "is_async": false
            },
            {
              "name": "_parse_params_from_sig",
              "signature": "(sig:str)->List[str]",
              "intent": "parses params from sig",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "re",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Union"
      ],
      "exports": [
        "FunctionSpec",
        "ClassSpec",
        "ModuleSpec",
        "ProjectSpec",
        "LogicParser"
      ]
    },
    {
      "path": "logic2test/templates.py",
      "language": "python",
      "lines": 198,
      "classes": [
        {
          "name": "TestTemplate",
          "bases": [],
          "docstring": "Template for generating test code.",
          "methods": [
            {
              "name": "render_test_file_header",
              "signature": "(module_path:str,imports:List[str]=None)->str",
              "intent": "formats test file header",
              "is_async": false
            },
            {
              "name": "render_function_test",
              "signature": "(func_name:str,params:List[str],return_type:Optional[str]=None,docstring:Optional[str]=None...+2)->str",
              "intent": "formats function test",
              "is_async": false
            },
            {
              "name": "render_class_test",
              "signature": "(class_name:str,bases:List[str],is_dataclass:bool=False,fields:List[dict]=None...+1)->str",
              "intent": "formats class test",
              "is_async": false
            },
            {
              "name": "render_dataclass_test",
              "signature": "(class_name:str,fields:List[dict])->str",
              "intent": "formats dataclass test",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "TestTemplate"
      ]
    },
    {
      "path": "logic2test/tests/__init__.py",
      "language": "python",
      "lines": 1,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "logic2test/tests/test_basic.py",
      "language": "python",
      "lines": 31,
      "classes": [],
      "functions": [
        {
          "name": "test_import_logic2test",
          "signature": "()",
          "intent": "checks import logic2test",
          "is_async": false
        },
        {
          "name": "test_import_generator",
          "signature": "()",
          "intent": "checks import generator",
          "is_async": false
        },
        {
          "name": "test_config_defaults",
          "signature": "()",
          "intent": "checks config defaults",
          "is_async": false
        },
        {
          "name": "test_generator_config_custom",
          "signature": "()",
          "intent": "checks generator config custom",
          "is_async": false
        }
      ],
      "imports": [
        "pytest"
      ],
      "exports": [
        "test_import_logic2test",
        "test_import_generator",
        "test_config_defaults",
        "test_generator_config_custom"
      ]
    },
    {
      "path": "lolm/__init__.py",
      "language": "python",
      "lines": 103,
      "classes": [],
      "functions": [],
      "imports": [
        "config.LLMConfig",
        "config.load_config",
        "config.save_config",
        "config.get_config_path",
        "config.get_provider_model",
        "config.get_provider_priorities_from_litellm",
        "config.DEFAULT_MODELS",
        "config.DEFAULT_PROVIDER_PRIORITIES",
        "config.RECOMMENDED_MODELS",
        "provider.BaseLLMClient"
      ],
      "exports": []
    },
    {
      "path": "lolm/__main__.py",
      "language": "python",
      "lines": 10,
      "classes": [],
      "functions": [],
      "imports": [
        "cli.main"
      ],
      "exports": []
    },
    {
      "path": "lolm/cli.py",
      "language": "python",
      "lines": 231,
      "classes": [],
      "functions": [
        {
          "name": "cmd_status",
          "signature": "(args)->int",
          "intent": "cmd status",
          "is_async": false
        },
        {
          "name": "cmd_set_provider",
          "signature": "(args)->int",
          "intent": "cmd set provider",
          "is_async": false
        },
        {
          "name": "cmd_set_model",
          "signature": "(args)->int",
          "intent": "cmd set model",
          "is_async": false
        },
        {
          "name": "cmd_key_set",
          "signature": "(args)->int",
          "intent": "cmd key set",
          "is_async": false
        },
        {
          "name": "cmd_key_show",
          "signature": "(args)->int",
          "intent": "cmd key show",
          "is_async": false
        },
        {
          "name": "cmd_models",
          "signature": "(args)->int",
          "intent": "cmd models",
          "is_async": false
        },
        {
          "name": "cmd_test",
          "signature": "(args)->int",
          "intent": "cmd test",
          "is_async": false
        },
        {
          "name": "cmd_config_show",
          "signature": "(args)->int",
          "intent": "cmd config show",
          "is_async": false
        },
        {
          "name": "cmd_priority_set_provider",
          "signature": "(args)->int",
          "intent": "cmd priority set provider",
          "is_async": false
        },
        {
          "name": "cmd_priority_set_mode",
          "signature": "(args)->int",
          "intent": "cmd priority set mode",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "argparse",
        "os",
        "sys",
        "pathlib.Path",
        "config.DEFAULT_MODELS",
        "config.DEFAULT_PROVIDER_PRIORITIES",
        "config.RECOMMENDED_MODELS",
        "config.LLMConfig",
        "config.get_api_key",
        "config.get_config_path"
      ],
      "exports": [
        "cmd_status",
        "cmd_set_provider",
        "cmd_set_model",
        "cmd_key_set",
        "cmd_key_show",
        "cmd_models",
        "cmd_test",
        "cmd_config_show",
        "cmd_priority_set_provider",
        "cmd_priority_set_mode"
      ]
    },
    {
      "path": "lolm/clients.py",
      "language": "python",
      "lines": 274,
      "classes": [
        {
          "name": "LLMRateLimitError",
          "bases": [
            "Exception"
          ],
          "docstring": "Exception raised when a rate limit is hit.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(message:str,provider:str='',status_code:int=429,headers:dict=None...+1)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "__str__",
              "signature": "()",
              "intent": "str",
              "is_async": false
            }
          ]
        },
        {
          "name": "OpenRouterClient",
          "bases": [
            "BaseLLMClient"
          ],
          "docstring": "OpenRouter API client for cloud LLM access.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(api_key:str=None,model:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "list_recommended_models",
              "signature": "()->List[tuple]",
              "intent": "list recommended models",
              "is_async": false
            }
          ]
        },
        {
          "name": "OllamaClient",
          "bases": [
            "BaseLLMClient"
          ],
          "docstring": "Ollama client for local LLM inference.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(model:str=None,host:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "list_models",
              "signature": "()->List[str]",
              "intent": "list models",
              "is_async": false
            },
            {
              "name": "list_recommended_models",
              "signature": "()->List[tuple]",
              "intent": "list recommended models",
              "is_async": false
            }
          ]
        },
        {
          "name": "LiteLLMClient",
          "bases": [
            "BaseLLMClient"
          ],
          "docstring": "LiteLLM client for universal LLM access.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(model:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            }
          ]
        },
        {
          "name": "GroqClient",
          "bases": [
            "BaseLLMClient"
          ],
          "docstring": "Groq API client for fast inference.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(api_key:str=None,model:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            }
          ]
        },
        {
          "name": "TogetherClient",
          "bases": [
            "BaseLLMClient"
          ],
          "docstring": "Together AI client.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(api_key:str=None,model:str=None)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "os",
        "time",
        "typing.List",
        "typing.Optional",
        "config.DEFAULT_MODELS",
        "config.RECOMMENDED_MODELS",
        "config.get_provider_model",
        "config.load_env_file",
        "provider.BaseLLMClient",
        "provider.LLMModelInfo"
      ],
      "exports": [
        "LLMRateLimitError",
        "OpenRouterClient",
        "OllamaClient",
        "LiteLLMClient",
        "GroqClient",
        "TogetherClient"
      ]
    },
    {
      "path": "lolm/config.py",
      "language": "python",
      "lines": 271,
      "classes": [
        {
          "name": "LLMConfig",
          "bases": [],
          "docstring": "LLM configuration container.",
          "methods": [
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            },
            {
              "name": "from_dict",
              "signature": "(data:Dict[str,Any])->'LLMConfig'",
              "intent": "from dict",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_config_dir",
          "signature": "()->Path",
          "intent": "retrieves config dir",
          "is_async": false
        },
        {
          "name": "get_config_path",
          "signature": "()->Path",
          "intent": "retrieves config path",
          "is_async": false
        },
        {
          "name": "load_config",
          "signature": "()->LLMConfig",
          "intent": "retrieves config",
          "is_async": false
        },
        {
          "name": "save_config",
          "signature": "(config:LLMConfig)->None",
          "intent": "caches config",
          "is_async": false
        },
        {
          "name": "load_env_file",
          "signature": "(search_paths:Optional[List[Path]]=None)->None",
          "intent": "retrieves env file",
          "is_async": false
        },
        {
          "name": "load_litellm_config",
          "signature": "(search_paths:Optional[List[Path]]=None)->Dict[str, Any]",
          "intent": "retrieves litellm config",
          "is_async": false
        },
        {
          "name": "save_litellm_config",
          "signature": "(config:Dict[str,Any],path:Optional[Path]=None)->None",
          "intent": "caches litellm config",
          "is_async": false
        },
        {
          "name": "get_provider_model",
          "signature": "(provider:str)->str",
          "intent": "retrieves provider model",
          "is_async": false
        },
        {
          "name": "set_provider_model",
          "signature": "(provider:str,model:str)->None",
          "intent": "updates provider model",
          "is_async": false
        },
        {
          "name": "get_api_key",
          "signature": "(provider:str)->Optional[str]",
          "intent": "retrieves api key",
          "is_async": false
        },
        {
          "name": "set_api_key",
          "signature": "(provider:str,key:str,env_path:Optional[Path]=None)->None",
          "intent": "updates api key",
          "is_async": false
        },
        {
          "name": "get_provider_priorities_from_litellm",
          "signature": "()->Dict[str, int]",
          "intent": "retrieves provider priorities from litellm",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "dataclasses.dataclass",
        "dataclasses.field",
        "pathlib.Path",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "getv.EnvStore"
      ],
      "exports": [
        "RECOMMENDED_MODELS",
        "DEFAULT_MODELS",
        "DEFAULT_PROVIDER_PRIORITIES",
        "LLMConfig",
        "get_config_dir",
        "get_config_path",
        "load_config",
        "save_config",
        "load_env_file",
        "load_litellm_config"
      ]
    },
    {
      "path": "lolm/examples/01_quickstart.py",
      "language": "python",
      "lines": 60,
      "classes": [],
      "functions": [
        {
          "name": "example_simple_client",
          "signature": "()",
          "intent": "example simple client",
          "is_async": false
        },
        {
          "name": "example_specific_provider",
          "signature": "()",
          "intent": "example specific provider",
          "is_async": false
        },
        {
          "name": "example_manager",
          "signature": "()",
          "intent": "example manager",
          "is_async": false
        },
        {
          "name": "example_fallback",
          "signature": "()",
          "intent": "example fallback",
          "is_async": false
        }
      ],
      "imports": [
        "lolm.get_client",
        "lolm.LLMManager"
      ],
      "exports": [
        "example_simple_client",
        "example_specific_provider",
        "example_manager",
        "example_fallback"
      ]
    },
    {
      "path": "lolm/examples/02_configuration.py",
      "language": "python",
      "lines": 88,
      "classes": [],
      "functions": [
        {
          "name": "show_defaults",
          "signature": "()",
          "intent": "show defaults",
          "is_async": false
        },
        {
          "name": "show_recommended_models",
          "signature": "()",
          "intent": "show recommended models",
          "is_async": false
        },
        {
          "name": "show_current_config",
          "signature": "()",
          "intent": "show current config",
          "is_async": false
        },
        {
          "name": "example_modify_config",
          "signature": "()",
          "intent": "example modify config",
          "is_async": false
        },
        {
          "name": "show_environment_config",
          "signature": "()",
          "intent": "show environment config",
          "is_async": false
        }
      ],
      "imports": [
        "os",
        "pathlib.Path",
        "lolm.LLMConfig",
        "lolm.load_config",
        "lolm.save_config",
        "lolm.get_config_path",
        "lolm.get_provider_model",
        "lolm.DEFAULT_MODELS",
        "lolm.DEFAULT_PROVIDER_PRIORITIES",
        "lolm.RECOMMENDED_MODELS"
      ],
      "exports": [
        "show_defaults",
        "show_recommended_models",
        "show_current_config",
        "example_modify_config",
        "show_environment_config"
      ]
    },
    {
      "path": "lolm/examples/03_code_generation.py",
      "language": "python",
      "lines": 86,
      "classes": [],
      "functions": [
        {
          "name": "generate_function",
          "signature": "(description:str)->str",
          "intent": "creates function",
          "is_async": false
        },
        {
          "name": "generate_class",
          "signature": "(description:str)->str",
          "intent": "creates class",
          "is_async": false
        },
        {
          "name": "explain_code",
          "signature": "(code:str)->str",
          "intent": "explain code",
          "is_async": false
        },
        {
          "name": "review_code",
          "signature": "(code:str)->str",
          "intent": "review code",
          "is_async": false
        }
      ],
      "imports": [
        "lolm.get_client",
        "lolm.LLMManager"
      ],
      "exports": [
        "SYSTEM_PROMPT",
        "generate_function",
        "generate_class",
        "explain_code",
        "review_code"
      ]
    },
    {
      "path": "lolm/manager.py",
      "language": "python",
      "lines": 412,
      "classes": [
        {
          "name": "ProviderInfo",
          "bases": [],
          "docstring": "Information about a configured provider.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(name:str,status:LLMProviderStatus,client:Optional[BaseLLMClient]=None,model:str=''...+1)",
              "intent": "creates",
              "is_async": false
            }
          ]
        },
        {
          "name": "LLMManager",
          "bases": [],
          "docstring": "LLM Manager with multi-provider support.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(verbose:bool=False,enable_rotation:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "is_ready",
              "signature": "()->bool",
              "intent": "is ready",
              "is_async": false
            },
            {
              "name": "primary_provider",
              "signature": "()->Optional[BaseLLMClient]",
              "intent": "primary provider",
              "is_async": false
            },
            {
              "name": "providers",
              "signature": "()->Dict[str, ProviderInfo]",
              "intent": "providers",
              "is_async": false
            },
            {
              "name": "initialize",
              "signature": "()->None",
              "intent": "initializes",
              "is_async": false
            },
            {
              "name": "_init_openrouter",
              "signature": "()->None",
              "intent": "creates openrouter",
              "is_async": false
            },
            {
              "name": "_init_ollama",
              "signature": "()->None",
              "intent": "creates ollama",
              "is_async": false
            },
            {
              "name": "_init_groq",
              "signature": "()->None",
              "intent": "creates groq",
              "is_async": false
            },
            {
              "name": "_init_together",
              "signature": "()->None",
              "intent": "creates together",
              "is_async": false
            },
            {
              "name": "_init_litellm",
              "signature": "()->None",
              "intent": "creates litellm",
              "is_async": false
            },
            {
              "name": "_get_effective_priority",
              "signature": "(provider:str)->int",
              "intent": "retrieves effective priority",
              "is_async": false
            },
            {
              "name": "_get_priority_order",
              "signature": "()->List[str]",
              "intent": "retrieves priority order",
              "is_async": false
            },
            {
              "name": "get_client",
              "signature": "(provider:str=None)->Optional[BaseLLMClient]",
              "intent": "retrieves client",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000,provider:str=None)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "generate_with_fallback",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000,providers:Optional[List[str]]=None)->str",
              "intent": "creates with fallback",
              "is_async": false
            },
            {
              "name": "generate_with_rotation",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000,max_retries:int=3)->str",
              "intent": "creates with rotation",
              "is_async": false
            },
            {
              "name": "get_rotation_queue",
              "signature": "()->Optional[RotationQueue]",
              "intent": "retrieves rotation queue",
              "is_async": false
            },
            {
              "name": "get_provider_health",
              "signature": "(name:str=None)->Dict",
              "intent": "retrieves provider health",
              "is_async": false
            },
            {
              "name": "reset_provider",
              "signature": "(name:str)->bool",
              "intent": "reset provider",
              "is_async": false
            },
            {
              "name": "set_provider_priority",
              "signature": "(name:str,priority:int)->bool",
              "intent": "updates provider priority",
              "is_async": false
            },
            {
              "name": "get_status",
              "signature": "()->Dict[str, Dict]",
              "intent": "retrieves status",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "get_client",
          "signature": "(provider:str=None,model:str=None)->BaseLLMClient",
          "intent": "retrieves client",
          "is_async": false
        },
        {
          "name": "list_available_providers",
          "signature": "()->List[str]",
          "intent": "list available providers",
          "is_async": false
        }
      ],
      "imports": [
        "os",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "config.DEFAULT_MODELS",
        "config.DEFAULT_PROVIDER_PRIORITIES",
        "config.LLMConfig",
        "config.get_provider_model",
        "config.get_provider_priorities_from_litellm",
        "config.load_config"
      ],
      "exports": [
        "ProviderInfo",
        "LLMManager",
        "get_client",
        "list_available_providers"
      ]
    },
    {
      "path": "lolm/provider.py",
      "language": "python",
      "lines": 121,
      "classes": [
        {
          "name": "LLMProviderStatus",
          "bases": [
            "str",
            "Enum"
          ],
          "docstring": "Provider availability status."
        },
        {
          "name": "GenerateOptions",
          "bases": [],
          "docstring": "Options for LLM generation.",
          "methods": [
            {
              "name": "to_messages",
              "signature": "()->List[Dict[str, str]]",
              "intent": "converts messages",
              "is_async": false
            }
          ]
        },
        {
          "name": "LLMResponse",
          "bases": [],
          "docstring": "Response from LLM generation."
        },
        {
          "name": "LLMModelInfo",
          "bases": [],
          "docstring": "Information about an available model."
        },
        {
          "name": "BaseLLMClient",
          "bases": [
            "ABC"
          ],
          "docstring": "Abstract base class for synchronous LLM clients.",
          "properties": [
            "provider: str"
          ],
          "methods": [
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "chat",
              "signature": "(messages:List[Dict[str,str]],max_tokens:int=4000)->str",
              "intent": "chat",
              "is_async": false
            }
          ]
        },
        {
          "name": "LLMProvider",
          "bases": [
            "ABC"
          ],
          "docstring": "Abstract base class for async LLM providers.",
          "methods": [
            {
              "name": "name",
              "signature": "()->str",
              "intent": "name",
              "is_async": false
            },
            {
              "name": "model",
              "signature": "()->str",
              "intent": "model",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": true
            },
            {
              "name": "list_models",
              "signature": "()->List[LLMModelInfo]",
              "intent": "list models",
              "is_async": true
            },
            {
              "name": "generate",
              "signature": "(options:GenerateOptions)->LLMResponse",
              "intent": "creates",
              "is_async": true
            },
            {
              "name": "has_model",
              "signature": "(model_name:str)->bool",
              "intent": "has model",
              "is_async": true
            },
            {
              "name": "get_code_models",
              "signature": "(models:List[LLMModelInfo])->List[LLMModelInfo]",
              "intent": "retrieves code models",
              "is_async": false
            },
            {
              "name": "close",
              "signature": "()->None",
              "intent": "stops",
              "is_async": true
            },
            {
              "name": "__aenter__",
              "signature": "()",
              "intent": "aenter",
              "is_async": true
            },
            {
              "name": "__aexit__",
              "signature": "()",
              "intent": "aexit",
              "is_async": true
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum",
        "typing.Any",
        "typing.Dict",
        "typing.List",
        "typing.Literal",
        "typing.Optional"
      ],
      "exports": [
        "LLMProviderStatus",
        "GenerateOptions",
        "LLMResponse",
        "LLMModelInfo",
        "BaseLLMClient",
        "LLMProvider"
      ]
    },
    {
      "path": "lolm/rotation.py",
      "language": "python",
      "lines": 560,
      "classes": [
        {
          "name": "ProviderState",
          "bases": [
            "str",
            "Enum"
          ],
          "docstring": "Provider availability state."
        },
        {
          "name": "RateLimitType",
          "bases": [
            "str",
            "Enum"
          ],
          "docstring": "Type of rate limit encountered."
        },
        {
          "name": "RateLimitInfo",
          "bases": [],
          "docstring": "Information about a rate limit event.",
          "methods": [
            {
              "name": "get_wait_seconds",
              "signature": "()->float",
              "intent": "retrieves wait seconds",
              "is_async": false
            }
          ]
        },
        {
          "name": "ProviderHealth",
          "bases": [],
          "docstring": "Health metrics for a provider.",
          "methods": [
            {
              "name": "success_rate",
              "signature": "()->float",
              "intent": "success rate",
              "is_async": false
            },
            {
              "name": "is_available",
              "signature": "()->bool",
              "intent": "is available",
              "is_async": false
            },
            {
              "name": "record_success",
              "signature": "(latency_ms:float=0)->None",
              "intent": "record success",
              "is_async": false
            },
            {
              "name": "record_failure",
              "signature": "(error:str,is_rate_limit:bool=False,rate_limit_info:Optional[RateLimitInfo]=None)->None",
              "intent": "record failure",
              "is_async": false
            },
            {
              "name": "_adjust_priority",
              "signature": "()->None",
              "intent": "adjust priority",
              "is_async": false
            },
            {
              "name": "check_cooldown",
              "signature": "()->bool",
              "intent": "checks cooldown",
              "is_async": false
            },
            {
              "name": "to_dict",
              "signature": "()->Dict[str, Any]",
              "intent": "converts dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "RotationQueue",
          "bases": [],
          "docstring": "Priority queue for LLM provider rotation with automatic failover.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(max_consecutive_failures:int=3,default_cooldown_seconds:float=60,enable_health_recovery:bool=True)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "add_provider",
              "signature": "(name:str,priority:int=100)->None",
              "intent": "creates provider",
              "is_async": false
            },
            {
              "name": "remove_provider",
              "signature": "(name:str)->bool",
              "intent": "deletes provider",
              "is_async": false
            },
            {
              "name": "set_priority",
              "signature": "(name:str,priority:int)->bool",
              "intent": "updates priority",
              "is_async": false
            },
            {
              "name": "get_priority_order",
              "signature": "()->List[str]",
              "intent": "retrieves priority order",
              "is_async": false
            },
            {
              "name": "get_next",
              "signature": "()->Optional[str]",
              "intent": "retrieves next",
              "is_async": false
            },
            {
              "name": "get_available",
              "signature": "()->List[str]",
              "intent": "retrieves available",
              "is_async": false
            },
            {
              "name": "record_success",
              "signature": "(name:str,latency_ms:float=0)->None",
              "intent": "record success",
              "is_async": false
            },
            {
              "name": "record_failure",
              "signature": "(name:str,error:str,is_rate_limit:bool=False,rate_limit_info:Optional[RateLimitInfo]=None)->None",
              "intent": "record failure",
              "is_async": false
            },
            {
              "name": "mark_rate_limited",
              "signature": "(name:str,rate_limit_info:Optional[RateLimitInfo]=None,cooldown_seconds:Optional[float]=None)->None",
              "intent": "mark rate limited",
              "is_async": false
            },
            {
              "name": "reset_provider",
              "signature": "(name:str)->bool",
              "intent": "reset provider",
              "is_async": false
            },
            {
              "name": "reset_all",
              "signature": "()->None",
              "intent": "reset all",
              "is_async": false
            },
            {
              "name": "get_health",
              "signature": "(name:str)->Optional[ProviderHealth]",
              "intent": "retrieves health",
              "is_async": false
            },
            {
              "name": "get_all_health",
              "signature": "()->Dict[str, Dict[str, Any]]",
              "intent": "retrieves all health",
              "is_async": false
            },
            {
              "name": "get_status",
              "signature": "()->Dict[str, Any]",
              "intent": "retrieves status",
              "is_async": false
            },
            {
              "name": "on_provider_unavailable",
              "signature": "(callback:Callable[Any,None])->None",
              "intent": "handles provider unavailable",
              "is_async": false
            },
            {
              "name": "on_rate_limit",
              "signature": "(callback:Callable[Any,None])->None",
              "intent": "handles rate limit",
              "is_async": false
            },
            {
              "name": "on_rotation",
              "signature": "(callback:Callable[Any,None])->None",
              "intent": "handles rotation",
              "is_async": false
            }
          ]
        },
        {
          "name": "LLMRotationManager",
          "bases": [],
          "docstring": "High-level manager for LLM rotation with generation capabilities.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(max_retries:int=3,default_cooldown:float=60.0,verbose:bool=False)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "register",
              "signature": "(name:str,client:Any,priority:int=100)->None",
              "intent": "registers",
              "is_async": false
            },
            {
              "name": "unregister",
              "signature": "(name:str)->bool",
              "intent": "unregister",
              "is_async": false
            },
            {
              "name": "set_priority",
              "signature": "(name:str,priority:int)->bool",
              "intent": "updates priority",
              "is_async": false
            },
            {
              "name": "generate",
              "signature": "(prompt:str,system:str=None,max_tokens:int=4000,preferred_provider:str=None)->str",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "get_queue",
              "signature": "()->RotationQueue",
              "intent": "retrieves queue",
              "is_async": false
            },
            {
              "name": "get_status",
              "signature": "()->Dict[str, Any]",
              "intent": "retrieves status",
              "is_async": false
            },
            {
              "name": "reset",
              "signature": "()->None",
              "intent": "reset",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "parse_rate_limit_headers",
          "signature": "(headers:Dict[str,str])->Optional[RateLimitInfo]",
          "intent": "parses rate limit headers",
          "is_async": false
        },
        {
          "name": "is_rate_limit_error",
          "signature": "(status_code:int=None,error_message:str=None)->bool",
          "intent": "is rate limit error",
          "is_async": false
        },
        {
          "name": "create_rotation_manager",
          "signature": "(providers:Dict[str,Tuple[Any,int]]=None,verbose:bool=False)->LLMRotationManager",
          "intent": "creates rotation manager",
          "is_async": false
        }
      ],
      "imports": [
        "time",
        "threading",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime",
        "datetime.timedelta",
        "enum.Enum",
        "typing.Any",
        "typing.Callable",
        "typing.Dict"
      ],
      "exports": [
        "ProviderState",
        "RateLimitType",
        "RateLimitInfo",
        "ProviderHealth",
        "RotationQueue",
        "parse_rate_limit_headers",
        "is_rate_limit_error",
        "LLMRotationManager",
        "create_rotation_manager"
      ]
    },
    {
      "path": "lolm/tests/__init__.py",
      "language": "python",
      "lines": 1,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "lolm/tests/test_basic.py",
      "language": "python",
      "lines": 51,
      "classes": [],
      "functions": [
        {
          "name": "test_import_lolm",
          "signature": "()",
          "intent": "checks import lolm",
          "is_async": false
        },
        {
          "name": "test_import_config",
          "signature": "()",
          "intent": "checks import config",
          "is_async": false
        },
        {
          "name": "test_import_clients",
          "signature": "()",
          "intent": "checks import clients",
          "is_async": false
        },
        {
          "name": "test_config_defaults",
          "signature": "()",
          "intent": "checks config defaults",
          "is_async": false
        },
        {
          "name": "test_manager_init",
          "signature": "()",
          "intent": "checks manager init",
          "is_async": false
        },
        {
          "name": "test_recommended_models",
          "signature": "()",
          "intent": "checks recommended models",
          "is_async": false
        }
      ],
      "imports": [
        "pytest"
      ],
      "exports": [
        "test_import_lolm",
        "test_import_config",
        "test_import_clients",
        "test_config_defaults",
        "test_manager_init",
        "test_recommended_models"
      ]
    },
    {
      "path": "raport/mermaid-init.js",
      "language": "javascript",
      "lines": 29,
      "classes": [],
      "functions": [
        {
          "name": "convertMermaidCodeBlocks",
          "signature": "()",
          "intent": "converts mermaid code blocks",
          "is_async": false
        },
        {
          "name": "renderMermaid",
          "signature": "()",
          "intent": "formats mermaid",
          "is_async": true
        }
      ],
      "imports": [
        "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs"
      ],
      "exports": [
        "convertMermaidCodeBlocks",
        "renderMermaid"
      ]
    },
    {
      "path": "scripts/configure_llm.py",
      "language": "python",
      "lines": 360,
      "classes": [],
      "functions": [
        {
          "name": "log",
          "signature": "(msg:str,level:str='info')",
          "intent": "logs",
          "is_async": false
        },
        {
          "name": "check_ollama",
          "signature": "()->Dict[str, Any]",
          "intent": "checks ollama",
          "is_async": false
        },
        {
          "name": "check_litellm",
          "signature": "()->Dict[str, Any]",
          "intent": "checks litellm",
          "is_async": false
        },
        {
          "name": "check_env_keys",
          "signature": "()->Dict[str, bool]",
          "intent": "checks env keys",
          "is_async": false
        },
        {
          "name": "categorize_models",
          "signature": "(models:List[Dict])->Dict[str, List[Dict]]",
          "intent": "categorize models",
          "is_async": false
        },
        {
          "name": "get_recommended_models",
          "signature": "(models:List[Dict])->Dict[str, str]",
          "intent": "retrieves recommended models",
          "is_async": false
        },
        {
          "name": "test_model",
          "signature": "(model:str,timeout:int=30)->Dict[str, Any]",
          "intent": "checks model",
          "is_async": false
        },
        {
          "name": "save_config",
          "signature": "(config:Dict[str,Any])",
          "intent": "caches config",
          "is_async": false
        },
        {
          "name": "load_config",
          "signature": "()->Dict[str, Any]",
          "intent": "retrieves config",
          "is_async": false
        },
        {
          "name": "format_size",
          "signature": "(size_bytes:int)->str",
          "intent": "formats size",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        }
      ],
      "imports": [
        "sys",
        "os",
        "json",
        "time",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "datetime"
      ],
      "exports": [
        "CONFIG_DIR",
        "CONFIG_FILE",
        "log",
        "check_ollama",
        "check_litellm",
        "check_env_keys",
        "categorize_models",
        "get_recommended_models",
        "test_model",
        "save_config"
      ]
    },
    {
      "path": "tests/__init__.py",
      "language": "python",
      "lines": 3,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": []
    },
    {
      "path": "tests/conftest.py",
      "language": "python",
      "lines": 314,
      "classes": [],
      "functions": [
        {
          "name": "sample_python_code",
          "signature": "()->str",
          "intent": "sample python code",
          "is_async": false
        },
        {
          "name": "sample_javascript_code",
          "signature": "()->str",
          "intent": "sample javascript code",
          "is_async": false
        },
        {
          "name": "sample_java_code",
          "signature": "()->str",
          "intent": "sample java code",
          "is_async": false
        },
        {
          "name": "temp_project_dir",
          "signature": "()",
          "intent": "temp project dir",
          "is_async": false
        },
        {
          "name": "sample_project",
          "signature": "(temp_project_dir,sample_python_code)",
          "intent": "sample project",
          "is_async": false
        },
        {
          "name": "sample_module",
          "signature": "()",
          "intent": "sample module",
          "is_async": false
        },
        {
          "name": "sample_project_model",
          "signature": "()",
          "intent": "sample project model",
          "is_async": false
        },
        {
          "name": "mock_llm_config",
          "signature": "()",
          "intent": "mock llm config",
          "is_async": false
        },
        {
          "name": "sample_analysis_result",
          "signature": "()",
          "intent": "sample analysis result",
          "is_async": false
        }
      ],
      "imports": [
        "pytest",
        "tempfile",
        "pathlib.Path",
        "typing.Dict",
        "typing.Any",
        "code2logic.models.ProjectInfo",
        "code2logic.models.ModuleInfo",
        "code2logic.models.FunctionInfo",
        "code2logic.models.ClassInfo"
      ],
      "exports": [
        "sample_python_code",
        "sample_javascript_code",
        "sample_java_code",
        "temp_project_dir",
        "sample_project",
        "sample_module",
        "sample_project_model",
        "mock_llm_config",
        "sample_analysis_result"
      ]
    },
    {
      "path": "tests/samples/sample_algorithms.py",
      "language": "python",
      "lines": 184,
      "classes": [],
      "functions": [
        {
          "name": "binary_search",
          "signature": "(arr:List[int],target:int)->int",
          "intent": "binary search",
          "is_async": false
        },
        {
          "name": "quicksort",
          "signature": "(arr:List[int])->List[int]",
          "intent": "quicksort",
          "is_async": false
        },
        {
          "name": "merge_sort",
          "signature": "(arr:List[int])->List[int]",
          "intent": "merges sort",
          "is_async": false
        },
        {
          "name": "_merge",
          "signature": "(left:List[int],right:List[int])->List[int]",
          "intent": "merges",
          "is_async": false
        },
        {
          "name": "fibonacci",
          "signature": "(n:int)->int",
          "intent": "fibonacci",
          "is_async": false
        },
        {
          "name": "fibonacci_generator",
          "signature": "(limit:int)->Generator[int, None, None]",
          "intent": "fibonacci generator",
          "is_async": false
        },
        {
          "name": "is_prime",
          "signature": "(n:int)->bool",
          "intent": "is prime",
          "is_async": false
        },
        {
          "name": "sieve_of_eratosthenes",
          "signature": "(limit:int)->List[int]",
          "intent": "sieve of eratosthenes",
          "is_async": false
        },
        {
          "name": "gcd",
          "signature": "(a:int,b:int)->int",
          "intent": "gcd",
          "is_async": false
        },
        {
          "name": "lcm",
          "signature": "(a:int,b:int)->int",
          "intent": "lcm",
          "is_async": false
        },
        {
          "name": "levenshtein_distance",
          "signature": "(s1:str,s2:str)->int",
          "intent": "levenshtein distance",
          "is_async": false
        },
        {
          "name": "knapsack_01",
          "signature": "(weights:List[int],values:List[int],capacity:int)->int",
          "intent": "knapsack 01",
          "is_async": false
        }
      ],
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "typing.Generator",
        "typing.TypeVar",
        "functools.lru_cache"
      ],
      "exports": [
        "T",
        "binary_search",
        "quicksort",
        "merge_sort",
        "fibonacci",
        "fibonacci_generator",
        "is_prime",
        "sieve_of_eratosthenes",
        "gcd",
        "lcm"
      ]
    },
    {
      "path": "tests/samples/sample_api.py",
      "language": "python",
      "lines": 106,
      "classes": [
        {
          "name": "APIResponse",
          "bases": [],
          "docstring": "Standard API response structure."
        },
        {
          "name": "User",
          "bases": [],
          "docstring": "User model for API."
        },
        {
          "name": "APIError",
          "bases": [
            "Exception"
          ],
          "docstring": "Custom API error.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(message:str,code:int=400)",
              "intent": "creates",
              "is_async": false
            }
          ]
        },
        {
          "name": "UserAPI",
          "bases": [],
          "docstring": "User management API.",
          "methods": [
            {
              "name": "__init__",
              "signature": "()",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "create_user",
              "signature": "(username:str,email:str,roles:List[str]=None)->APIResponse",
              "intent": "creates user",
              "is_async": false
            },
            {
              "name": "get_user",
              "signature": "(user_id:int)->APIResponse",
              "intent": "retrieves user",
              "is_async": false
            },
            {
              "name": "update_user",
              "signature": "(user_id:int)->APIResponse",
              "intent": "updates user",
              "is_async": false
            },
            {
              "name": "delete_user",
              "signature": "(user_id:int)->APIResponse",
              "intent": "deletes user",
              "is_async": false
            },
            {
              "name": "list_users",
              "signature": "(limit:int=10,offset:int=0)->APIResponse",
              "intent": "list users",
              "is_async": false
            },
            {
              "name": "search_users",
              "signature": "(query:str)->APIResponse",
              "intent": "filters users",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "fetch_user_async",
          "signature": "(api:UserAPI,user_id:int)->APIResponse",
          "intent": "retrieves user async",
          "is_async": true
        },
        {
          "name": "create_user_async",
          "signature": "(api:UserAPI,username:str,email:str)->APIResponse",
          "intent": "creates user async",
          "is_async": true
        },
        {
          "name": "handle_api_error",
          "signature": "(func)",
          "intent": "handles api error",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "typing.Any",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime",
        "json"
      ],
      "exports": [
        "APIResponse",
        "User",
        "APIError",
        "UserAPI",
        "fetch_user_async",
        "create_user_async",
        "handle_api_error"
      ]
    },
    {
      "path": "tests/samples/sample_async.py",
      "language": "python",
      "lines": 163,
      "classes": [
        {
          "name": "Task",
          "bases": [],
          "docstring": "Async task with status tracking."
        },
        {
          "name": "TaskResult",
          "bases": [],
          "docstring": "Result of task execution."
        },
        {
          "name": "AsyncTaskQueue",
          "bases": [],
          "docstring": "Async task queue with concurrency control.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(max_concurrent:int=5)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "add_task",
              "signature": "(task:Task)->None",
              "intent": "creates task",
              "is_async": true
            },
            {
              "name": "get_task",
              "signature": "(task_id:str)->Optional[Task]",
              "intent": "retrieves task",
              "is_async": true
            },
            {
              "name": "process_task",
              "signature": "(task_id:str,handler)->TaskResult",
              "intent": "processes task",
              "is_async": true
            },
            {
              "name": "process_all",
              "signature": "(handler)->List[TaskResult]",
              "intent": "processes all",
              "is_async": true
            }
          ]
        },
        {
          "name": "AsyncCache",
          "bases": [],
          "docstring": "Simple async cache with TTL.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(ttl_seconds:int=300)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "get",
              "signature": "(key:str)->Optional[Any]",
              "intent": "retrieves",
              "is_async": true
            },
            {
              "name": "set",
              "signature": "(key:str,value:Any)->None",
              "intent": "updates",
              "is_async": true
            },
            {
              "name": "delete",
              "signature": "(key:str)->bool",
              "intent": "deletes",
              "is_async": true
            },
            {
              "name": "clear",
              "signature": "()->None",
              "intent": "deletes",
              "is_async": true
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "async_timer",
          "signature": "(name:str='operation')",
          "intent": "async timer",
          "is_async": true
        },
        {
          "name": "fetch_with_retry",
          "signature": "(url:str,max_retries:int=3,delay:float=1.0)->Dict[str, Any]",
          "intent": "retrieves with retry",
          "is_async": true
        },
        {
          "name": "parallel_map",
          "signature": "(items:List[T],handler,max_concurrent:int=5)->List[Any]",
          "intent": "parallel map",
          "is_async": true
        },
        {
          "name": "race",
          "signature": "()->Any",
          "intent": "race",
          "is_async": true
        },
        {
          "name": "timeout_wrapper",
          "signature": "(coro,timeout_seconds:float,default=None)",
          "intent": "timeout wrapper",
          "is_async": true
        }
      ],
      "imports": [
        "asyncio",
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "typing.Any",
        "typing.TypeVar",
        "dataclasses.dataclass",
        "dataclasses.field",
        "datetime",
        "contextlib.asynccontextmanager"
      ],
      "exports": [
        "T",
        "Task",
        "TaskResult",
        "AsyncTaskQueue",
        "AsyncCache",
        "async_timer",
        "fetch_with_retry",
        "parallel_map",
        "race",
        "timeout_wrapper"
      ]
    },
    {
      "path": "tests/samples/sample_class.py",
      "language": "python",
      "lines": 74,
      "classes": [
        {
          "name": "Calculator",
          "bases": [],
          "docstring": "Simple calculator with history.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(precision:int=2)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "add",
              "signature": "(a:float,b:float)->float",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "subtract",
              "signature": "(a:float,b:float)->float",
              "intent": "subtract",
              "is_async": false
            },
            {
              "name": "multiply",
              "signature": "(a:float,b:float)->float",
              "intent": "multiply",
              "is_async": false
            },
            {
              "name": "divide",
              "signature": "(a:float,b:float)->Optional[float]",
              "intent": "splits",
              "is_async": false
            },
            {
              "name": "clear_history",
              "signature": "()->None",
              "intent": "deletes history",
              "is_async": false
            },
            {
              "name": "get_history",
              "signature": "()->List[str]",
              "intent": "retrieves history",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "typing.Any"
      ],
      "exports": [
        "Calculator"
      ]
    },
    {
      "path": "tests/samples/sample_csharp.cs",
      "language": "csharp",
      "lines": 28,
      "classes": [
        {
          "name": "IHasId",
          "bases": [],
          "docstring": null
        },
        {
          "name": "User",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "FilterActive",
          "signature": "(IEnumerable<User> users)->List<User>",
          "intent": "filters active",
          "is_async": false
        },
        {
          "name": "FindById",
          "signature": "(IEnumerable<User> users,string id)->User",
          "intent": "retrieves by id",
          "is_async": false
        }
      ],
      "imports": [
        "System",
        "System.Collections.Generic",
        "System.Linq"
      ],
      "exports": [
        "IHasId",
        "User"
      ]
    },
    {
      "path": "tests/samples/sample_dataclasses.py",
      "language": "python",
      "lines": 68,
      "classes": [
        {
          "name": "User",
          "bases": [],
          "docstring": "Represents a user in the system."
        },
        {
          "name": "Product",
          "bases": [],
          "docstring": "Represents a product in the catalog."
        },
        {
          "name": "Order",
          "bases": [],
          "docstring": "Represents a customer order."
        },
        {
          "name": "Address",
          "bases": [],
          "docstring": "Represents a shipping address."
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass",
        "dataclasses.field",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "datetime"
      ],
      "exports": [
        "User",
        "Product",
        "Order",
        "Address"
      ]
    },
    {
      "path": "tests/samples/sample_enum.py",
      "language": "python",
      "lines": 78,
      "classes": [
        {
          "name": "Status",
          "bases": [
            "Enum"
          ],
          "docstring": "Status enumeration with auto values."
        },
        {
          "name": "Priority",
          "bases": [
            "IntEnum"
          ],
          "docstring": "Priority levels as integers."
        },
        {
          "name": "Color",
          "bases": [
            "Enum"
          ],
          "docstring": "Color enumeration with string values.",
          "methods": [
            {
              "name": "from_hex",
              "signature": "(hex_code:str)->\"Color\"",
              "intent": "from hex",
              "is_async": false
            }
          ]
        },
        {
          "name": "HttpStatus",
          "bases": [
            "IntEnum"
          ],
          "docstring": "HTTP status codes.",
          "methods": [
            {
              "name": "is_success",
              "signature": "()->bool",
              "intent": "is success",
              "is_async": false
            },
            {
              "name": "is_error",
              "signature": "()->bool",
              "intent": "is error",
              "is_async": false
            }
          ]
        },
        {
          "name": "TaskType",
          "bases": [
            "Enum"
          ],
          "docstring": "Task type enumeration.",
          "methods": [
            {
              "name": "get_timeout",
              "signature": "()->int",
              "intent": "retrieves timeout",
              "is_async": false
            },
            {
              "name": "get_allowed_statuses",
              "signature": "()->List[Status]",
              "intent": "retrieves allowed statuses",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "enum.Enum",
        "enum.IntEnum",
        "enum.auto",
        "typing.List"
      ],
      "exports": [
        "Status",
        "Priority",
        "Color",
        "HttpStatus",
        "TaskType"
      ]
    },
    {
      "path": "tests/samples/sample_functions.py",
      "language": "python",
      "lines": 89,
      "classes": [],
      "functions": [
        {
          "name": "calculate_total",
          "signature": "(items:List[int],tax_rate:float=0.1)->float",
          "intent": "processes total",
          "is_async": false
        },
        {
          "name": "filter_by_status",
          "signature": "(records:List[Dict],status:str)->List[Dict]",
          "intent": "filters by status",
          "is_async": false
        },
        {
          "name": "merge_configs",
          "signature": "(base:Dict[str,Any],override:Dict[str,Any])->Dict[str, Any]",
          "intent": "merges configs",
          "is_async": false
        },
        {
          "name": "validate_email",
          "signature": "(email:str)->bool",
          "intent": "validates email",
          "is_async": false
        },
        {
          "name": "load_json_file",
          "signature": "(path:str)->Optional[Dict]",
          "intent": "retrieves json file",
          "is_async": false
        },
        {
          "name": "get_env_or_default",
          "signature": "(key:str,default:str='')->str",
          "intent": "retrieves env or default",
          "is_async": false
        },
        {
          "name": "chunk_list",
          "signature": "(items:List[Any],chunk_size:int)->List[List[Any]]",
          "intent": "chunk list",
          "is_async": false
        },
        {
          "name": "format_currency",
          "signature": "(amount:int,currency:str='USD')->str",
          "intent": "formats currency",
          "is_async": false
        }
      ],
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Optional",
        "typing.Any",
        "json",
        "os"
      ],
      "exports": [
        "calculate_total",
        "filter_by_status",
        "merge_configs",
        "validate_email",
        "load_json_file",
        "get_env_or_default",
        "chunk_list",
        "format_currency"
      ]
    },
    {
      "path": "tests/samples/sample_go.go",
      "language": "go",
      "lines": 90,
      "classes": [
        {
          "name": "User",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Product",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Order",
          "bases": [],
          "docstring": null
        },
        {
          "name": "OrderItem",
          "bases": [],
          "docstring": null
        },
        {
          "name": "UserService",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Repository",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "NewUserService",
          "signature": "()",
          "intent": "creates user service",
          "is_async": false
        },
        {
          "name": "GetUser",
          "signature": "(id int)->(*User, error)",
          "intent": "retrieves user",
          "is_async": false
        },
        {
          "name": "CreateUser",
          "signature": "(name,email string)->(*User, error)",
          "intent": "creates user",
          "is_async": false
        },
        {
          "name": "CalculateTotal",
          "signature": "(items []OrderItem,taxRate float64)->int64",
          "intent": "processes total",
          "is_async": false
        },
        {
          "name": "FilterProducts",
          "signature": "(products []Product,predicate func(Product)->bool",
          "intent": "filters products",
          "is_async": false
        },
        {
          "name": "FormatPrice",
          "signature": "(cents int64,currency string)->string",
          "intent": "formats price",
          "is_async": false
        }
      ],
      "imports": [
        "errors"
      ],
      "exports": [
        "User",
        "Product",
        "Order",
        "OrderItem",
        "UserService",
        "Repository",
        "NewUserService",
        "GetUser",
        "CreateUser",
        "CalculateTotal"
      ]
    },
    {
      "path": "tests/samples/sample_java.java",
      "language": "java",
      "lines": 43,
      "classes": [
        {
          "name": "SampleJava",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Identifiable",
          "bases": [],
          "docstring": null
        },
        {
          "name": "User",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "getId",
          "signature": "()->String",
          "intent": "retrieves id",
          "is_async": false
        },
        {
          "name": "filterActive",
          "signature": "(List<User> users)->List<User>",
          "intent": "filters active",
          "is_async": false
        },
        {
          "name": "sortByName",
          "signature": "(List<User> users)->List<User>",
          "intent": "sorts by name",
          "is_async": false
        }
      ],
      "imports": [
        "java.util.ArrayList",
        "java.util.Collections",
        "java.util.Comparator",
        "java.util.List",
        "java.util.Objects"
      ],
      "exports": [
        "SampleJava",
        "Identifiable",
        "Status",
        "User"
      ]
    },
    {
      "path": "tests/samples/sample_javascript.js",
      "language": "javascript",
      "lines": 154,
      "classes": [
        {
          "name": "User",
          "bases": [],
          "docstring": null,
          "methods": [
            {
              "name": "constructor",
              "signature": "(id,name,email)",
              "intent": "constructor",
              "is_async": false
            },
            {
              "name": "getDisplayName",
              "signature": "()",
              "intent": "retrieves display name",
              "is_async": false
            },
            {
              "name": "deactivate",
              "signature": "()",
              "intent": "deactivate",
              "is_async": false
            }
          ]
        },
        {
          "name": "Product",
          "bases": [],
          "docstring": null,
          "methods": [
            {
              "name": "constructor",
              "signature": "(sku,name,price)",
              "intent": "constructor",
              "is_async": false
            },
            {
              "name": "addTags",
              "signature": "()",
              "intent": "creates tags",
              "is_async": false
            },
            {
              "name": "isInStock",
              "signature": "()",
              "intent": "is in stock",
              "is_async": false
            },
            {
              "name": "formatPrice",
              "signature": "()",
              "intent": "formats price",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "calculateTotal",
          "signature": "(items)",
          "intent": "processes total",
          "is_async": false
        },
        {
          "name": "filterBy",
          "signature": "(arr,predicate)",
          "intent": "filters by",
          "is_async": false
        },
        {
          "name": "fetchData",
          "signature": "(url)",
          "intent": "retrieves data",
          "is_async": true
        },
        {
          "name": "debounce",
          "signature": "(func,wait)",
          "intent": "debounce",
          "is_async": false
        },
        {
          "name": "deepClone",
          "signature": "(obj)",
          "intent": "deep clone",
          "is_async": false
        }
      ],
      "imports": [],
      "exports": [
        "deepClone",
        "User",
        "fetchData",
        "calculateTotal",
        "debounce",
        "Product",
        "filterBy"
      ]
    },
    {
      "path": "tests/samples/sample_javascript_advanced.js",
      "language": "javascript",
      "lines": 111,
      "classes": [
        {
          "name": "FileProcessor",
          "bases": [
            "EventEmitter"
          ],
          "docstring": null,
          "methods": [
            {
              "name": "constructor",
              "signature": "(rootDir)",
              "intent": "constructor",
              "is_async": false
            },
            {
              "name": "analyze",
              "signature": "(filePath)",
              "intent": "processes",
              "is_async": true
            },
            {
              "name": "fromConfig",
              "signature": "(configPath)",
              "intent": "from config",
              "is_async": false
            },
            {
              "name": "getResults",
              "signature": "()",
              "intent": "retrieves results",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "getArg",
          "signature": "(name,def)",
          "intent": "retrieves arg",
          "is_async": false
        },
        {
          "name": "processItem",
          "signature": "(item)",
          "intent": "processes item",
          "is_async": false
        },
        {
          "name": "validate",
          "signature": "(input)",
          "intent": "validates",
          "is_async": false
        },
        {
          "name": "fetchResource",
          "signature": "(url,options)",
          "intent": "retrieves resource",
          "is_async": true
        },
        {
          "name": "shouldIgnore",
          "signature": "(filePath)",
          "intent": "checks ignore",
          "is_async": false
        },
        {
          "name": "formatOutput",
          "signature": "(data,indent)",
          "intent": "formats output",
          "is_async": false
        },
        {
          "name": "walk",
          "signature": "(dir,onFile)",
          "intent": "walk",
          "is_async": false
        },
        {
          "name": "findFiles",
          "signature": "(dir,extensions)",
          "intent": "retrieves files",
          "is_async": false
        },
        {
          "name": "processFiles",
          "signature": "(pattern)",
          "intent": "processes files",
          "is_async": true
        },
        {
          "name": "outerFunction",
          "signature": "(data)",
          "intent": "outer function",
          "is_async": false
        },
        {
          "name": "main",
          "signature": "()",
          "intent": "main",
          "is_async": false
        },
        {
          "name": "traverse",
          "signature": "(currentDir)",
          "intent": "traverse",
          "is_async": false
        },
        {
          "name": "middleHelper",
          "signature": "(items)",
          "intent": "middle helper",
          "is_async": false
        },
        {
          "name": "innerSort",
          "signature": "(a,b)",
          "intent": "inner sort",
          "is_async": false
        }
      ],
      "imports": [
        "fs",
        "path",
        "events"
      ],
      "exports": [
        "outerFunction",
        "processFiles",
        "walk",
        "getArg",
        "fetchResource",
        "shouldIgnore",
        "validate",
        "formatOutput",
        "findFiles",
        "FileProcessor"
      ]
    },
    {
      "path": "tests/samples/sample_pydantic.py",
      "language": "python",
      "lines": 62,
      "classes": [
        {
          "name": "TaskStatus",
          "bases": [
            "str",
            "Enum"
          ],
          "docstring": "Task status enumeration."
        },
        {
          "name": "Task",
          "bases": [
            "BaseModel"
          ],
          "docstring": "Task model with Pydantic features.",
          "properties": [
            "id: str",
            "name: str",
            "description: Optional[str]",
            "status: TaskStatus",
            "priority: int",
            "created_at: Optional[datetime]",
            "tags: List[str]"
          ],
          "methods": [
            {
              "name": "name_not_empty",
              "signature": "(v:str)->str",
              "intent": "name not empty",
              "is_async": false
            }
          ]
        },
        {
          "name": "TaskQueue",
          "bases": [
            "BaseModel"
          ],
          "docstring": "Task queue container.",
          "properties": [
            "name: str",
            "tasks: List[Task]",
            "max_size: int"
          ],
          "methods": [
            {
              "name": "add_task",
              "signature": "(task:Task)->bool",
              "intent": "creates task",
              "is_async": false
            },
            {
              "name": "get_pending",
              "signature": "()->List[Task]",
              "intent": "retrieves pending",
              "is_async": false
            },
            {
              "name": "get_by_status",
              "signature": "(status:TaskStatus)->List[Task]",
              "intent": "retrieves by status",
              "is_async": false
            }
          ]
        },
        {
          "name": "Project",
          "bases": [
            "BaseModel"
          ],
          "docstring": "Project model with nested models.",
          "properties": [
            "id: str",
            "name: str",
            "owner: str",
            "queues: List[TaskQueue]",
            "metadata: dict"
          ],
          "methods": [
            {
              "name": "total_tasks",
              "signature": "()->int",
              "intent": "total tasks",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "pydantic.BaseModel",
        "pydantic.Field",
        "pydantic.field_validator",
        "typing.List",
        "typing.Optional",
        "datetime",
        "enum.Enum"
      ],
      "exports": [
        "TaskStatus",
        "Task",
        "TaskQueue",
        "Project"
      ]
    },
    {
      "path": "tests/samples/sample_reexport/__init__.py",
      "language": "python",
      "lines": 17,
      "classes": [],
      "functions": [],
      "imports": [
        "models.User",
        "models.Order",
        "models.Product",
        "utils.process_data",
        "utils.validate_input",
        "exceptions.ValidationError",
        "exceptions.ProcessingError"
      ],
      "exports": []
    },
    {
      "path": "tests/samples/sample_reexport/exceptions.py",
      "language": "python",
      "lines": 7,
      "classes": [
        {
          "name": "ValidationError",
          "bases": [
            "Exception"
          ],
          "docstring": "Validation error."
        },
        {
          "name": "ProcessingError",
          "bases": [
            "Exception"
          ],
          "docstring": "Processing error."
        }
      ],
      "functions": [],
      "imports": [],
      "exports": [
        "ValidationError",
        "ProcessingError"
      ]
    },
    {
      "path": "tests/samples/sample_reexport/models.py",
      "language": "python",
      "lines": 21,
      "classes": [
        {
          "name": "User",
          "bases": [],
          "docstring": "User model."
        },
        {
          "name": "Order",
          "bases": [],
          "docstring": "Order model."
        },
        {
          "name": "Product",
          "bases": [],
          "docstring": "Product model."
        }
      ],
      "functions": [],
      "imports": [
        "dataclasses.dataclass",
        "typing.List",
        "typing.Optional"
      ],
      "exports": [
        "User",
        "Order",
        "Product"
      ]
    },
    {
      "path": "tests/samples/sample_reexport/utils.py",
      "language": "python",
      "lines": 8,
      "classes": [],
      "functions": [
        {
          "name": "process_data",
          "signature": "(data:Dict[str,Any])->Dict[str, Any]",
          "intent": "processes data",
          "is_async": false
        },
        {
          "name": "validate_input",
          "signature": "(data:Dict[str,Any])->bool",
          "intent": "validates input",
          "is_async": false
        }
      ],
      "imports": [
        "typing.Any",
        "typing.Dict"
      ],
      "exports": [
        "process_data",
        "validate_input"
      ]
    },
    {
      "path": "tests/samples/sample_rust.rs",
      "language": "rust",
      "lines": 168,
      "classes": [
        {
          "name": "User",
          "bases": [],
          "docstring": null,
          "methods": [
            {
              "name": "id",
              "signature": "(&self)->Self::Id",
              "intent": "id",
              "is_async": false
            }
          ]
        },
        {
          "name": "Product",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Order",
          "bases": [],
          "docstring": null,
          "methods": [
            {
              "name": "id",
              "signature": "(&self)->Self::Id",
              "intent": "id",
              "is_async": false
            }
          ]
        },
        {
          "name": "OrderItem",
          "bases": [],
          "docstring": null
        },
        {
          "name": "Repository",
          "bases": [],
          "docstring": null
        },
        {
          "name": "AppError",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "fmt",
          "signature": "(&self,f: &mut fmt::Formatter<'_>)->fmt::Result",
          "intent": "fmt",
          "is_async": false
        },
        {
          "name": "id",
          "signature": "(&self)->Self::Id;",
          "intent": "id",
          "is_async": false
        },
        {
          "name": "id",
          "signature": "(&self)->Self::Id",
          "intent": "id",
          "is_async": false
        },
        {
          "name": "id",
          "signature": "(&self)->Self::Id",
          "intent": "id",
          "is_async": false
        },
        {
          "name": "new",
          "signature": "()->Self",
          "intent": "creates",
          "is_async": false
        },
        {
          "name": "add",
          "signature": "(&mut self,item: T)",
          "intent": "creates",
          "is_async": false
        },
        {
          "name": "get",
          "signature": "(&self,id: &str)->Option<&T>",
          "intent": "retrieves",
          "is_async": false
        },
        {
          "name": "get_all",
          "signature": "(&self)->Vec<&T>",
          "intent": "retrieves all",
          "is_async": false
        },
        {
          "name": "delete",
          "signature": "(&mut self,id: &str)->bool",
          "intent": "deletes",
          "is_async": false
        },
        {
          "name": "count",
          "signature": "(&self)->usize",
          "intent": "count",
          "is_async": false
        },
        {
          "name": "create_user",
          "signature": "(id: u64,name: &str,email: &str)->User",
          "intent": "creates user",
          "is_async": false
        },
        {
          "name": "calculate_order_total",
          "signature": "(items: &[OrderItem])->f64",
          "intent": "processes order total",
          "is_async": false
        },
        {
          "name": "validate_email",
          "signature": "(email: &str)->Result<()>",
          "intent": "validates email",
          "is_async": false
        },
        {
          "name": "process_order",
          "signature": "(mut order: Order)->Result<Order>",
          "intent": "processes order",
          "is_async": false
        },
        {
          "name": "test_create_user",
          "signature": "()",
          "intent": "checks create user",
          "is_async": false
        },
        {
          "name": "test_calculate_order_total",
          "signature": "()",
          "intent": "checks calculate order total",
          "is_async": false
        },
        {
          "name": "test_validate_email",
          "signature": "()",
          "intent": "checks validate email",
          "is_async": false
        }
      ],
      "imports": [
        "std::collections::HashMap",
        "std::fmt"
      ],
      "exports": [
        "User",
        "Product",
        "Order",
        "OrderItem",
        "Repository",
        "OrderStatus",
        "AppError",
        "Entity",
        "fmt",
        "id"
      ]
    },
    {
      "path": "tests/samples/sample_sql.sql",
      "language": "sql",
      "lines": 73,
      "classes": [
        {
          "name": "users",
          "bases": [],
          "docstring": null
        },
        {
          "name": "products",
          "bases": [],
          "docstring": null
        },
        {
          "name": "orders",
          "bases": [],
          "docstring": null
        },
        {
          "name": "order_items",
          "bases": [],
          "docstring": null
        },
        {
          "name": "order_summary",
          "bases": [],
          "docstring": null
        }
      ],
      "functions": [
        {
          "name": "calculate_order_total",
          "signature": "()",
          "intent": "processes order total",
          "is_async": false
        },
        {
          "name": "update_order_total",
          "signature": "()",
          "intent": "updates order total",
          "is_async": false
        }
      ],
      "imports": [],
      "exports": [
        "users",
        "products",
        "orders",
        "order_items",
        "order_summary",
        "calculate_order_total",
        "update_order_total"
      ]
    },
    {
      "path": "tests/samples/sample_sql_dsl.py",
      "language": "python",
      "lines": 177,
      "classes": [
        {
          "name": "SQLOperator",
          "bases": [
            "Enum"
          ],
          "docstring": "SQL comparison operators."
        },
        {
          "name": "JoinType",
          "bases": [
            "Enum"
          ],
          "docstring": "SQL join types."
        },
        {
          "name": "Condition",
          "bases": [],
          "docstring": "SQL WHERE condition.",
          "methods": [
            {
              "name": "to_sql",
              "signature": "()->str",
              "intent": "converts sql",
              "is_async": false
            }
          ]
        },
        {
          "name": "Join",
          "bases": [],
          "docstring": "SQL JOIN clause.",
          "methods": [
            {
              "name": "to_sql",
              "signature": "()->str",
              "intent": "converts sql",
              "is_async": false
            }
          ]
        },
        {
          "name": "QueryBuilder",
          "bases": [],
          "docstring": "Fluent SQL query builder.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(table:str)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "select",
              "signature": "()->\"QueryBuilder\"",
              "intent": "retrieves",
              "is_async": false
            },
            {
              "name": "where",
              "signature": "(column:str,operator:Union[SQLOperator,str],value:Any=None)->\"QueryBuilder\"",
              "intent": "where",
              "is_async": false
            },
            {
              "name": "join",
              "signature": "(table:str,on_left:str,on_right:str,join_type:JoinType=JoinType.INNER)->\"QueryBuilder\"",
              "intent": "merges",
              "is_async": false
            },
            {
              "name": "order_by",
              "signature": "()->\"QueryBuilder\"",
              "intent": "sorts by",
              "is_async": false
            },
            {
              "name": "group_by",
              "signature": "()->\"QueryBuilder\"",
              "intent": "group by",
              "is_async": false
            },
            {
              "name": "limit",
              "signature": "(count:int)->\"QueryBuilder\"",
              "intent": "limit",
              "is_async": false
            },
            {
              "name": "offset",
              "signature": "(count:int)->\"QueryBuilder\"",
              "intent": "offset",
              "is_async": false
            },
            {
              "name": "build",
              "signature": "()->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        },
        {
          "name": "InsertBuilder",
          "bases": [],
          "docstring": "SQL INSERT query builder.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(table:str)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "columns",
              "signature": "()->\"InsertBuilder\"",
              "intent": "columns",
              "is_async": false
            },
            {
              "name": "values",
              "signature": "()->\"InsertBuilder\"",
              "intent": "values",
              "is_async": false
            },
            {
              "name": "build",
              "signature": "()->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        },
        {
          "name": "UpdateBuilder",
          "bases": [],
          "docstring": "SQL UPDATE query builder.",
          "methods": [
            {
              "name": "__init__",
              "signature": "(table:str)",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "set",
              "signature": "(column:str,value:Any)->\"UpdateBuilder\"",
              "intent": "updates",
              "is_async": false
            },
            {
              "name": "where",
              "signature": "(column:str,operator:SQLOperator,value:Any=None)->\"UpdateBuilder\"",
              "intent": "where",
              "is_async": false
            },
            {
              "name": "build",
              "signature": "()->str",
              "intent": "creates",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "select",
          "signature": "(table:str)->QueryBuilder",
          "intent": "retrieves",
          "is_async": false
        },
        {
          "name": "insert",
          "signature": "(table:str)->InsertBuilder",
          "intent": "creates",
          "is_async": false
        },
        {
          "name": "update",
          "signature": "(table:str)->UpdateBuilder",
          "intent": "updates",
          "is_async": false
        }
      ],
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Union",
        "dataclasses.dataclass",
        "dataclasses.field",
        "enum.Enum"
      ],
      "exports": [
        "SQLOperator",
        "JoinType",
        "Condition",
        "Join",
        "QueryBuilder",
        "InsertBuilder",
        "UpdateBuilder",
        "select",
        "insert",
        "update"
      ]
    },
    {
      "path": "tests/samples/sample_ts_reexport/index.ts",
      "language": "typescript",
      "lines": 2,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": [
        "add",
        "multiply"
      ]
    },
    {
      "path": "tests/samples/sample_ts_reexport/math.ts",
      "language": "typescript",
      "lines": 6,
      "classes": [],
      "functions": [
        {
          "name": "add",
          "signature": "(a: number,b: number)->number",
          "intent": "creates",
          "is_async": false
        },
        {
          "name": "multiply",
          "signature": "(a: number,b: number)->number",
          "intent": "multiply",
          "is_async": false
        }
      ],
      "imports": [],
      "exports": [
        "add",
        "multiply"
      ]
    },
    {
      "path": "tests/samples/sample_ts_reexport/types.ts",
      "language": "typescript",
      "lines": 5,
      "classes": [],
      "functions": [],
      "imports": [],
      "exports": [
        "User",
        "Result"
      ]
    },
    {
      "path": "tests/samples/sample_typescript.ts",
      "language": "typescript",
      "lines": 114,
      "classes": [
        {
          "name": "Repository",
          "bases": [],
          "docstring": null,
          "methods": [
            {
              "name": "add",
              "signature": "(item: T)->void",
              "intent": "creates",
              "is_async": false
            },
            {
              "name": "get",
              "signature": "(id: T['id'])->Nullable<T>",
              "intent": "retrieves",
              "is_async": false
            },
            {
              "name": "getAll",
              "signature": "()->T[]",
              "intent": "retrieves all",
              "is_async": false
            },
            {
              "name": "delete",
              "signature": "(id: T['id'])->boolean",
              "intent": "deletes",
              "is_async": false
            },
            {
              "name": "count",
              "signature": "()->number",
              "intent": "count",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "createUser",
          "signature": "(id: number,name: string,email: string)->User",
          "intent": "creates user",
          "is_async": false
        },
        {
          "name": "calculateOrderTotal",
          "signature": "(items: OrderItem[])->number",
          "intent": "processes order total",
          "is_async": false
        },
        {
          "name": "filterByStatus",
          "signature": "(items: T[],status: string)->T[]",
          "intent": "filters by status",
          "is_async": false
        },
        {
          "name": "groupBy",
          "signature": "(items: T[],key: K)->Map<T[K], T[]>",
          "intent": "group by",
          "is_async": false
        },
        {
          "name": "fetchUser",
          "signature": "(id: number)->Promise<Result<User>>",
          "intent": "retrieves user",
          "is_async": true
        },
        {
          "name": "processOrder",
          "signature": "(order: Order)->Promise<Result<Order>>",
          "intent": "processes order",
          "is_async": true
        }
      ],
      "imports": [],
      "exports": [
        "Order",
        "User",
        "fetchUser",
        "groupBy",
        "processOrder",
        "Nullable",
        "OrderItem",
        "Product",
        "createUser",
        "calculateOrderTotal"
      ]
    },
    {
      "path": "tests/test_analyzer.py",
      "language": "python",
      "lines": 180,
      "classes": [
        {
          "name": "TestProjectAnalyzer",
          "bases": [],
          "docstring": "Test cases for ProjectAnalyzer.",
          "methods": [
            {
              "name": "test_init",
              "signature": "(temp_project_dir)",
              "intent": "checks init",
              "is_async": false
            },
            {
              "name": "test_init_with_verbose",
              "signature": "(temp_project_dir,capsys)",
              "intent": "checks init with verbose",
              "is_async": false
            },
            {
              "name": "test_analyze_returns_project_info",
              "signature": "(sample_project)",
              "intent": "checks analyze returns project info",
              "is_async": false
            },
            {
              "name": "test_analyze_finds_source_files",
              "signature": "(sample_project)",
              "intent": "checks analyze finds source files",
              "is_async": false
            },
            {
              "name": "test_ignores_non_source_files",
              "signature": "(temp_project_dir)",
              "intent": "checks ignores non source files",
              "is_async": false
            },
            {
              "name": "test_ignores_common_dirs",
              "signature": "(temp_project_dir)",
              "intent": "checks ignores common dirs",
              "is_async": false
            },
            {
              "name": "test_analyze_extracts_functions",
              "signature": "(temp_project_dir)",
              "intent": "checks analyze extracts functions",
              "is_async": false
            },
            {
              "name": "test_analyze_extracts_classes",
              "signature": "(temp_project_dir)",
              "intent": "checks analyze extracts classes",
              "is_async": false
            },
            {
              "name": "test_analyze_extracts_imports",
              "signature": "(temp_project_dir)",
              "intent": "checks analyze extracts imports",
              "is_async": false
            },
            {
              "name": "test_analyze_counts_lines",
              "signature": "(temp_project_dir)",
              "intent": "checks analyze counts lines",
              "is_async": false
            },
            {
              "name": "test_analyze_empty_project",
              "signature": "(temp_project_dir)",
              "intent": "checks analyze empty project",
              "is_async": false
            },
            {
              "name": "test_detect_entrypoints",
              "signature": "(temp_project_dir)",
              "intent": "checks detect entrypoints",
              "is_async": false
            },
            {
              "name": "test_get_statistics",
              "signature": "(sample_project)",
              "intent": "checks get statistics",
              "is_async": false
            },
            {
              "name": "test_language_detection",
              "signature": "(temp_project_dir)",
              "intent": "checks language detection",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestAnalyzeProjectFunction",
          "bases": [],
          "docstring": "Test the analyze_project convenience function.",
          "methods": [
            {
              "name": "test_analyze_project",
              "signature": "(sample_project)",
              "intent": "checks analyze project",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestGetLibraryStatus",
          "bases": [],
          "docstring": "Test the get_library_status function.",
          "methods": [
            {
              "name": "test_get_library_status",
              "signature": "()",
              "intent": "checks get library status",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "pytest",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "code2logic.analyzer.ProjectAnalyzer",
        "code2logic.analyzer.analyze_project",
        "code2logic.analyzer.get_library_status",
        "code2logic.models.ProjectInfo",
        "code2logic.models.ModuleInfo"
      ],
      "exports": [
        "TestProjectAnalyzer",
        "TestAnalyzeProjectFunction",
        "TestGetLibraryStatus"
      ]
    },
    {
      "path": "tests/test_e2e_projects.py",
      "language": "python",
      "lines": 82,
      "classes": [],
      "functions": [
        {
          "name": "_repo_root",
          "signature": "()->Path",
          "intent": "repo root",
          "is_async": false
        },
        {
          "name": "_copy_example_sample_project",
          "signature": "(tmp_path:Path)->Path",
          "intent": "copy example sample project",
          "is_async": false
        },
        {
          "name": "_write_code2logic_compact_yaml",
          "signature": "(project_dir:Path,out_file:Path)->None",
          "intent": "logs code2logic compact yaml",
          "is_async": false
        },
        {
          "name": "test_e2e_pipeline_code2logic_logic2test_logic2code",
          "signature": "(tmp_path:Path)->None",
          "intent": "checks e2e pipeline code2logic logic2test logic2code",
          "is_async": false
        },
        {
          "name": "test_e2e_logic2test_on_examples_input",
          "signature": "(tmp_path:Path)->None",
          "intent": "checks e2e logic2test on examples input",
          "is_async": false
        },
        {
          "name": "test_e2e_logic2code_on_examples_input",
          "signature": "(tmp_path:Path)->None",
          "intent": "checks e2e logic2code on examples input",
          "is_async": false
        }
      ],
      "imports": [
        "shutil",
        "pathlib.Path",
        "code2logic.analyze_project",
        "code2logic.generators.YAMLGenerator",
        "logic2code.generator.Logic2CodeGenerator",
        "logic2code.generator.Logic2CodeGeneratorConfig",
        "logic2test.generator.Logic2TestGeneratorConfig",
        "logic2test.generator.Logic2TestGenerator"
      ],
      "exports": [
        "test_e2e_pipeline_code2logic_logic2test_logic2code",
        "test_e2e_logic2test_on_examples_input",
        "test_e2e_logic2code_on_examples_input"
      ]
    },
    {
      "path": "tests/test_error_handling.py",
      "language": "python",
      "lines": 311,
      "classes": [
        {
          "name": "TestFilesystemErrors",
          "bases": [],
          "docstring": "Tests for filesystem-related errors.",
          "methods": [
            {
              "name": "test_file_not_found",
              "signature": "(error_handler)",
              "intent": "checks file not found",
              "is_async": false
            },
            {
              "name": "test_permission_denied",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks permission denied",
              "is_async": false
            },
            {
              "name": "test_file_too_large",
              "signature": "(tmp_path)",
              "intent": "checks file too large",
              "is_async": false
            },
            {
              "name": "test_binary_file_detection",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks binary file detection",
              "is_async": false
            },
            {
              "name": "test_encoding_fallback",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks encoding fallback",
              "is_async": false
            },
            {
              "name": "test_empty_file",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks empty file",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestParsingErrors",
          "bases": [],
          "docstring": "Tests for parsing-related errors.",
          "methods": [
            {
              "name": "test_syntax_error_in_python",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks syntax error in python",
              "is_async": false
            },
            {
              "name": "test_deeply_nested_code",
              "signature": "(error_handler)",
              "intent": "checks deeply nested code",
              "is_async": false
            },
            {
              "name": "test_unsupported_language",
              "signature": "(error_handler)",
              "intent": "checks unsupported language",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestGenerationErrors",
          "bases": [],
          "docstring": "Tests for output generation errors.",
          "methods": [
            {
              "name": "test_yaml_with_special_characters",
              "signature": "(temp_project)",
              "intent": "checks yaml with special characters",
              "is_async": false
            },
            {
              "name": "test_json_with_unicode",
              "signature": "(temp_project)",
              "intent": "checks json with unicode",
              "is_async": false
            },
            {
              "name": "test_write_to_readonly_location",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks write to readonly location",
              "is_async": false
            },
            {
              "name": "test_write_creates_directories",
              "signature": "(error_handler,tmp_path)",
              "intent": "checks write creates directories",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestErrorHandlerModes",
          "bases": [],
          "docstring": "Tests for different error handler modes.",
          "methods": [
            {
              "name": "test_lenient_mode_continues",
              "signature": "(tmp_path)",
              "intent": "checks lenient mode continues",
              "is_async": false
            },
            {
              "name": "test_strict_mode_stops",
              "signature": "(tmp_path)",
              "intent": "checks strict mode stops",
              "is_async": false
            },
            {
              "name": "test_silent_mode_no_logging",
              "signature": "(tmp_path,caplog)",
              "intent": "checks silent mode no logging",
              "is_async": false
            },
            {
              "name": "test_critical_error_stops_all_modes",
              "signature": "()",
              "intent": "checks critical error stops all modes",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestIntegration",
          "bases": [],
          "docstring": "Integration tests for error handling during full analysis.",
          "methods": [
            {
              "name": "test_mixed_valid_invalid_files",
              "signature": "(tmp_path)",
              "intent": "checks mixed valid invalid files",
              "is_async": false
            },
            {
              "name": "test_nested_folders_with_errors",
              "signature": "(tmp_path)",
              "intent": "checks nested folders with errors",
              "is_async": false
            },
            {
              "name": "test_large_project_resilience",
              "signature": "(tmp_path)",
              "intent": "checks large project resilience",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestAnalysisResult",
          "bases": [],
          "docstring": "Tests for AnalysisResult class.",
          "methods": [
            {
              "name": "test_result_summary",
              "signature": "()",
              "intent": "checks result summary",
              "is_async": false
            },
            {
              "name": "test_error_to_dict",
              "signature": "()",
              "intent": "checks error to dict",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestEdgeCases",
          "bases": [],
          "docstring": "Tests for edge cases and unusual scenarios.",
          "methods": [
            {
              "name": "test_very_long_lines",
              "signature": "(tmp_path)",
              "intent": "checks very long lines",
              "is_async": false
            },
            {
              "name": "test_many_functions",
              "signature": "(tmp_path)",
              "intent": "checks many functions",
              "is_async": false
            },
            {
              "name": "test_deeply_nested_classes",
              "signature": "(tmp_path)",
              "intent": "checks deeply nested classes",
              "is_async": false
            },
            {
              "name": "test_circular_imports_reference",
              "signature": "(tmp_path)",
              "intent": "checks circular imports reference",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "error_handler",
          "signature": "()",
          "intent": "error handler",
          "is_async": false
        },
        {
          "name": "strict_handler",
          "signature": "()",
          "intent": "strict handler",
          "is_async": false
        },
        {
          "name": "temp_project",
          "signature": "(tmp_path)",
          "intent": "temp project",
          "is_async": false
        }
      ],
      "imports": [
        "pytest",
        "tempfile",
        "os",
        "stat",
        "pathlib.Path",
        "unittest.mock.patch",
        "unittest.mock.MagicMock",
        "code2logic.errors.ErrorHandler",
        "code2logic.errors.ErrorType",
        "code2logic.errors.ErrorSeverity"
      ],
      "exports": [
        "error_handler",
        "strict_handler",
        "temp_project",
        "TestFilesystemErrors",
        "TestParsingErrors",
        "TestGenerationErrors",
        "TestErrorHandlerModes",
        "TestIntegration",
        "TestAnalysisResult",
        "TestEdgeCases"
      ]
    },
    {
      "path": "tests/test_formats.py",
      "language": "python",
      "lines": 393,
      "classes": [
        {
          "name": "TestAllFormatsGeneration",
          "bases": [],
          "docstring": "Test that all formats generate valid output.",
          "methods": [
            {
              "name": "test_format_generates_output",
              "signature": "(sample_project,fmt)",
              "intent": "checks format generates output",
              "is_async": false
            },
            {
              "name": "test_format_contains_class_info",
              "signature": "(sample_project,fmt)",
              "intent": "checks format contains class info",
              "is_async": false
            },
            {
              "name": "test_format_contains_function_info",
              "signature": "(sample_project,fmt)",
              "intent": "checks format contains function info",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestRustSupport",
          "bases": [],
          "docstring": null,
          "methods": [
            {
              "name": "test_rust_parsing_finds_top_level_and_impl_methods",
              "signature": "(rust_sample_project)",
              "intent": "checks rust parsing finds top level and impl methods",
              "is_async": false
            },
            {
              "name": "test_rust_shows_up_in_toon_and_function_logic",
              "signature": "(rust_sample_project)",
              "intent": "checks rust shows up in toon and function logic",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestFormatValidation",
          "bases": [],
          "docstring": "Test format validation where applicable.",
          "methods": [
            {
              "name": "test_yaml_validation_valid",
              "signature": "(sample_project)",
              "intent": "checks yaml validation valid",
              "is_async": false
            },
            {
              "name": "test_yaml_validation_invalid",
              "signature": "()",
              "intent": "checks yaml validation invalid",
              "is_async": false
            },
            {
              "name": "test_json_validation_valid",
              "signature": "(sample_project)",
              "intent": "checks json validation valid",
              "is_async": false
            },
            {
              "name": "test_json_validation_invalid",
              "signature": "()",
              "intent": "checks json validation invalid",
              "is_async": false
            },
            {
              "name": "test_logicml_validation_valid",
              "signature": "(sample_project)",
              "intent": "checks logicml validation valid",
              "is_async": false
            },
            {
              "name": "test_markdown_validation_valid",
              "signature": "(sample_project)",
              "intent": "checks markdown validation valid",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestFormatEfficiency",
          "bases": [],
          "docstring": "Test format size efficiency.",
          "methods": [
            {
              "name": "test_format_sizes",
              "signature": "(sample_project)",
              "intent": "checks format sizes",
              "is_async": false
            },
            {
              "name": "test_logicml_compression",
              "signature": "(sample_project)",
              "intent": "checks logicml compression",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestDetailLevels",
          "bases": [],
          "docstring": "Test different detail levels.",
          "methods": [
            {
              "name": "test_detail_levels_ordering",
              "signature": "(sample_project,fmt)",
              "intent": "checks detail levels ordering",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestYAMLSpecifics",
          "bases": [],
          "docstring": "YAML-specific tests.",
          "methods": [
            {
              "name": "test_yaml_parseable",
              "signature": "(sample_project)",
              "intent": "checks yaml parseable",
              "is_async": false
            },
            {
              "name": "test_yaml_includes_imports",
              "signature": "(sample_project)",
              "intent": "checks yaml includes imports",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestJSONSpecifics",
          "bases": [],
          "docstring": "JSON-specific tests.",
          "methods": [
            {
              "name": "test_json_parseable",
              "signature": "(sample_project)",
              "intent": "checks json parseable",
              "is_async": false
            },
            {
              "name": "test_json_structure",
              "signature": "(sample_project)",
              "intent": "checks json structure",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestLogicMLSpecifics",
          "bases": [],
          "docstring": "LogicML-specific tests.",
          "methods": [
            {
              "name": "test_logicml_has_signatures",
              "signature": "(sample_project)",
              "intent": "checks logicml has signatures",
              "is_async": false
            },
            {
              "name": "test_logicml_has_async_markers",
              "signature": "(samples_project)",
              "intent": "checks logicml has async markers",
              "is_async": false
            },
            {
              "name": "test_logicml_token_estimate",
              "signature": "(sample_project)",
              "intent": "checks logicml token estimate",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestGherkinSpecifics",
          "bases": [],
          "docstring": "Gherkin-specific tests.",
          "methods": [
            {
              "name": "test_gherkin_has_feature",
              "signature": "(sample_project)",
              "intent": "checks gherkin has feature",
              "is_async": false
            },
            {
              "name": "test_gherkin_has_scenarios",
              "signature": "(sample_project)",
              "intent": "checks gherkin has scenarios",
              "is_async": false
            },
            {
              "name": "test_gherkin_has_steps",
              "signature": "(sample_project)",
              "intent": "checks gherkin has steps",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestTOONSpecifics",
          "bases": [],
          "docstring": "TOON-specific tests.",
          "methods": [
            {
              "name": "test_toon_array_syntax",
              "signature": "(sample_project)",
              "intent": "checks toon array syntax",
              "is_async": false
            },
            {
              "name": "test_toon_tabular_syntax",
              "signature": "(sample_project)",
              "intent": "checks toon tabular syntax",
              "is_async": false
            },
            {
              "name": "test_toon_minimal_quoting",
              "signature": "(sample_project)",
              "intent": "checks toon minimal quoting",
              "is_async": false
            },
            {
              "name": "test_toon_with_tabs",
              "signature": "(sample_project)",
              "intent": "checks toon with tabs",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCSVSpecifics",
          "bases": [],
          "docstring": "CSV-specific tests.",
          "methods": [
            {
              "name": "test_csv_has_header",
              "signature": "(sample_project)",
              "intent": "checks csv has header",
              "is_async": false
            },
            {
              "name": "test_csv_consistent_columns",
              "signature": "(sample_project)",
              "intent": "checks csv consistent columns",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCompactSpecifics",
          "bases": [],
          "docstring": "Compact format-specific tests.",
          "methods": [
            {
              "name": "test_compact_is_small",
              "signature": "(sample_project)",
              "intent": "checks compact is small",
              "is_async": false
            },
            {
              "name": "test_compact_has_summary",
              "signature": "(sample_project)",
              "intent": "checks compact has summary",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCrossFormatEquivalence",
          "bases": [],
          "docstring": "Test that all formats contain equivalent information.",
          "methods": [
            {
              "name": "test_all_formats_have_project_name",
              "signature": "(sample_project)",
              "intent": "checks all formats have project name",
              "is_async": false
            },
            {
              "name": "test_all_formats_have_module_info",
              "signature": "(sample_project)",
              "intent": "checks all formats have module info",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "sample_code",
          "signature": "()",
          "intent": "sample code",
          "is_async": false
        },
        {
          "name": "sample_project",
          "signature": "(tmp_path,sample_code)",
          "intent": "sample project",
          "is_async": false
        },
        {
          "name": "samples_project",
          "signature": "()",
          "intent": "samples project",
          "is_async": false
        },
        {
          "name": "rust_sample_project",
          "signature": "(tmp_path)",
          "intent": "rust sample project",
          "is_async": false
        },
        {
          "name": "get_generator",
          "signature": "(fmt:str)",
          "intent": "retrieves generator",
          "is_async": false
        },
        {
          "name": "generate_output",
          "signature": "(generator,project,detail='standard')",
          "intent": "creates output",
          "is_async": false
        },
        {
          "name": "test_function_logic_toon_js_does_not_default_return_type_to_none",
          "signature": "(tmp_path)",
          "intent": "checks function logic toon js does not default return type to none",
          "is_async": false
        }
      ],
      "imports": [
        "pytest",
        "json",
        "pathlib.Path",
        "code2logic.analyze_project",
        "code2logic.YAMLGenerator",
        "code2logic.JSONGenerator",
        "code2logic.GherkinGenerator",
        "code2logic.MarkdownGenerator",
        "code2logic.LogicMLGenerator",
        "code2logic.TOONGenerator"
      ],
      "exports": [
        "sample_code",
        "sample_project",
        "samples_project",
        "rust_sample_project",
        "ALL_FORMATS",
        "get_generator",
        "generate_output",
        "TestAllFormatsGeneration",
        "TestRustSupport",
        "TestFormatValidation"
      ]
    },
    {
      "path": "tests/test_generators.py",
      "language": "python",
      "lines": 207,
      "classes": [
        {
          "name": "TestMarkdownGenerator",
          "bases": [],
          "docstring": "Tests for MarkdownGenerator.",
          "methods": [
            {
              "name": "test_generate_basic",
              "signature": "(sample_project)",
              "intent": "checks generate basic",
              "is_async": false
            },
            {
              "name": "test_generate_includes_modules",
              "signature": "(sample_project)",
              "intent": "checks generate includes modules",
              "is_async": false
            },
            {
              "name": "test_generate_includes_classes",
              "signature": "(sample_project)",
              "intent": "checks generate includes classes",
              "is_async": false
            },
            {
              "name": "test_generate_includes_functions",
              "signature": "(sample_project)",
              "intent": "checks generate includes functions",
              "is_async": false
            },
            {
              "name": "test_generate_includes_entrypoints",
              "signature": "(sample_project)",
              "intent": "checks generate includes entrypoints",
              "is_async": false
            },
            {
              "name": "test_detail_levels",
              "signature": "(sample_project)",
              "intent": "checks detail levels",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCompactGenerator",
          "bases": [],
          "docstring": "Tests for CompactGenerator.",
          "methods": [
            {
              "name": "test_generate_basic",
              "signature": "(sample_project)",
              "intent": "checks generate basic",
              "is_async": false
            },
            {
              "name": "test_generate_includes_hubs",
              "signature": "(sample_project)",
              "intent": "checks generate includes hubs",
              "is_async": false
            },
            {
              "name": "test_compact_is_smaller",
              "signature": "(sample_project)",
              "intent": "checks compact is smaller",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestJSONGenerator",
          "bases": [],
          "docstring": "Tests for JSONGenerator.",
          "methods": [
            {
              "name": "test_generate_valid_json",
              "signature": "(sample_project)",
              "intent": "checks generate valid json",
              "is_async": false
            },
            {
              "name": "test_generate_structure",
              "signature": "(sample_project)",
              "intent": "checks generate structure",
              "is_async": false
            },
            {
              "name": "test_generate_modules",
              "signature": "(sample_project)",
              "intent": "checks generate modules",
              "is_async": false
            },
            {
              "name": "test_generate_functions",
              "signature": "(sample_project)",
              "intent": "checks generate functions",
              "is_async": false
            },
            {
              "name": "test_generate_classes",
              "signature": "(sample_project)",
              "intent": "checks generate classes",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "sample_project",
          "signature": "()",
          "intent": "sample project",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "pytest",
        "code2logic.MarkdownGenerator",
        "code2logic.CompactGenerator",
        "code2logic.JSONGenerator",
        "code2logic.ProjectInfo",
        "code2logic.ModuleInfo",
        "code2logic.ClassInfo",
        "code2logic.FunctionInfo"
      ],
      "exports": [
        "sample_project",
        "TestMarkdownGenerator",
        "TestCompactGenerator",
        "TestJSONGenerator"
      ]
    },
    {
      "path": "tests/test_intent.py",
      "language": "python",
      "lines": 353,
      "classes": [
        {
          "name": "TestIntentAnalyzer",
          "bases": [],
          "docstring": "Test cases for IntentAnalyzer.",
          "methods": [
            {
              "name": "test_init",
              "signature": "()",
              "intent": "checks init",
              "is_async": false
            },
            {
              "name": "test_extract_keywords",
              "signature": "()",
              "intent": "checks extract keywords",
              "is_async": false
            },
            {
              "name": "test_calculate_intent_confidence",
              "signature": "()",
              "intent": "checks calculate intent confidence",
              "is_async": false
            },
            {
              "name": "test_identify_target_module",
              "signature": "(sample_project_model)",
              "intent": "checks identify target module",
              "is_async": false
            },
            {
              "name": "test_identify_target_function",
              "signature": "(sample_project_model)",
              "intent": "checks identify target function",
              "is_async": false
            },
            {
              "name": "test_identify_target_class",
              "signature": "(sample_project_model)",
              "intent": "checks identify target class",
              "is_async": false
            },
            {
              "name": "test_identify_target_project",
              "signature": "(sample_project_model)",
              "intent": "checks identify target project",
              "is_async": false
            },
            {
              "name": "test_generate_description",
              "signature": "()",
              "intent": "checks generate description",
              "is_async": false
            },
            {
              "name": "test_generate_suggestions_refactor",
              "signature": "()",
              "intent": "checks generate suggestions refactor",
              "is_async": false
            },
            {
              "name": "test_generate_suggestions_analyze",
              "signature": "()",
              "intent": "checks generate suggestions analyze",
              "is_async": false
            },
            {
              "name": "test_generate_suggestions_optimize",
              "signature": "()",
              "intent": "checks generate suggestions optimize",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_refactor",
              "signature": "(sample_project_model)",
              "intent": "checks analyze intent refactor",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_analyze",
              "signature": "(sample_project_model)",
              "intent": "checks analyze intent analyze",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_optimize",
              "signature": "(sample_project_model)",
              "intent": "checks analyze intent optimize",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_multiple",
              "signature": "(sample_project_model)",
              "intent": "checks analyze intent multiple",
              "is_async": false
            },
            {
              "name": "test_analyze_intent_sorting",
              "signature": "(sample_project_model)",
              "intent": "checks analyze intent sorting",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_long_module",
              "signature": "()",
              "intent": "checks detect code smells long module",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_complex_function",
              "signature": "()",
              "intent": "checks detect code smells complex function",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_large_class",
              "signature": "()",
              "intent": "checks detect code smells large class",
              "is_async": false
            },
            {
              "name": "test_detect_code_smells_too_many_imports",
              "signature": "()",
              "intent": "checks detect code smells too many imports",
              "is_async": false
            },
            {
              "name": "test_suggest_refactoring_module",
              "signature": "(sample_project_model)",
              "intent": "checks suggest refactoring module",
              "is_async": false
            },
            {
              "name": "test_suggest_refactoring_class",
              "signature": "(sample_project_model)",
              "intent": "checks suggest refactoring class",
              "is_async": false
            },
            {
              "name": "test_suggest_refactoring_function",
              "signature": "(sample_project_model)",
              "intent": "checks suggest refactoring function",
              "is_async": false
            },
            {
              "name": "test_find_target_object_module",
              "signature": "(sample_project_model)",
              "intent": "checks find target object module",
              "is_async": false
            },
            {
              "name": "test_find_target_object_function",
              "signature": "(sample_project_model)",
              "intent": "checks find target object function",
              "is_async": false
            },
            {
              "name": "test_find_target_object_class",
              "signature": "(sample_project_model)",
              "intent": "checks find target object class",
              "is_async": false
            },
            {
              "name": "test_find_target_object_not_found",
              "signature": "(sample_project_model)",
              "intent": "checks find target object not found",
              "is_async": false
            },
            {
              "name": "test_suggest_module_refactoring",
              "signature": "()",
              "intent": "checks suggest module refactoring",
              "is_async": false
            },
            {
              "name": "test_suggest_class_refactoring",
              "signature": "()",
              "intent": "checks suggest class refactoring",
              "is_async": false
            },
            {
              "name": "test_suggest_function_refactoring",
              "signature": "()",
              "intent": "checks suggest function refactoring",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "make_function",
          "signature": "(name,params=None,complexity=1,lines=5...+1)",
          "intent": "creates function",
          "is_async": false
        },
        {
          "name": "make_class",
          "signature": "(name,methods=None,bases=None)",
          "intent": "creates class",
          "is_async": false
        },
        {
          "name": "make_module",
          "signature": "(name,path,functions=None,classes=None...+2)",
          "intent": "creates module",
          "is_async": false
        },
        {
          "name": "make_project",
          "signature": "(name,modules)",
          "intent": "creates project",
          "is_async": false
        }
      ],
      "imports": [
        "pytest",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "code2logic.intent.IntentAnalyzer",
        "code2logic.intent.IntentType",
        "code2logic.intent.Intent",
        "code2logic.models.ProjectInfo",
        "code2logic.models.ModuleInfo",
        "code2logic.models.FunctionInfo",
        "code2logic.models.ClassInfo"
      ],
      "exports": [
        "make_function",
        "make_class",
        "make_module",
        "make_project",
        "TestIntentAnalyzer"
      ]
    },
    {
      "path": "tests/test_llm_priority.py",
      "language": "python",
      "lines": 44,
      "classes": [],
      "functions": [
        {
          "name": "_write_user_llm_config",
          "signature": "(tmp_path:Path,data:dict)->Path",
          "intent": "logs user llm config",
          "is_async": false
        },
        {
          "name": "test_get_client_auto_prefers_override_provider_on_tie",
          "signature": "(tmp_path:Path,monkeypatch:Any)",
          "intent": "checks get client auto prefers override provider on tie",
          "is_async": false
        },
        {
          "name": "test_get_client_auto_model_first_uses_model_priority",
          "signature": "(tmp_path:Path,monkeypatch:Any)",
          "intent": "checks get client auto model first uses model priority",
          "is_async": false
        }
      ],
      "imports": [
        "json",
        "os",
        "pathlib.Path",
        "pytest",
        "code2logic.llm_clients.OpenRouterClient",
        "code2logic.llm_clients.OllamaLocalClient",
        "code2logic.llm_clients.get_client"
      ],
      "exports": [
        "test_get_client_auto_prefers_override_provider_on_tie",
        "test_get_client_auto_model_first_uses_model_priority"
      ]
    },
    {
      "path": "tests/test_llm_profiler.py",
      "language": "python",
      "lines": 416,
      "classes": [
        {
          "name": "TestLLMProfile",
          "bases": [],
          "docstring": "Tests for LLMProfile dataclass.",
          "methods": [
            {
              "name": "test_profile_creation",
              "signature": "()",
              "intent": "checks profile creation",
              "is_async": false
            },
            {
              "name": "test_profile_id_consistency",
              "signature": "()",
              "intent": "checks profile id consistency",
              "is_async": false
            },
            {
              "name": "test_profile_defaults",
              "signature": "()",
              "intent": "checks profile defaults",
              "is_async": false
            },
            {
              "name": "test_profile_custom_values",
              "signature": "()",
              "intent": "checks profile custom values",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestDefaultProfiles",
          "bases": [],
          "docstring": "Tests for default profile creation.",
          "methods": [
            {
              "name": "test_gpt4_profile",
              "signature": "()",
              "intent": "checks gpt4 profile",
              "is_async": false
            },
            {
              "name": "test_gpt4_turbo_profile",
              "signature": "()",
              "intent": "checks gpt4 turbo profile",
              "is_async": false
            },
            {
              "name": "test_claude_profile",
              "signature": "()",
              "intent": "checks claude profile",
              "is_async": false
            },
            {
              "name": "test_qwen_coder_profile",
              "signature": "()",
              "intent": "checks qwen coder profile",
              "is_async": false
            },
            {
              "name": "test_deepseek_profile",
              "signature": "()",
              "intent": "checks deepseek profile",
              "is_async": false
            },
            {
              "name": "test_llama_70b_profile",
              "signature": "()",
              "intent": "checks llama 70b profile",
              "is_async": false
            },
            {
              "name": "test_llama_7b_profile",
              "signature": "()",
              "intent": "checks llama 7b profile",
              "is_async": false
            },
            {
              "name": "test_mistral_profile",
              "signature": "()",
              "intent": "checks mistral profile",
              "is_async": false
            },
            {
              "name": "test_unknown_model_profile",
              "signature": "()",
              "intent": "checks unknown model profile",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestProfileStorage",
          "bases": [],
          "docstring": "Tests for profile storage (save/load).",
          "methods": [
            {
              "name": "test_save_and_load_profile",
              "signature": "(tmp_path)",
              "intent": "checks save and load profile",
              "is_async": false
            },
            {
              "name": "test_load_empty_profiles",
              "signature": "(tmp_path)",
              "intent": "checks load empty profiles",
              "is_async": false
            },
            {
              "name": "test_get_profile",
              "signature": "(tmp_path)",
              "intent": "checks get profile",
              "is_async": false
            },
            {
              "name": "test_get_nonexistent_profile",
              "signature": "(tmp_path)",
              "intent": "checks get nonexistent profile",
              "is_async": false
            },
            {
              "name": "test_get_or_create_profile_existing",
              "signature": "(tmp_path)",
              "intent": "checks get or create profile existing",
              "is_async": false
            },
            {
              "name": "test_get_or_create_profile_new",
              "signature": "(tmp_path)",
              "intent": "checks get or create profile new",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestAdaptiveChunker",
          "bases": [],
          "docstring": "Tests for AdaptiveChunker.",
          "methods": [
            {
              "name": "test_chunker_creation",
              "signature": "()",
              "intent": "checks chunker creation",
              "is_async": false
            },
            {
              "name": "test_chunker_default_profile",
              "signature": "()",
              "intent": "checks chunker default profile",
              "is_async": false
            },
            {
              "name": "test_chunk_small_spec",
              "signature": "()",
              "intent": "checks chunk small spec",
              "is_async": false
            },
            {
              "name": "test_chunk_large_spec",
              "signature": "()",
              "intent": "checks chunk large spec",
              "is_async": false
            },
            {
              "name": "test_chunk_format_adjustment",
              "signature": "()",
              "intent": "checks chunk format adjustment",
              "is_async": false
            },
            {
              "name": "test_recommend_format_small_spec",
              "signature": "()",
              "intent": "checks recommend format small spec",
              "is_async": false
            },
            {
              "name": "test_recommend_format_large_spec",
              "signature": "()",
              "intent": "checks recommend format large spec",
              "is_async": false
            },
            {
              "name": "test_estimate_chunks_needed",
              "signature": "()",
              "intent": "checks estimate chunks needed",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestLLMProfiler",
          "bases": [],
          "docstring": "Tests for LLMProfiler class.",
          "methods": [
            {
              "name": "test_profiler_creation",
              "signature": "()",
              "intent": "checks profiler creation",
              "is_async": false
            },
            {
              "name": "test_profiler_with_unknown_client",
              "signature": "()",
              "intent": "checks profiler with unknown client",
              "is_async": false
            },
            {
              "name": "test_code_to_spec",
              "signature": "()",
              "intent": "checks code to spec",
              "is_async": false
            },
            {
              "name": "test_extract_code_with_block",
              "signature": "()",
              "intent": "checks extract code with block",
              "is_async": false
            },
            {
              "name": "test_extract_code_without_block",
              "signature": "()",
              "intent": "checks extract code without block",
              "is_async": false
            },
            {
              "name": "test_check_syntax_valid",
              "signature": "()",
              "intent": "checks check syntax valid",
              "is_async": false
            },
            {
              "name": "test_check_syntax_invalid",
              "signature": "()",
              "intent": "checks check syntax invalid",
              "is_async": false
            },
            {
              "name": "test_calculate_similarity",
              "signature": "()",
              "intent": "checks calculate similarity",
              "is_async": false
            },
            {
              "name": "test_run_profile_quick",
              "signature": "(tmp_path)",
              "intent": "checks run profile quick",
              "is_async": false
            },
            {
              "name": "test_metrics_calculation",
              "signature": "()",
              "intent": "checks metrics calculation",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestProfileTestCases",
          "bases": [],
          "docstring": "Tests for built-in test cases.",
          "methods": [
            {
              "name": "test_test_cases_exist",
              "signature": "()",
              "intent": "checks test cases exist",
              "is_async": false
            },
            {
              "name": "test_test_cases_valid_python",
              "signature": "()",
              "intent": "checks test cases valid python",
              "is_async": false
            },
            {
              "name": "test_test_cases_have_functions_or_classes",
              "signature": "()",
              "intent": "checks test cases have functions or classes",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestConvenienceFunctions",
          "bases": [],
          "docstring": "Tests for convenience functions.",
          "methods": [
            {
              "name": "test_get_adaptive_chunker",
              "signature": "()",
              "intent": "checks get adaptive chunker",
              "is_async": false
            },
            {
              "name": "test_profile_llm_function",
              "signature": "(tmp_path)",
              "intent": "checks profile llm function",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "json",
        "tempfile",
        "os",
        "pathlib.Path",
        "unittest.mock.Mock",
        "unittest.mock.patch",
        "pytest",
        "code2logic.llm_profiler.LLMProfile",
        "code2logic.llm_profiler.LLMProfiler",
        "code2logic.llm_profiler.AdaptiveChunker"
      ],
      "exports": [
        "TestLLMProfile",
        "TestDefaultProfiles",
        "TestProfileStorage",
        "TestAdaptiveChunker",
        "TestLLMProfiler",
        "TestProfileTestCases",
        "TestConvenienceFunctions"
      ]
    },
    {
      "path": "tests/test_parser_integrity.py",
      "language": "python",
      "lines": 361,
      "classes": [
        {
          "name": "TestFunctionNameExtraction",
          "bases": [],
          "docstring": "Test 1: Verify complete function names are extracted.",
          "methods": [
            {
              "name": "test_function_name_not_truncated",
              "signature": "(parser)",
              "intent": "checks function name not truncated",
              "is_async": false
            },
            {
              "name": "test_multiple_function_names",
              "signature": "(parser)",
              "intent": "checks multiple function names",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestSignatureParsing",
          "bases": [],
          "docstring": "Test 2: Verify complete signatures with types.",
          "methods": [
            {
              "name": "test_signature_with_types",
              "signature": "(parser)",
              "intent": "checks signature with types",
              "is_async": false
            },
            {
              "name": "test_signature_with_defaults",
              "signature": "(parser)",
              "intent": "checks signature with defaults",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestClassNameIntegrity",
          "bases": [],
          "docstring": "Test 3: Verify class names have no embedded whitespace.",
          "methods": [
            {
              "name": "test_class_name_no_whitespace",
              "signature": "(parser)",
              "intent": "checks class name no whitespace",
              "is_async": false
            },
            {
              "name": "test_class_with_bases",
              "signature": "(parser)",
              "intent": "checks class with bases",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestImportParsing",
          "bases": [],
          "docstring": "Test 4: Verify imports are correctly formatted.",
          "methods": [
            {
              "name": "test_import_from_statement",
              "signature": "(parser)",
              "intent": "checks import from statement",
              "is_async": false
            },
            {
              "name": "test_no_duplicate_imports",
              "signature": "(parser)",
              "intent": "checks no duplicate imports",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestExportsCompleteness",
          "bases": [],
          "docstring": "Test 5: Verify exports contain full function names.",
          "methods": [
            {
              "name": "test_exports_complete",
              "signature": "(parser)",
              "intent": "checks exports complete",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestDocstringTruncation",
          "bases": [],
          "docstring": "Test 6: Verify docstrings are properly truncated.",
          "methods": [
            {
              "name": "test_long_docstring_truncated",
              "signature": "(parser)",
              "intent": "checks long docstring truncated",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestUnicodeHandling",
          "bases": [],
          "docstring": "Test 7: Verify Unicode characters don't break parsing.",
          "methods": [
            {
              "name": "test_unicode_in_docstring",
              "signature": "(parser)",
              "intent": "checks unicode in docstring",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestNestedClassMethods",
          "bases": [],
          "docstring": "Test 8: Verify methods in classes are parsed correctly.",
          "methods": [
            {
              "name": "test_class_methods",
              "signature": "(parser)",
              "intent": "checks class methods",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestDecoratorCapture",
          "bases": [],
          "docstring": "Test 9: Verify decorators are captured in metadata.",
          "methods": [
            {
              "name": "test_decorators_captured",
              "signature": "(parser)",
              "intent": "checks decorators captured",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestLargeFileHandling",
          "bases": [],
          "docstring": "Test 10: Verify large files don't cause truncation.",
          "methods": [
            {
              "name": "test_many_functions",
              "signature": "(parser)",
              "intent": "checks many functions",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestJavaScriptFunctionExtraction",
          "bases": [],
          "docstring": "Test JS function extraction: arrow fns, function expressions, IIFEs, nested, etc...",
          "methods": [
            {
              "name": "test_regular_function_declaration",
              "signature": "(parser)",
              "intent": "checks regular function declaration",
              "is_async": false
            },
            {
              "name": "test_async_function_declaration",
              "signature": "(parser)",
              "intent": "checks async function declaration",
              "is_async": false
            },
            {
              "name": "test_const_arrow_function",
              "signature": "(parser)",
              "intent": "checks const arrow function",
              "is_async": false
            },
            {
              "name": "test_let_arrow_function",
              "signature": "(parser)",
              "intent": "checks let arrow function",
              "is_async": false
            },
            {
              "name": "test_var_arrow_function",
              "signature": "(parser)",
              "intent": "checks var arrow function",
              "is_async": false
            },
            {
              "name": "test_const_function_expression",
              "signature": "(parser)",
              "intent": "checks const function expression",
              "is_async": false
            },
            {
              "name": "test_var_function_expression",
              "signature": "(parser)",
              "intent": "checks var function expression",
              "is_async": false
            },
            {
              "name": "test_iife_named_function",
              "signature": "(parser)",
              "intent": "checks iife named function",
              "is_async": false
            },
            {
              "name": "test_nested_function_in_body",
              "signature": "(parser)",
              "intent": "checks nested function in body",
              "is_async": false
            },
            {
              "name": "test_deeply_nested_functions",
              "signature": "(parser)",
              "intent": "checks deeply nested functions",
              "is_async": false
            },
            {
              "name": "test_module_exports_shorthand",
              "signature": "(parser)",
              "intent": "checks module exports shorthand",
              "is_async": false
            },
            {
              "name": "test_commonjs_require_imports",
              "signature": "(parser)",
              "intent": "checks commonjs require imports",
              "is_async": false
            },
            {
              "name": "test_class_with_methods",
              "signature": "(parser)",
              "intent": "checks class with methods",
              "is_async": false
            },
            {
              "name": "test_export_clause",
              "signature": "(parser)",
              "intent": "checks export clause",
              "is_async": false
            },
            {
              "name": "test_no_duplicate_functions",
              "signature": "(parser)",
              "intent": "checks no duplicate functions",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestMethodSignatureIntegrity",
          "bases": [],
          "docstring": "Additional tests for method signature integrity.",
          "methods": [
            {
              "name": "test_init_signature",
              "signature": "(parser)",
              "intent": "checks init signature",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "parser",
          "signature": "()",
          "intent": "parser",
          "is_async": false
        },
        {
          "name": "parse_python",
          "signature": "(parser,code:str)",
          "intent": "parses python",
          "is_async": false
        },
        {
          "name": "parse_js",
          "signature": "(parser,code:str)",
          "intent": "parses js",
          "is_async": false
        }
      ],
      "imports": [
        "pytest",
        "code2logic.parsers.TreeSitterParser",
        "code2logic.parsers.UniversalParser",
        "code2logic.parsers.is_tree_sitter_available"
      ],
      "exports": [
        "parser",
        "parse_python",
        "TestFunctionNameExtraction",
        "TestSignatureParsing",
        "TestClassNameIntegrity",
        "TestImportParsing",
        "TestExportsCompleteness",
        "TestDocstringTruncation",
        "TestUnicodeHandling",
        "TestNestedClassMethods"
      ]
    },
    {
      "path": "tests/test_reproduction.py",
      "language": "python",
      "lines": 208,
      "classes": [
        {
          "name": "TestYAMLGenerator",
          "bases": [],
          "docstring": "Tests for YAML format generation.",
          "methods": [
            {
              "name": "test_yaml_basic",
              "signature": "()",
              "intent": "checks yaml basic",
              "is_async": false
            },
            {
              "name": "test_yaml_includes_classes",
              "signature": "()",
              "intent": "checks yaml includes classes",
              "is_async": false
            },
            {
              "name": "test_yaml_includes_functions",
              "signature": "()",
              "intent": "checks yaml includes functions",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestGherkinGenerator",
          "bases": [],
          "docstring": "Tests for Gherkin format generation.",
          "methods": [
            {
              "name": "test_gherkin_basic",
              "signature": "()",
              "intent": "checks gherkin basic",
              "is_async": false
            },
            {
              "name": "test_gherkin_has_scenarios",
              "signature": "()",
              "intent": "checks gherkin has scenarios",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestMarkdownGenerator",
          "bases": [],
          "docstring": "Tests for Markdown hybrid format generation.",
          "methods": [
            {
              "name": "test_markdown_basic",
              "signature": "()",
              "intent": "checks markdown basic",
              "is_async": false
            },
            {
              "name": "test_markdown_has_yaml_section",
              "signature": "()",
              "intent": "checks markdown has yaml section",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestReproductionMetrics",
          "bases": [],
          "docstring": "Tests for reproduction metrics calculation.",
          "methods": [
            {
              "name": "test_metrics_basic",
              "signature": "()",
              "intent": "checks metrics basic",
              "is_async": false
            },
            {
              "name": "test_metrics_identical_code",
              "signature": "()",
              "intent": "checks metrics identical code",
              "is_async": false
            },
            {
              "name": "test_metrics_different_code",
              "signature": "()",
              "intent": "checks metrics different code",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestChunkedReproduction",
          "bases": [],
          "docstring": "Tests for chunked reproduction functionality.",
          "methods": [
            {
              "name": "test_estimate_tokens",
              "signature": "()",
              "intent": "checks estimate tokens",
              "is_async": false
            },
            {
              "name": "test_get_llm_limit",
              "signature": "()",
              "intent": "checks get llm limit",
              "is_async": false
            },
            {
              "name": "test_chunk_yaml_spec",
              "signature": "()",
              "intent": "checks chunk yaml spec",
              "is_async": false
            },
            {
              "name": "test_chunk_gherkin_spec",
              "signature": "()",
              "intent": "checks chunk gherkin spec",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestProjectAnalysis",
          "bases": [],
          "docstring": "Tests for project analysis.",
          "methods": [
            {
              "name": "test_analyze_samples",
              "signature": "()",
              "intent": "checks analyze samples",
              "is_async": false
            },
            {
              "name": "test_analyze_detects_classes",
              "signature": "()",
              "intent": "checks analyze detects classes",
              "is_async": false
            },
            {
              "name": "test_analyze_detects_functions",
              "signature": "()",
              "intent": "checks analyze detects functions",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestLogicMLGenerator",
          "bases": [],
          "docstring": "Tests for LogicML format generation.",
          "methods": [
            {
              "name": "test_logicml_basic",
              "signature": "()",
              "intent": "checks logicml basic",
              "is_async": false
            },
            {
              "name": "test_logicml_includes_classes",
              "signature": "()",
              "intent": "checks logicml includes classes",
              "is_async": false
            },
            {
              "name": "test_logicml_includes_signatures",
              "signature": "()",
              "intent": "checks logicml includes signatures",
              "is_async": false
            },
            {
              "name": "test_logicml_convenience_function",
              "signature": "()",
              "intent": "checks logicml convenience function",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestFormatComparison",
          "bases": [],
          "docstring": "Tests comparing different formats.",
          "methods": [
            {
              "name": "test_yaml_compact",
              "signature": "()",
              "intent": "checks yaml compact",
              "is_async": false
            },
            {
              "name": "test_all_formats_produce_output",
              "signature": "()",
              "intent": "checks all formats produce output",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "pytest",
        "sys",
        "pathlib.Path",
        "code2logic.analyze_project",
        "code2logic.ReproductionMetrics",
        "code2logic.generators.YAMLGenerator",
        "code2logic.gherkin.GherkinGenerator",
        "code2logic.markdown_format.MarkdownHybridGenerator",
        "code2logic.logicml.LogicMLGenerator",
        "code2logic.logicml.generate_logicml"
      ],
      "exports": [
        "TestYAMLGenerator",
        "TestGherkinGenerator",
        "TestMarkdownGenerator",
        "TestReproductionMetrics",
        "TestChunkedReproduction",
        "TestProjectAnalysis",
        "TestLogicMLGenerator",
        "TestFormatComparison"
      ]
    },
    {
      "path": "tests/test_shared_utils.py",
      "language": "python",
      "lines": 249,
      "classes": [
        {
          "name": "TestCompactImports",
          "bases": [],
          "docstring": "Tests for compact_imports function.",
          "methods": [
            {
              "name": "test_groups_submodules",
              "signature": "()",
              "intent": "checks groups submodules",
              "is_async": false
            },
            {
              "name": "test_preserves_standalone",
              "signature": "()",
              "intent": "checks preserves standalone",
              "is_async": false
            },
            {
              "name": "test_limits_output",
              "signature": "()",
              "intent": "checks limits output",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            },
            {
              "name": "test_skips_module_module_duplicates",
              "signature": "()",
              "intent": "checks skips module module duplicates",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestDeduplicateImports",
          "bases": [],
          "docstring": "Tests for deduplicate_imports function.",
          "methods": [
            {
              "name": "test_removes_base_when_specific_exists",
              "signature": "()",
              "intent": "checks removes base when specific exists",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestAbbreviateType",
          "bases": [],
          "docstring": "Tests for abbreviate_type function.",
          "methods": [
            {
              "name": "test_simple_types",
              "signature": "()",
              "intent": "checks simple types",
              "is_async": false
            },
            {
              "name": "test_complex_types",
              "signature": "()",
              "intent": "checks complex types",
              "is_async": false
            },
            {
              "name": "test_optional_type",
              "signature": "()",
              "intent": "checks optional type",
              "is_async": false
            },
            {
              "name": "test_preserves_unknown",
              "signature": "()",
              "intent": "checks preserves unknown",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestExpandType",
          "bases": [],
          "docstring": "Tests for expand_type function.",
          "methods": [
            {
              "name": "test_expands_abbreviated",
              "signature": "()",
              "intent": "checks expands abbreviated",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestBuildSignature",
          "bases": [],
          "docstring": "Tests for build_signature function.",
          "methods": [
            {
              "name": "test_removes_self_by_default",
              "signature": "()",
              "intent": "checks removes self by default",
              "is_async": false
            },
            {
              "name": "test_includes_self_when_requested",
              "signature": "()",
              "intent": "checks includes self when requested",
              "is_async": false
            },
            {
              "name": "test_removes_cls",
              "signature": "()",
              "intent": "checks removes cls",
              "is_async": false
            },
            {
              "name": "test_abbreviates_types",
              "signature": "()",
              "intent": "checks abbreviates types",
              "is_async": false
            },
            {
              "name": "test_truncates_params",
              "signature": "()",
              "intent": "checks truncates params",
              "is_async": false
            },
            {
              "name": "test_includes_return_type",
              "signature": "()",
              "intent": "checks includes return type",
              "is_async": false
            },
            {
              "name": "test_no_return_type",
              "signature": "()",
              "intent": "checks no return type",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestRemoveSelfFromParams",
          "bases": [],
          "docstring": "Tests for remove_self_from_params function.",
          "methods": [
            {
              "name": "test_removes_self",
              "signature": "()",
              "intent": "checks removes self",
              "is_async": false
            },
            {
              "name": "test_removes_cls",
              "signature": "()",
              "intent": "checks removes cls",
              "is_async": false
            },
            {
              "name": "test_removes_typed_self",
              "signature": "()",
              "intent": "checks removes typed self",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCategorizeFunction",
          "bases": [],
          "docstring": "Tests for categorize_function function.",
          "methods": [
            {
              "name": "test_read_category",
              "signature": "()",
              "intent": "checks read category",
              "is_async": false
            },
            {
              "name": "test_create_category",
              "signature": "()",
              "intent": "checks create category",
              "is_async": false
            },
            {
              "name": "test_update_category",
              "signature": "()",
              "intent": "checks update category",
              "is_async": false
            },
            {
              "name": "test_delete_category",
              "signature": "()",
              "intent": "checks delete category",
              "is_async": false
            },
            {
              "name": "test_handles_method_names",
              "signature": "()",
              "intent": "checks handles method names",
              "is_async": false
            },
            {
              "name": "test_returns_other_for_unknown",
              "signature": "()",
              "intent": "checks returns other for unknown",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestExtractDomain",
          "bases": [],
          "docstring": "Tests for extract_domain function.",
          "methods": [
            {
              "name": "test_extracts_known_domain",
              "signature": "()",
              "intent": "checks extracts known domain",
              "is_async": false
            },
            {
              "name": "test_handles_windows_paths",
              "signature": "()",
              "intent": "checks handles windows paths",
              "is_async": false
            },
            {
              "name": "test_returns_parent_for_unknown",
              "signature": "()",
              "intent": "checks returns parent for unknown",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestComputeHash",
          "bases": [],
          "docstring": "Tests for compute_hash function.",
          "methods": [
            {
              "name": "test_returns_hex_string",
              "signature": "()",
              "intent": "checks returns hex string",
              "is_async": false
            },
            {
              "name": "test_respects_length",
              "signature": "()",
              "intent": "checks respects length",
              "is_async": false
            },
            {
              "name": "test_same_input_same_hash",
              "signature": "()",
              "intent": "checks same input same hash",
              "is_async": false
            },
            {
              "name": "test_different_input_different_hash",
              "signature": "()",
              "intent": "checks different input different hash",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestTruncateDocstring",
          "bases": [],
          "docstring": "Tests for truncate_docstring function.",
          "methods": [
            {
              "name": "test_truncates_long",
              "signature": "()",
              "intent": "checks truncates long",
              "is_async": false
            },
            {
              "name": "test_preserves_short",
              "signature": "()",
              "intent": "checks preserves short",
              "is_async": false
            },
            {
              "name": "test_removes_markers",
              "signature": "()",
              "intent": "checks removes markers",
              "is_async": false
            },
            {
              "name": "test_stops_at_sentence_end",
              "signature": "()",
              "intent": "checks stops at sentence end",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestEscapeForYaml",
          "bases": [],
          "docstring": "Tests for escape_for_yaml function.",
          "methods": [
            {
              "name": "test_removes_newlines",
              "signature": "()",
              "intent": "checks removes newlines",
              "is_async": false
            },
            {
              "name": "test_quotes_special_chars",
              "signature": "()",
              "intent": "checks quotes special chars",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCleanIdentifier",
          "bases": [],
          "docstring": "Tests for clean_identifier function.",
          "methods": [
            {
              "name": "test_removes_whitespace",
              "signature": "()",
              "intent": "checks removes whitespace",
              "is_async": false
            },
            {
              "name": "test_handles_empty",
              "signature": "()",
              "intent": "checks handles empty",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [],
      "imports": [
        "pytest",
        "code2logic.shared_utils.compact_imports",
        "code2logic.shared_utils.deduplicate_imports",
        "code2logic.shared_utils.abbreviate_type",
        "code2logic.shared_utils.expand_type",
        "code2logic.shared_utils.build_signature",
        "code2logic.shared_utils.remove_self_from_params",
        "code2logic.shared_utils.categorize_function",
        "code2logic.shared_utils.extract_domain",
        "code2logic.shared_utils.compute_hash"
      ],
      "exports": [
        "TestCompactImports",
        "TestDeduplicateImports",
        "TestAbbreviateType",
        "TestExpandType",
        "TestBuildSignature",
        "TestRemoveSelfFromParams",
        "TestCategorizeFunction",
        "TestExtractDomain",
        "TestComputeHash",
        "TestTruncateDocstring"
      ]
    },
    {
      "path": "tests/test_yaml_compact.py",
      "language": "python",
      "lines": 187,
      "classes": [
        {
          "name": "TestYAMLShortKeys",
          "bases": [],
          "docstring": "Test that YAML uses short keys.",
          "methods": [
            {
              "name": "test_short_keys_in_module",
              "signature": "(sample_project)",
              "intent": "checks short keys in module",
              "is_async": false
            },
            {
              "name": "test_short_keys_in_class",
              "signature": "(sample_project)",
              "intent": "checks short keys in class",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestSelfRemoval",
          "bases": [],
          "docstring": "Test that 'self' is removed from method signatures.",
          "methods": [
            {
              "name": "test_no_self_in_signature",
              "signature": "(sample_project)",
              "intent": "checks no self in signature",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestImportDeduplication",
          "bases": [],
          "docstring": "Test that imports are deduplicated.",
          "methods": [
            {
              "name": "test_typing_grouped",
              "signature": "(sample_project)",
              "intent": "checks typing grouped",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestEmptyFieldsOmitted",
          "bases": [],
          "docstring": "Test that empty fields are omitted.",
          "methods": [
            {
              "name": "test_empty_bases_omitted",
              "signature": "(sample_project)",
              "intent": "checks empty bases omitted",
              "is_async": false
            },
            {
              "name": "test_empty_decorators_omitted",
              "signature": "(sample_project)",
              "intent": "checks empty decorators omitted",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestMetaLegend",
          "bases": [],
          "docstring": "Test that meta.legend provides key transparency.",
          "methods": [
            {
              "name": "test_meta_legend_structure",
              "signature": "(sample_project)",
              "intent": "checks meta legend structure",
              "is_async": false
            },
            {
              "name": "test_meta_legend_in_output",
              "signature": "(sample_project)",
              "intent": "checks meta legend in output",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestCompactSizeReduction",
          "bases": [],
          "docstring": "Test that compact format reduces output size for larger projects.",
          "methods": [
            {
              "name": "test_compact_smaller_for_large_projects",
              "signature": "()",
              "intent": "checks compact smaller for large projects",
              "is_async": false
            }
          ]
        },
        {
          "name": "TestDocstringTruncation",
          "bases": [],
          "docstring": "Test that docstrings are truncated.",
          "methods": [
            {
              "name": "test_class_docstring_truncated",
              "signature": "(sample_project)",
              "intent": "checks class docstring truncated",
              "is_async": false
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "sample_project",
          "signature": "()",
          "intent": "sample project",
          "is_async": false
        }
      ],
      "imports": [
        "pytest",
        "yaml",
        "code2logic.analyze_project",
        "code2logic.generators.YAMLGenerator",
        "code2logic.models.ProjectInfo",
        "code2logic.models.ModuleInfo",
        "code2logic.models.ClassInfo",
        "code2logic.models.FunctionInfo"
      ],
      "exports": [
        "sample_project",
        "TestYAMLShortKeys",
        "TestSelfRemoval",
        "TestImportDeduplication",
        "TestEmptyFieldsOmitted",
        "TestMetaLegend",
        "TestCompactSizeReduction",
        "TestDocstringTruncation"
      ]
    }
  ]
}