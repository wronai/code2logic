"""
Test templates for different test types and frameworks.
"""

from dataclasses import dataclass
from typing import List, Optional


@dataclass
class TestTemplate:
    """Template for generating test code."""
    name: str
    framework: str = 'pytest'
    
    def render_test_file_header(self, module_path: str, imports: List[str] = None) -> str:
        """Render the header of a test file."""
        imports = imports or []
        
        # Convert module path to import path
        import_path = module_path.replace('/', '.').replace('\\', '.')
        if import_path.endswith('.py'):
            import_path = import_path[:-3]
        
        lines = [
            '"""',
            f'Auto-generated tests for {module_path}',
            '',
            'Generated by logic2test from Code2Logic output.',
            '"""',
            '',
            'import pytest',
            'from unittest.mock import Mock, patch, MagicMock',
            '',
        ]
        
        # Add module import if valid
        if import_path and not import_path.startswith('.'):
            lines.append(f'# from {import_path} import *  # Uncomment after review')
        
        lines.append('')
        lines.append('')
        
        return '\n'.join(lines)
    
    def render_function_test(
        self, 
        func_name: str,
        params: List[str],
        return_type: Optional[str] = None,
        docstring: Optional[str] = None,
        is_async: bool = False,
        class_name: Optional[str] = None
    ) -> str:
        """Render a test for a function."""
        # Build test function name
        if class_name:
            test_name = f'test_{class_name.lower()}_{func_name}'
        else:
            test_name = f'test_{func_name}'
        
        # Handle dunder methods
        if func_name.startswith('__') and func_name.endswith('__'):
            test_name = f'test_{func_name[2:-2]}_dunder'
        
        # Build param fixtures/mocks
        param_setup = []
        param_values = []
        for param in params:
            if 'path' in param.lower():
                param_setup.append(f'    {param} = "/tmp/test_path"')
                param_values.append(param)
            elif 'name' in param.lower() or 'str' in param.lower():
                param_setup.append(f'    {param} = "test_value"')
                param_values.append(param)
            elif 'count' in param.lower() or 'num' in param.lower() or 'limit' in param.lower():
                param_setup.append(f'    {param} = 10')
                param_values.append(param)
            elif 'flag' in param.lower() or 'is_' in param.lower() or 'has_' in param.lower():
                param_setup.append(f'    {param} = True')
                param_values.append(param)
            elif param.lower() in ('verbose', 'debug', 'strict', 'force'):
                param_setup.append(f'    {param} = False')
                param_values.append(param)
            else:
                param_setup.append(f'    {param} = Mock()')
                param_values.append(param)
        
        # Build assertion based on return type
        if return_type:
            if return_type in ('str', 'String'):
                assertion = '    assert isinstance(result, str)'
            elif return_type in ('int', 'Integer'):
                assertion = '    assert isinstance(result, int)'
            elif return_type in ('bool', 'Boolean'):
                assertion = '    assert isinstance(result, bool)'
            elif return_type.startswith('List') or return_type.startswith('list'):
                assertion = '    assert isinstance(result, list)'
            elif return_type.startswith('Dict') or return_type.startswith('dict'):
                assertion = '    assert isinstance(result, dict)'
            elif return_type == 'None':
                assertion = '    assert result is None'
            else:
                assertion = '    assert result is not None  # TODO: Add specific assertion'
        else:
            assertion = '    # TODO: Add assertions based on expected behavior'
        
        # Build the test function
        async_prefix = 'async ' if is_async else ''
        await_prefix = 'await ' if is_async else ''
        
        lines = []
        
        # Add docstring as comment
        if docstring:
            lines.append(f'# Test for: {docstring[:60]}')
        
        if is_async:
            lines.append('@pytest.mark.asyncio')
        
        lines.append(f'{async_prefix}def {test_name}():')
        lines.append(f'    """Test {func_name} function."""')
        lines.append('    # Arrange')
        
        if param_setup:
            lines.extend(param_setup)
        else:
            lines.append('    pass  # No parameters')
        
        lines.append('')
        lines.append('    # Act')
        
        if class_name:
            lines.append(f'    # instance = {class_name}()')
            if param_values:
                lines.append(f'    # result = {await_prefix}instance.{func_name}({", ".join(param_values)})')
            else:
                lines.append(f'    # result = {await_prefix}instance.{func_name}()')
        else:
            if param_values:
                lines.append(f'    # result = {await_prefix}{func_name}({", ".join(param_values)})')
            else:
                lines.append(f'    # result = {await_prefix}{func_name}()')
        
        lines.append('')
        lines.append('    # Assert')
        lines.append(assertion)
        lines.append('')
        lines.append('')
        
        return '\n'.join(lines)
    
    def render_class_test(
        self,
        class_name: str,
        bases: List[str],
        is_dataclass: bool = False,
        fields: List[dict] = None,
        docstring: Optional[str] = None
    ) -> str:
        """Render tests for a class."""
        fields = fields or []
        
        lines = []
        
        if docstring:
            lines.append(f'# Tests for: {docstring[:60]}')
        
        lines.append(f'class Test{class_name}:')
        lines.append(f'    """Test suite for {class_name}."""')
        lines.append('')
        
        # Test instantiation
        lines.append(f'    def test_{class_name.lower()}_instantiation(self):')
        lines.append(f'        """Test that {class_name} can be instantiated."""')
        
        if is_dataclass and fields:
            field_args = []
            for f in fields[:5]:
                fname = f.get('n', f.get('name', ''))
                ftype = f.get('t', f.get('type', 'Any'))
                if 'str' in ftype.lower():
                    field_args.append(f'{fname}="test"')
                elif 'int' in ftype.lower():
                    field_args.append(f'{fname}=0')
                elif 'bool' in ftype.lower():
                    field_args.append(f'{fname}=True')
                elif 'list' in ftype.lower():
                    field_args.append(f'{fname}=[]')
                elif 'dict' in ftype.lower():
                    field_args.append(f'{fname}={{}}')
                else:
                    field_args.append(f'{fname}=None')
            
            lines.append(f'        # instance = {class_name}({", ".join(field_args)})')
        else:
            lines.append(f'        # instance = {class_name}()')
        
        lines.append(f'        # assert instance is not None')
        lines.append('        pass  # TODO: Implement after uncommenting imports')
        lines.append('')
        
        # Test inheritance
        if bases:
            lines.append(f'    def test_{class_name.lower()}_inheritance(self):')
            lines.append(f'        """Test that {class_name} has correct base classes."""')
            for base in bases[:3]:
                if base not in ('object', 'ABC'):
                    lines.append(f'        # assert issubclass({class_name}, {base})')
            lines.append('        pass  # TODO: Verify inheritance')
            lines.append('')
        
        lines.append('')
        
        return '\n'.join(lines)
    
    def render_dataclass_test(
        self,
        class_name: str,
        fields: List[dict]
    ) -> str:
        """Render tests specifically for dataclasses."""
        lines = []
        
        lines.append(f'class Test{class_name}Dataclass:')
        lines.append(f'    """Dataclass-specific tests for {class_name}."""')
        lines.append('')
        
        # Test field access
        lines.append(f'    def test_{class_name.lower()}_fields(self):')
        lines.append(f'        """Test dataclass fields are accessible."""')
        lines.append(f'        # instance = {class_name}(...)')
        
        for f in fields[:5]:
            fname = f.get('n', f.get('name', ''))
            if fname:
                lines.append(f'        # assert hasattr(instance, "{fname}")')
        
        lines.append('        pass')
        lines.append('')
        
        # Test equality
        lines.append(f'    def test_{class_name.lower()}_equality(self):')
        lines.append(f'        """Test dataclass equality comparison."""')
        lines.append(f'        # instance1 = {class_name}(...)')
        lines.append(f'        # instance2 = {class_name}(...)')
        lines.append('        # assert instance1 == instance2')
        lines.append('        pass')
        lines.append('')
        lines.append('')
        
        return '\n'.join(lines)
