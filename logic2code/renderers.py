"""
Code renderers for different programming languages.
"""

import re
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set

# Import from sibling package
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

from logic2test.parsers import ClassSpec, FunctionSpec, ModuleSpec


@dataclass
class RenderConfig:
    """Configuration for code rendering."""
    include_docstrings: bool = True
    include_type_hints: bool = True
    stubs_only: bool = False
    line_length: int = 100
    indent: str = '    '


class BaseRenderer(ABC):
    """Abstract base class for language-specific renderers."""
    
    def __init__(self, config: Optional[RenderConfig] = None):
        self.config = config or RenderConfig()
    
    @abstractmethod
    def render_module(self, module: ModuleSpec) -> str:
        """Render a complete module."""
        pass
    
    @abstractmethod
    def render_class(self, cls: ClassSpec) -> str:
        """Render a class definition."""
        pass
    
    @abstractmethod
    def render_function(self, func: FunctionSpec) -> str:
        """Render a function definition."""
        pass


class PythonRenderer(BaseRenderer):
    """Python code renderer."""
    
    BUILTIN_TYPES = {
        'str', 'int', 'float', 'bool', 'bytes', 'list', 'dict', 'set', 'tuple',
        'List', 'Dict', 'Set', 'Tuple', 'Optional', 'Union', 'Any', 'Callable',
        'Iterable', 'Iterator', 'Generator', 'Sequence', 'Mapping',
    }
    
    def render_module(self, module: ModuleSpec) -> str:
        """Render a complete Python module."""
        parts = []
        
        # Module docstring
        parts.append(f'"""')
        parts.append(f'Generated module: {module.path}')
        parts.append(f'')
        parts.append(f'Auto-generated by logic2code from Code2Logic output.')
        parts.append(f'"""')
        parts.append('')
        
        # Collect imports
        imports = self._collect_imports(module)
        if imports:
            parts.append(imports)
            parts.append('')
        
        # Constants
        for const in module.constants[:20]:
            const_code = self._render_constant(const)
            if const_code:
                parts.append(const_code)
        
        if module.constants:
            parts.append('')
        
        # Classes
        for cls in module.classes:
            parts.append(self.render_class(cls))
            parts.append('')
        
        # Functions
        for func in module.functions:
            parts.append(self.render_function(func))
            parts.append('')
        
        return '\n'.join(parts)
    
    def _collect_imports(self, module: ModuleSpec) -> str:
        """Collect and organize imports for a module."""
        stdlib_imports: Set[str] = set()
        typing_imports: Set[str] = set()
        third_party: Set[str] = set()
        local_imports: Set[str] = set()
        
        # Always need these for generated code
        typing_imports.add('from typing import Any, Optional, List, Dict')
        
        # Check for dataclasses
        has_dataclass = any(cls.is_dataclass for cls in module.classes)
        if has_dataclass:
            stdlib_imports.add('from dataclasses import dataclass, field')
        
        # Check for async
        has_async = any(func.is_async for func in module.functions)
        has_async = has_async or any(
            any(m.is_async for m in cls.methods) 
            for cls in module.classes
        )
        if has_async:
            typing_imports.add('from typing import Coroutine')
        
        # Check for ABC
        has_abc = any('ABC' in cls.bases for cls in module.classes)
        if has_abc:
            stdlib_imports.add('from abc import ABC, abstractmethod')
        
        # Check for Enum
        has_enum = any('Enum' in cls.bases for cls in module.classes)
        if has_enum:
            stdlib_imports.add('from enum import Enum, auto')
        
        # Parse original imports
        for imp in module.imports:
            if isinstance(imp, str):
                if imp.startswith('from typing'):
                    typing_imports.add(imp)
                elif imp.startswith('from ') or imp.startswith('import '):
                    if any(imp.startswith(f'from {lib}') or imp.startswith(f'import {lib}') 
                           for lib in ['os', 're', 'sys', 'json', 'pathlib', 'collections', 'functools']):
                        stdlib_imports.add(imp)
                    else:
                        third_party.add(imp)
        
        lines = []
        
        # Future imports first
        lines.append('from __future__ import annotations')
        lines.append('')
        
        # Standard library
        if stdlib_imports:
            lines.extend(sorted(stdlib_imports))
            lines.append('')
        
        # Typing
        if typing_imports:
            lines.extend(sorted(typing_imports))
            lines.append('')
        
        # Third-party (commented out for safety)
        if third_party:
            lines.append('# Third-party imports (uncomment as needed)')
            for imp in sorted(third_party):
                lines.append(f'# {imp}')
            lines.append('')
        
        return '\n'.join(lines)
    
    def _render_constant(self, const: Dict[str, Any]) -> str:
        """Render a constant definition."""
        if isinstance(const, str):
            return f'{const} = None  # TODO: Set value'
        
        name = const.get('n', const.get('name', ''))
        if not name:
            return ''
        
        value = const.get('v', const.get('value', 'None'))
        type_hint = const.get('t', const.get('type', ''))
        
        if value == '-' or value is None:
            value = 'None  # TODO: Set value'
        elif isinstance(value, str) and not value.startswith(("'", '"', '[', '{', '(')) and not value.replace('.', '').replace('-', '').isdigit():
            # String value that needs quotes
            if value not in ('None', 'True', 'False') and not value.startswith('0x'):
                value = f'"{value}"'
        
        if type_hint and type_hint != '-' and self.config.include_type_hints:
            return f'{name}: {type_hint} = {value}'
        else:
            return f'{name} = {value}'
    
    def render_class(self, cls: ClassSpec) -> str:
        """Render a Python class definition."""
        lines = []
        indent = self.config.indent
        
        # Decorators
        if cls.is_dataclass:
            lines.append('@dataclass')
        
        for dec in cls.decorators if hasattr(cls, 'decorators') else []:
            if dec and dec != 'dataclass':
                lines.append(f'@{dec}')
        
        # Class declaration
        bases_str = ', '.join(cls.bases) if cls.bases else ''
        if bases_str:
            lines.append(f'class {cls.name}({bases_str}):')
        else:
            lines.append(f'class {cls.name}:')
        
        # Docstring
        if self.config.include_docstrings and cls.docstring:
            doc = cls.docstring.replace('"""', "'''")
            lines.append(f'{indent}"""{doc}"""')
        else:
            lines.append(f'{indent}"""Class {cls.name}."""')
        
        lines.append('')
        
        # Dataclass fields
        if cls.is_dataclass and cls.fields:
            for fld in cls.fields:
                field_line = self._render_field(fld)
                lines.append(f'{indent}{field_line}')
            lines.append('')
        
        # Class attributes (for non-dataclasses)
        if not cls.is_dataclass and cls.attributes:
            for attr in cls.attributes[:10]:
                attr_name = attr.get('n', attr.get('name', ''))
                attr_type = attr.get('t', attr.get('type', 'Any'))
                if attr_name:
                    if self.config.include_type_hints and attr_type:
                        lines.append(f'{indent}{attr_name}: {attr_type}')
                    else:
                        lines.append(f'{indent}{attr_name} = None')
            lines.append('')
        
        # Methods
        if cls.methods:
            for method in cls.methods:
                method_code = self._render_method(method)
                for line in method_code.split('\n'):
                    lines.append(f'{indent}{line}' if line else '')
                lines.append('')
        else:
            # Empty class
            if not cls.fields and not cls.attributes:
                lines.append(f'{indent}pass')
        
        return '\n'.join(lines)
    
    def _render_field(self, fld: Dict[str, Any]) -> str:
        """Render a dataclass field."""
        name = fld.get('n', fld.get('name', ''))
        type_hint = fld.get('t', fld.get('type', 'Any'))
        default = fld.get('default')
        factory = fld.get('factory', fld.get('default_factory'))
        
        if factory:
            return f'{name}: {type_hint} = field(default_factory={factory})'
        elif default is not None:
            return f'{name}: {type_hint} = {default}'
        else:
            # Check if type is Optional or has None default
            if 'Optional' in type_hint or type_hint == 'None':
                return f'{name}: {type_hint} = None'
            return f'{name}: {type_hint}'
    
    def _render_method(self, method: FunctionSpec) -> str:
        """Render a method (function inside a class)."""
        return self._render_function_internal(method, is_method=True)
    
    def render_function(self, func: FunctionSpec) -> str:
        """Render a standalone function."""
        return self._render_function_internal(func, is_method=False)
    
    def _render_function_internal(self, func: FunctionSpec, is_method: bool = False) -> str:
        """Internal function rendering logic."""
        lines = []
        indent = self.config.indent
        
        # Decorators
        for dec in func.decorators:
            if dec:
                lines.append(f'@{dec}')
        
        # Build signature
        async_prefix = 'async ' if func.is_async else ''
        
        # Parameters
        params = self._build_params(func, is_method)
        params_str = ', '.join(params)
        
        # Return type
        return_type = ''
        if self.config.include_type_hints and func.return_type:
            ret = func.return_type
            if func.is_async and not ret.startswith('Coroutine') and not ret.startswith('Awaitable'):
                return_type = f' -> {ret}'
            else:
                return_type = f' -> {ret}'
        
        # Function declaration
        lines.append(f'{async_prefix}def {func.name}({params_str}){return_type}:')
        
        # Docstring
        if self.config.include_docstrings:
            doc = func.docstring if func.docstring else f'{func.name} function.'
            doc = doc.replace('"""', "'''")[:80]
            lines.append(f'{indent}"""{doc}"""')
        
        # Body
        if self.config.stubs_only:
            lines.append(f'{indent}...')
        else:
            lines.append(f'{indent}raise NotImplementedError("TODO: Implement {func.name}")')
        
        return '\n'.join(lines)
    
    def _build_params(self, func: FunctionSpec, is_method: bool) -> List[str]:
        """Build parameter list for a function."""
        params = []
        
        # Add self for methods
        if is_method and func.name != '__new__':
            params.append('self')
        
        # Parse original signature for params with types and defaults
        sig = func.signature
        if sig and sig != '()':
            # Extract params from signature
            match = re.search(r'\(([^)]*)\)', sig)
            if match:
                sig_params = match.group(1)
                # Split carefully handling nested brackets
                parsed = self._split_params(sig_params)
                for p in parsed:
                    p = p.strip()
                    if not p or p in ('self', 'cls'):
                        continue
                    if p.startswith('...'):
                        continue
                    params.append(p)
        
        # Fallback to param names if no signature details
        if len(params) <= 1 and func.params:
            for param_name in func.params:
                if param_name in ('self', 'cls'):
                    continue
                if self.config.include_type_hints:
                    params.append(f'{param_name}: Any')
                else:
                    params.append(param_name)
        
        return params
    
    def _split_params(self, params_str: str) -> List[str]:
        """Split parameter string handling nested brackets."""
        if not params_str:
            return []
        
        parts = []
        depth = 0
        current = []
        
        for char in params_str:
            if char in '([{<':
                depth += 1
            elif char in ')]}>':
                depth -= 1
            
            if char == ',' and depth == 0:
                parts.append(''.join(current).strip())
                current = []
            else:
                current.append(char)
        
        if current:
            parts.append(''.join(current).strip())
        
        return parts
    
    def render_init_file(self, modules: List[ModuleSpec]) -> str:
        """Render an __init__.py file with exports."""
        lines = [
            '"""',
            'Package exports.',
            '',
            'Auto-generated by logic2code.',
            '"""',
            '',
        ]
        
        # Collect public classes and functions
        exports = []
        
        for module in modules:
            module_name = Path(module.path).stem
            
            for cls in module.classes:
                if not cls.name.startswith('_'):
                    lines.append(f'from .{module_name} import {cls.name}')
                    exports.append(cls.name)
            
            for func in module.functions:
                if not func.name.startswith('_'):
                    lines.append(f'from .{module_name} import {func.name}')
                    exports.append(func.name)
        
        lines.append('')
        lines.append(f'__all__ = {exports!r}')
        
        return '\n'.join(lines)
